/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 25790:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(36765), __webpack_require__(26222) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
})(function() {

var __meta__ = {
    id: "treeview.draganddrop",
    name: "Hierarchical Drag & Drop",
    category: "framework",
    depends: [ "core", "draganddrop" ],
    advanced: true
};

(function($, undefined) {
    var kendo = window.kendo;
    var ui = kendo.ui;
    var extend = $.extend;
    var VISIBILITY = "visibility";
    var KSTATEHOVER = "k-hover";
    var INPUTSELECTOR = "input,a:not(.k-in),textarea,.k-multiselect-wrap,select,button,a.k-button>.k-icon,button.k-button>.k-icon,span.k-icon.k-i-arrow-60-right,span.k-icon.k-i-arrow-45-down-right";
    var DROPHINTTEMPLATE = "<div class='k-drop-hint k-drop-hint-h'>" +
                                "<div class='k-drop-hint-start'></div>" +
                                "<div class='k-drop-hint-line'></div>" +
                            "</div>";

    ui.HierarchicalDragAndDrop = kendo.Class.extend({
        init: function(element, options) {
            this.element = element;
            this.hovered = element;
            this.options = extend({
                dragstart: $.noop, drag: $.noop, drop: $.noop, dragend: $.noop
            }, options);

            this._draggable = new ui.Draggable(element, {
                ignore: INPUTSELECTOR,
                filter: options.filter,
                autoScroll: options.autoScroll,
                cursorOffset: {
                    left: 10,
                    top: kendo.support.mobileOS ? -40 / kendo.support.zoomLevel() : 10
                },
                hint: this._hint.bind(this),
                dragstart: this.dragstart.bind(this),
                dragcancel: this.dragcancel.bind(this),
                drag: this.drag.bind(this),
                dragend: this.dragend.bind(this),
                $angular: options.$angular,
                holdToDrag: options.holdToDrag
            });
        },

        _hint: function(element) {
            return "<div class='k-drag-clue'>" +
                        "<span class='k-icon k-drag-status'></span>" +
                        this.options.hintText(element) +
                    "</div>";
        },

        _removeTouchHover: function() {
            if (kendo.support.touch && this.hovered) {
                this.hovered.find("." + KSTATEHOVER).removeClass(KSTATEHOVER);
                this.hovered = false;
            }
        },

        _hintStatus: function(newStatus) {
            var statusElement = this._draggable.hint.find(".k-drag-status")[0];

            if (newStatus) {
                statusElement.className = "k-icon k-drag-status " + newStatus;
            } else {
                return kendo.trim(statusElement.className.replace(/(p|k)-(icon|drag-status)/g, ""));
            }
        },

        dragstart: function(e) {
            this.source = e.currentTarget.closest(this.options.itemSelector);

            if (this.options.dragstart(this.source)) {
                e.preventDefault();
            }

            if (this.options.reorderable) {
                this.dropHint = $(DROPHINTTEMPLATE)
                    .css(VISIBILITY, "hidden")
                    .appendTo(this.element);
            } else {
                this.dropHint = $();
            }
        },

        drag: function(e) {
            var options = this.options;
            var source = this.source;
            var target = this.dropTarget = $(kendo.eventTarget(e));
            var container = target.closest(options.allowedContainers);
            var hoveredItem, itemHeight, itemTop, itemContent, delta;
            var insertOnTop, insertOnBottom, addChild;
            var itemData, position, status;

            if (!container.length) {
                // dragging outside of allowed elements
                status = "k-i-cancel";
                this._removeTouchHover();
            } else if (source[0] == target[0] || options.contains(source[0], target[0])) {
                // dragging item within itself
                status = "k-i-cancel";
            } else {
                // moving or reordering item
                status = "k-i-insert-middle";

                itemData = options.itemFromTarget(target);
                hoveredItem = itemData.item;

                if (hoveredItem.length) {
                    this._removeTouchHover();
                    itemHeight = kendo._outerHeight(hoveredItem);
                    itemContent = itemData.content;

                    if (options.reorderable) {
                        delta = itemHeight / (itemContent.length > 0 ? 4 : 2);
                        itemTop = kendo.getOffset(hoveredItem).top;

                        insertOnTop = e.y.location < (itemTop + delta);
                        insertOnBottom = (itemTop + itemHeight - delta) < e.y.location;
                        addChild = itemContent.length && !insertOnTop && !insertOnBottom;
                    } else {
                        addChild = true;
                        insertOnTop = false;
                        insertOnBottom = false;
                    }

                    this.hovered = addChild ? container : false;

                    this.dropHint.css(VISIBILITY, addChild ? "hidden" : "visible");

                    if (this._lastHover && this._lastHover[0] != itemContent[0]) {
                        this._lastHover.removeClass(KSTATEHOVER);
                    }

                    this._lastHover = itemContent.toggleClass(KSTATEHOVER, addChild);

                    if (addChild) {
                        status = "k-i-plus";
                    } else {
                        position = hoveredItem.position();
                        position.top += insertOnTop ? 0 : itemHeight;

                        this.dropHint.css(position)
                            [insertOnTop ? "prependTo" : "appendTo"]
                            (options.dropHintContainer(hoveredItem));

                        if (insertOnTop && itemData.first) {
                            status = "k-i-insert-up";
                        }

                        if (insertOnBottom && itemData.last) {
                            status = "k-i-insert-down";
                        }
                    }
                } else if (target[0] != this.dropHint[0]) {
                    if (this._lastHover) {
                        this._lastHover.removeClass(KSTATEHOVER);
                    }

                    if (!$.contains(this.element[0], container[0])) {
                        // moving node to different element
                        status = "k-i-plus";
                    } else {
                        status = "k-i-cancel";
                    }
                }
            }

            this.options.drag({
                originalEvent: e.originalEvent,
                source: source,
                target: target,
                pageY: e.y.location,
                pageX: e.x.location,
                status: status.substring(2),
                setStatus: function(value) {
                    status = value;
                }
            });

            if (status.indexOf("k-i-insert") !== 0) {
                this.dropHint.css(VISIBILITY, "hidden");
            }

            this._hintStatus(status);
        },

        dragcancel: function() {
            this.dropHint.remove();
        },

        dragend: function(e) {
            var position = "over",
                source = this.source,
                destination,
                dropHint = this.dropHint,
                dropTarget = this.dropTarget,
                eventArgs, dropPrevented;

            if (dropHint.css(VISIBILITY) == "visible") {
                position = this.options.dropPositionFrom(dropHint);
                destination = dropHint.closest(this.options.itemSelector);
            } else if (dropTarget) {
                destination = dropTarget.closest(this.options.itemSelector);

                // moving node to root element
                if (!destination.length) {
                    destination = dropTarget.closest(this.options.allowedContainers);
                }
            }

            eventArgs = {
                originalEvent: e.originalEvent,
                source: source[0],
                destination: destination[0],
                valid: this._hintStatus() != "k-i-cancel",
                setValid: function(newValid) {
                    this.valid = newValid;
                },
                dropTarget: dropTarget[0],
                position: position
            };

            dropPrevented = this.options.drop(eventArgs);

            dropHint.remove();
            this._removeTouchHover();
            if (this._lastHover) {
                this._lastHover.removeClass(KSTATEHOVER);
            }

            if (!eventArgs.valid || dropPrevented) {
                this._draggable.dropped = eventArgs.valid;
                return;
            }

            this._draggable.dropped = true;

            this.options.dragend({
                originalEvent: e.originalEvent,
                source: source,
                destination: destination,
                position: position
            });
        },

        destroy: function() {
            this._lastHover = this.hovered = null;
            this._draggable.destroy();
        }
    });

})(window.kendo.jQuery);

return window.kendo;

}, __webpack_require__.amdD);


/***/ }),

/***/ 36765:
/***/ (function(module) {

"use strict";
module.exports = require("./kendo.data");

/***/ }),

/***/ 26222:
/***/ (function(module) {

"use strict";
module.exports = require("./kendo.draganddrop");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	!function() {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(25790);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;