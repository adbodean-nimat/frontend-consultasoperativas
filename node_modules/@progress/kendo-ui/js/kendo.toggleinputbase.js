/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 62995:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(57949) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
})(function() {

var __meta__ = {
    id: "toggleinputbase",
    name: "ToggleInputBase",
    category: "web",
    description: "The ToggleInputBase component.",
    depends: [ "core" ]
};

(function($, undefined) {
    var kendo = window.kendo,
        ui = kendo.ui,
        Widget = ui.Widget,
        CHANGE = "change",
        DISABLED = "disabled",
        CHECKED = "checked";

    var ToggleInputBase = Widget.extend({
        init: function(element, options) {
            var that = this;

            Widget.fn.init.call(that, element, options);

            that._wrapper();

            that._initSettings();

            that._attachEvents();

            kendo.notify(that, kendo.ui);
        },

        events: [
            CHANGE
        ],

        options: {
            name: "ToggleInputBase"
        },

        NS: ".kendoToggleInputBase",
        RENDER_INPUT: $.noop,

        check: function(checked) {
            var that = this,
                element = that.element[0];

            if (checked === undefined) {
                return element.checked;
            }

            if (element.checked !== checked) {
                that.options.checked = element.checked = checked;
            }

            if (checked) {
                that.element.attr(CHECKED, CHECKED);
            } else {
                that.element.prop(CHECKED, false);
            }
        },

        destroy: function() {
            Widget.fn.destroy.call(this);
            this.wrapper.off(this.NS);
        },

        enable: function(enable) {
            var element = this.element;

            if (typeof enable == "undefined") {
                enable = true;
            }

            this.options.enabled = enable;

            if (enable) {
                element.prop(DISABLED, false);
            } else {
                element.attr(DISABLED, DISABLED);
            }
        },

        toggle: function() {
            var that = this;

            that.check(!that.element[0].checked);
        },

        _attachEvents: function() {
            this.element.on(CHANGE + this.NS, this._change.bind(this));
        },

        _change: function() {
            var checked = this.element[0].checked;

            this.trigger(CHANGE, { checked: checked });
        },

        _initSettings: function() {
            var that = this,
                element = that.element[0],
                options = that.options;

            if (options.checked === null) {
                options.checked = element.checked;
            }

            that.check(options.checked);

            options.enabled = options.enabled && !that.element.attr(DISABLED);
            that.enable(options.enabled);
        },

        _wrapper: function() {
            var that = this,
                options = that.options,
                inputMethod = that.RENDER_INPUT;


            inputMethod(that.element, $.extend({}, options));
            that.element.removeClass('input-validation-error');

            that.wrapper = that.element;
        }
    });

    ui.plugin(ToggleInputBase);
})(window.kendo.jQuery);

return window.kendo;

}, __webpack_require__.amdD);


/***/ }),

/***/ 57949:
/***/ (function(module) {

"use strict";
module.exports = require("./kendo.core");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	!function() {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(62995);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;