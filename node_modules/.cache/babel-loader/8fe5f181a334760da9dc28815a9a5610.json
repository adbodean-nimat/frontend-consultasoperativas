{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\n    92735:\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(76837)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        (function ($, undefined) {\n          var kendo = window.kendo,\n              diagram = kendo.dataviz.diagram,\n              Graph = diagram.Graph,\n              Node = diagram.Node,\n              Link = diagram.Link,\n              deepExtend = kendo.deepExtend,\n              Size = diagram.Size,\n              Rect = diagram.Rect,\n              Dictionary = diagram.Dictionary,\n              Set = diagram.Set,\n              HyperTree = diagram.Graph,\n              Utils = diagram.Utils,\n              Point = diagram.Point,\n              EPSILON = 1e-06,\n              DEG_TO_RAD = Math.PI / 180,\n              contains = Utils.contains,\n              grep = $.grep;\n          /**\n           * Base class for layout algorithms.\n           * @type {*}\n           */\n\n          var LayoutBase = kendo.Class.extend({\n            defaultOptions: {\n              type: \"Tree\",\n              subtype: \"Down\",\n              roots: null,\n              animate: false,\n              //-------------------------------------------------------------------\n\n              /**\n               * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n               */\n              limitToView: false,\n\n              /**\n               * Force-directed option: the amount of friction applied to the motion of the nodes.\n               */\n              friction: 0.9,\n\n              /**\n               * Force-directed option: the optimal distance between nodes (minimum energy).\n               */\n              nodeDistance: 50,\n\n              /**\n               * Force-directed option: the number of time things are being calculated.\n               */\n              iterations: 300,\n              //-------------------------------------------------------------------\n\n              /**\n               * Tree option: the separation in one direction (depends on the subtype what direction this is).\n               */\n              horizontalSeparation: 90,\n\n              /**\n               * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n               */\n              verticalSeparation: 50,\n              //-------------------------------------------------------------------\n\n              /**\n               * Tip-over tree option: children-to-parent vertical distance.\n               */\n              underneathVerticalTopOffset: 15,\n\n              /**\n               * Tip-over tree option: children-to-parent horizontal distance.\n               */\n              underneathHorizontalOffset: 15,\n\n              /**\n               * Tip-over tree option: leaf-to-next-branch vertical distance.\n               */\n              underneathVerticalSeparation: 15,\n              //-------------------------------------------------------------------\n\n              /**\n               * Settings object to organize the different components of the diagram in a grid layout structure\n               */\n              grid: {\n                /**\n                 * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n                 */\n                width: 1500,\n\n                /**\n                 * The left offset of the grid.\n                 */\n                offsetX: 50,\n\n                /**\n                 * The top offset of the grid.\n                 */\n                offsetY: 50,\n\n                /**\n                 * The horizontal padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingX: 20,\n\n                /**\n                 * The vertical padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingY: 20\n              },\n              //-------------------------------------------------------------------\n\n              /**\n               * Layered option: the separation height/width between the layers.\n               */\n              layerSeparation: 50,\n\n              /**\n               * Layered option: how many rounds of shifting and fine-tuning.\n               */\n              layeredIterations: 2,\n\n              /**\n               * Tree-radial option: the angle at which the layout starts.\n               */\n              startRadialAngle: 0,\n\n              /**\n               * Tree-radial option: the angle at which the layout starts.\n               */\n              endRadialAngle: 360,\n\n              /**\n               * Tree-radial option: the separation between levels.\n               */\n              radialSeparation: 150,\n\n              /**\n               * Tree-radial option: the separation between the root and the first level.\n               */\n              radialFirstLevelSeparation: 200,\n\n              /**\n               * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n               */\n              keepComponentsInOneRadialLayout: false,\n              //-------------------------------------------------------------------\n              // TODO: ensure to change this to false when containers are around\n              ignoreContainers: true,\n              layoutContainerChildren: false,\n              ignoreInvisible: true,\n              animateTransitions: false\n            },\n            init: function () {},\n\n            /**\n             * Organizes the components in a grid.\n             * Returns the final set of nodes (not the Graph).\n             * @param components\n             */\n            gridLayoutComponents: function (components) {\n              if (!components) {\n                throw \"No components supplied.\";\n              } // calculate and cache the bounds of the components\n\n\n              Utils.forEach(components, function (c) {\n                c.calcBounds();\n              }); // order by decreasing width\n\n              components.sort(function (a, b) {\n                return b.bounds.width - a.bounds.width;\n              });\n              var maxWidth = this.options.grid.width,\n                  offsetX = this.options.grid.componentSpacingX,\n                  offsetY = this.options.grid.componentSpacingY,\n                  height = 0,\n                  startX = this.options.grid.offsetX,\n                  startY = this.options.grid.offsetY,\n                  x = startX,\n                  y = startY,\n                  i,\n                  resultLinkSet = [],\n                  resultNodeSet = [];\n\n              while (components.length > 0) {\n                if (x >= maxWidth) {\n                  // start a new row\n                  x = startX;\n                  y += height + offsetY; // reset the row height\n\n                  height = 0;\n                }\n\n                var component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n\n                for (i = 0; i < component.nodes.length; i++) {\n                  resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n\n                for (i = 0; i < component.links.length; i++) {\n                  resultLinkSet.push(component.links[i]);\n                }\n\n                var boundingRect = component.bounds;\n                var currentHeight = boundingRect.height;\n\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                  currentHeight = 0;\n                }\n\n                var currentWidth = boundingRect.width;\n\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                  currentWidth = 0;\n                }\n\n                if (currentHeight >= height) {\n                  height = currentHeight;\n                }\n\n                x += currentWidth + offsetX;\n              }\n\n              return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n              };\n            },\n            moveToOffset: function (component, p) {\n              var i,\n                  j,\n                  bounds = component.bounds,\n                  deltax = p.x - bounds.x,\n                  deltay = p.y - bounds.y;\n\n              for (i = 0; i < component.nodes.length; i++) {\n                var node = component.nodes[i];\n                var nodeBounds = node.bounds();\n\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                  nodeBounds = new Rect(0, 0, 0, 0);\n                }\n\n                nodeBounds.x += deltax;\n                nodeBounds.y += deltay;\n                node.bounds(nodeBounds);\n              }\n\n              for (i = 0; i < component.links.length; i++) {\n                var link = component.links[i];\n\n                if (link.points) {\n                  var newpoints = [];\n                  var points = link.points;\n\n                  for (j = 0; j < points.length; j++) {\n                    var pt = points[j];\n                    pt.x += deltax;\n                    pt.y += deltay;\n                    newpoints.push(pt);\n                  }\n\n                  link.points = newpoints;\n                }\n              }\n\n              this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n              return new Point(deltax, deltay);\n            },\n            transferOptions: function (options) {\n              // Size options lead to stackoverflow and need special handling\n              this.options = kendo.deepExtend({}, this.defaultOptions);\n\n              if (Utils.isUndefined(options)) {\n                return;\n              }\n\n              this.options = kendo.deepExtend(this.options, options || {});\n            }\n          });\n          /**\n           * The data bucket a hypertree holds in its nodes.     *\n           * @type {*}\n           */\n\n          /* var ContainerGraph = kendo.Class.extend({\n           init: function (diagram) {\n           this.diagram = diagram;\n           this.graph = new Graph(diagram);\n           this.container = null;\n           this.containerNode = null;\n           }\n            });*/\n\n          /**\n           * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n           * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n           * to investigate how the effective graph structure looks like and how the layout has to be performed.\n           * @type {*}\n           */\n\n          var DiagramToHyperTreeAdapter = kendo.Class.extend({\n            init: function (diagram) {\n              /**\n               * The mapping to/from the original nodes.\n               * @type {Dictionary}\n               */\n              this.nodeMap = new Dictionary();\n              /**\n               * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n               * @type {Dictionary}\n               */\n\n              this.shapeMap = new Dictionary();\n              /**\n               * The nodes being mapped.\n               * @type {Dictionary}\n               */\n\n              this.nodes = [];\n              /**\n               * The connections being mapped.\n               * @type {Dictionary}\n               */\n\n              this.edges = []; // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n              // two shapes or because a container holds multiple connections to another shape or container.\n\n              this.edgeMap = new Dictionary();\n              /**\n               * The resulting set of Nodes when the analysis has finished.\n               * @type {Array}\n               */\n\n              this.finalNodes = [];\n              /**\n               * The resulting set of Links when the analysis has finished.\n               * @type {Array}\n               */\n\n              this.finalLinks = [];\n              /**\n               * The items being omitted because of multigraph edges.\n               * @type {Array}\n               */\n\n              this.ignoredConnections = [];\n              /**\n               * The items being omitted because of containers, visibility and other factors.\n               * @type {Array}\n               */\n\n              this.ignoredShapes = [];\n              /**\n               * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n               * @type {Dictionary}\n               */\n\n              this.hyperMap = new Dictionary();\n              /**\n               * The hypertree contains the hierarchy defined by the containers.\n               * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n               * @type {HyperTree}\n               */\n\n              this.hyperTree = new Graph();\n              /**\n               * The resulting graph after conversion. Note that this does not supply the information contained in the\n               * ignored connection and shape collections.\n               * @type {null}\n               */\n\n              this.finalGraph = null;\n              this.diagram = diagram;\n            },\n\n            /**\n             * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n             * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n             *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n             *    since there is no node mapped for the container.\n             *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n             *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n             *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n             * @param options\n             */\n            convert: function (options) {\n              if (Utils.isUndefined(this.diagram)) {\n                throw \"No diagram to convert.\";\n              }\n\n              this.options = kendo.deepExtend({\n                ignoreInvisible: true,\n                ignoreContainers: true,\n                layoutContainerChildren: false\n              }, options || {});\n              this.clear(); // create the nodes which participate effectively in the graph analysis\n\n              this._renormalizeShapes(); // recreate the incoming and outgoing collections of each and every node\n\n\n              this._renormalizeConnections(); // export the resulting graph\n\n\n              this.finalNodes = new Dictionary(this.nodes);\n              this.finalLinks = new Dictionary(this.edges);\n              this.finalGraph = new Graph();\n              this.finalNodes.forEach(function (n) {\n                this.finalGraph.addNode(n);\n              }, this);\n              this.finalLinks.forEach(function (l) {\n                this.finalGraph.addExistingLink(l);\n              }, this);\n              return this.finalGraph;\n            },\n\n            /**\n             * Maps the specified connection to an edge of the graph deduced from the given diagram.\n             * @param connection\n             * @returns {*}\n             */\n            mapConnection: function (connection) {\n              return this.edgeMap.get(connection.id);\n            },\n\n            /**\n             * Maps the specified shape to a node of the graph deduced from the given diagram.\n             * @param shape\n             * @returns {*}\n             */\n            mapShape: function (shape) {\n              return this.nodeMap.get(shape.id);\n            },\n\n            /**\n             * Gets the edge, if any, between the given nodes.\n             * @param a\n             * @param b\n             */\n            getEdge: function (a, b) {\n              return Utils.first(a.links, function (link) {\n                return link.getComplement(a) === b;\n              });\n            },\n\n            /**\n             * Clears all the collections used by the conversion process.\n             */\n            clear: function () {\n              this.finalGraph = null;\n              this.hyperTree = !this.options.ignoreContainers && this.options.layoutContainerChildren ? new HyperTree() : null;\n              this.hyperMap = !this.options.ignoreContainers && this.options.layoutContainerChildren ? new Dictionary() : null;\n              this.nodeMap = new Dictionary();\n              this.shapeMap = new Dictionary();\n              this.nodes = [];\n              this.edges = [];\n              this.edgeMap = new Dictionary();\n              this.ignoredConnections = [];\n              this.ignoredShapes = [];\n              this.finalNodes = [];\n              this.finalLinks = [];\n            },\n\n            /**\n             * The path from a given ContainerGraph to the root (container).\n             * @param containerGraph\n             * @returns {Array}\n             */\n            listToRoot: function (containerGraph) {\n              var list = [];\n              var s = containerGraph.container;\n\n              if (!s) {\n                return list;\n              }\n\n              list.push(s);\n\n              while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n              }\n\n              list.reverse();\n              return list;\n            },\n            firstNonIgnorableContainer: function (shape) {\n              if (shape.isContainer && !this._isIgnorableItem(shape)) {\n                return shape;\n              }\n\n              return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n            },\n            isContainerConnection: function (a, b) {\n              if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n              }\n\n              return b.isContainer && this.isDescendantOf(b, a);\n            },\n\n            /**\n             * Returns true if the given shape is a direct child or a nested container child of the given container.\n             * If the given container and shape are the same this will return false since a shape cannot be its own child.\n             * @param scope\n             * @param a\n             * @returns {boolean}\n             */\n            isDescendantOf: function (scope, a) {\n              if (!scope.isContainer) {\n                throw \"Expecting a container.\";\n              }\n\n              if (scope === a) {\n                return false;\n              }\n\n              if (contains(scope.children, a)) {\n                return true;\n              }\n\n              var containers = [];\n\n              for (var i = 0, len = scope.children.length; i < len; i++) {\n                var c = scope.children[i];\n\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                  containers.push(c);\n                }\n              }\n\n              return containers.length > 0;\n            },\n            isIgnorableItem: function (shape) {\n              if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                  return false;\n                }\n\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                  return false;\n                }\n\n                return true;\n              } else {\n                return shape.isCollapsed && !this._isTop(shape);\n              }\n            },\n\n            /**\n             *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n             * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n             * necessarily a container in the parent hierarchy of the shape.\n             * @param shape\n             */\n            isShapeMapped: function (shape) {\n              return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n            },\n            leastCommonAncestor: function (a, b) {\n              if (!a) {\n                throw \"Parameter should not be null.\";\n              }\n\n              if (!b) {\n                throw \"Parameter should not be null.\";\n              }\n\n              if (!this.hyperTree) {\n                throw \"No hypertree available.\";\n              }\n\n              var al = this.listToRoot(a);\n              var bl = this.listToRoot(b);\n              var found = null;\n\n              if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n                return this.hyperTree.root.data;\n              }\n\n              var xa = al[0];\n              var xb = bl[0];\n              var i = 0;\n\n              while (xa === xb) {\n                found = al[i];\n                i++;\n\n                if (i >= al.length || i >= bl.length) {\n                  break;\n                }\n\n                xa = al[i];\n                xb = bl[i];\n              }\n\n              if (!found) {\n                return this.hyperTree.root.data;\n              } else {\n                return grep(this.hyperTree.nodes, function (n) {\n                  return n.data.container === found;\n                });\n              }\n            },\n\n            /**\n             * Determines whether the specified item is a top-level shape or container.\n             * @param item\n             * @returns {boolean}\n             * @private\n             */\n            _isTop: function (item) {\n              return !item.parentContainer;\n            },\n\n            /**\n             * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n             * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n             * @param shape\n             * @returns {*}\n             * @private\n             */\n            _isVisible: function (shape) {\n              if (!shape.visible()) {\n                return false;\n              }\n\n              return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n            },\n            _isCollapsed: function (shape) {\n              if (shape.isContainer && shape.isCollapsed) {\n                return true;\n              }\n\n              return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n            },\n\n            /**\n             * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n             * @private\n             */\n            _renormalizeShapes: function () {\n              // add the nodes, the adjacency structure will be reconstructed later on\n              if (this.options.ignoreContainers) {\n                for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                  var shape = this.diagram.shapes[i]; // if not visible (and ignoring the invisible ones) or a container we skip\n\n                  if (this.options.ignoreInvisible && !this._isVisible(shape) || shape.isContainer) {\n                    this.ignoredShapes.push(shape);\n                    continue;\n                  }\n\n                  var node = new Node(shape.id, shape);\n                  node.isVirtual = false; // the mapping will always contain singletons and the hyperTree will be null\n\n                  this.nodeMap.add(shape.id, node);\n                  this.nodes.push(node);\n                }\n              } else {\n                throw \"Containers are not supported yet, but stay tuned.\";\n              }\n            },\n\n            /**\n             * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n             * @private\n             */\n            _renormalizeConnections: function () {\n              if (this.diagram.connections.length === 0) {\n                return;\n              }\n\n              for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n                var conn = this.diagram.connections[i];\n\n                if (this.isIgnorableItem(conn)) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                }\n\n                var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                var sink = !conn.targetConnector ? null : conn.targetConnector.shape; // no layout for floating connections\n\n                if (!source || !sink) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                }\n\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                }\n\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                } // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n\n\n                if (this.shapeMap.containsKey(source)) {\n                  source = this.shapeMap[source];\n                }\n\n                if (this.shapeMap.containsKey(sink)) {\n                  sink = this.shapeMap[sink];\n                }\n\n                var sourceNode = this.mapShape(source);\n                var sinkNode = this.mapShape(sink);\n\n                if (sourceNode === sinkNode || this.areConnectedAlready(sourceNode, sinkNode)) {\n                  this.ignoredConnections.push(conn);\n                  continue;\n                }\n\n                if (sourceNode === null || sinkNode === null) {\n                  throw \"A shape was not mapped to a node.\";\n                }\n\n                if (this.options.ignoreContainers) {\n                  // much like a floating connection here since at least one end is attached to a container\n                  if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                  }\n\n                  var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n                  this.edgeMap.add(conn.id, newEdge);\n                  this.edges.push(newEdge);\n                } else {\n                  throw \"Containers are not supported yet, but stay tuned.\";\n                }\n              }\n            },\n            areConnectedAlready: function (n, m) {\n              return Utils.any(this.edges, function (l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n              });\n            }\n            /**\n             * Depth-first traversal of the given container.\n             * @param container\n             * @param action\n             * @param includeStart\n             * @private\n             */\n\n            /* _visitContainer: function (container, action, includeStart) {\n              */\n\n            /*if (container == null) throw new ArgumentNullException(\"container\");\n            if (action == null) throw new ArgumentNullException(\"action\");\n            if (includeStart) action(container);\n            if (container.children.isEmpty()) return;\n            foreach(\n            var item\n            in\n            container.children.OfType < IShape > ()\n            )\n            {\n            var childContainer = item\n            as\n            IContainerShape;\n            if (childContainer != null) this.VisitContainer(childContainer, action);\n            else action(item);\n            }*/\n\n            /*\n            }*/\n\n          });\n          /**\n           * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n           * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n           *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n           *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n           *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n           * @type {*}\n           */\n\n          var SpringLayout = LayoutBase.extend({\n            init: function (diagram) {\n              var that = this;\n              LayoutBase.fn.init.call(that);\n\n              if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n              }\n\n              this.diagram = diagram;\n            },\n            layout: function (options) {\n              this.transferOptions(options);\n              var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n              var graph = adapter.convert(options);\n\n              if (graph.isEmpty()) {\n                return;\n              } // split into connected components\n\n\n              var components = graph.getConnectedComponents();\n\n              if (Utils.isEmpty(components)) {\n                return;\n              }\n\n              for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n              }\n\n              var finalNodeSet = this.gridLayoutComponents(components);\n              return new diagram.LayoutState(this.diagram, finalNodeSet);\n            },\n            layoutGraph: function (graph, options) {\n              if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n              }\n\n              this.graph = graph;\n              var initialTemperature = this.options.nodeDistance * 9;\n              this.temperature = initialTemperature;\n\n              var guessBounds = this._expectedBounds();\n\n              this.width = guessBounds.width;\n              this.height = guessBounds.height;\n\n              for (var step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick(); // exponential cooldown\n\n                this.temperature = this.refineStage ? initialTemperature / 30 : initialTemperature * (1 - step / (2 * this.options.iterations));\n              }\n            },\n\n            /**\n             * Single iteration of the simulation.\n             */\n            tick: function () {\n              var i; // collect the repulsive forces on each node\n\n              for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n              } // collect the attractive forces on each node\n\n\n              for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n              } // update the positions\n\n\n              for (i = 0; i < this.graph.nodes.length; i++) {\n                var node = this.graph.nodes[i];\n                var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n\n                if (offset === 0) {\n                  return;\n                }\n\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n\n                if (this.options.limitToView) {\n                  node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                  node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n              }\n            },\n\n            /**\n             * Shakes the node away from its current position to escape the deadlock.\n             * @param node A Node.\n             * @private\n             */\n            _shake: function (node) {\n              // just a simple polar neighborhood\n              var rho = Math.random() * this.options.nodeDistance / 4;\n              var alpha = Math.random() * 2 * Math.PI;\n              node.x += rho * Math.cos(alpha);\n              node.y -= rho * Math.sin(alpha);\n            },\n\n            /**\n             * The typical Coulomb-Newton force law F=k/r^2\n             * @remark This only works in dimensions less than three.\n             * @param d\n             * @param n A Node.\n             * @param m Another Node.\n             * @returns {number}\n             * @private\n             */\n            _InverseSquareForce: function (d, n, m) {\n              var force;\n\n              if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n              } else {\n                var deltax = n.x - m.x;\n                var deltay = n.y - m.y;\n                var wn = n.width / 2;\n                var hn = n.height / 2;\n                var wm = m.width / 2;\n                var hm = m.height / 2;\n                force = Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2) + Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2);\n              }\n\n              return force * 4 / 3;\n            },\n\n            /**\n             * The typical Hooke force law F=kr^2\n             * @param d\n             * @param n\n             * @param m\n             * @returns {number}\n             * @private\n             */\n            _SquareForce: function (d, n, m) {\n              return 1 / this._InverseSquareForce(d, n, m);\n            },\n            _repulsion: function (n) {\n              n.dx = 0;\n              n.dy = 0;\n              Utils.forEach(this.graph.nodes, function (m) {\n                if (m === n) {\n                  return;\n                }\n\n                while (n.x === m.x && n.y === m.y) {\n                  this._shake(m);\n                }\n\n                var vx = n.x - m.x;\n                var vy = n.y - m.y;\n                var distance = Math.sqrt(vx * vx + vy * vy);\n                var r = this._SquareForce(distance, n, m) * 2;\n                n.dx += vx / distance * r;\n                n.dy += vy / distance * r;\n              }, this);\n            },\n            _attraction: function (link) {\n              var t = link.target;\n              var s = link.source;\n\n              if (s === t) {\n                // loops induce endless shakes\n                return;\n              }\n\n              while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n              }\n\n              var vx = s.x - t.x;\n              var vy = s.y - t.y;\n              var distance = Math.sqrt(vx * vx + vy * vy);\n              var a = this._InverseSquareForce(distance, s, t) * 5;\n              var dx = vx / distance * a;\n              var dy = vy / distance * a;\n              t.dx += dx;\n              t.dy += dy;\n              s.dx -= dx;\n              s.dy -= dy;\n            },\n\n            /**\n             * Calculates the expected bounds after layout.\n             * @returns {*}\n             * @private\n             */\n            _expectedBounds: function () {\n              var size,\n                  N = this.graph.nodes.length,\n\n              /*golden ration optimal?*/\n              ratio = 1.5,\n                  multiplier = 4;\n\n              if (N === 0) {\n                return size;\n              }\n\n              size = Utils.fold(this.graph.nodes, function (s, node) {\n                var area = node.width * node.height;\n\n                if (area > 0) {\n                  s += Math.sqrt(area);\n                  return s;\n                }\n\n                return 0;\n              }, 0, this);\n              var av = size / N;\n              var squareSize = av * Math.ceil(Math.sqrt(N));\n              var width = squareSize * Math.sqrt(ratio);\n              var height = squareSize / Math.sqrt(ratio);\n              return {\n                width: width * multiplier,\n                height: height * multiplier\n              };\n            }\n          });\n          var TreeLayoutProcessor = kendo.Class.extend({\n            init: function (options) {\n              this.center = null;\n              this.options = options;\n            },\n            layout: function (treeGraph, root) {\n              this.graph = treeGraph;\n\n              if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n              }\n\n              if (!contains(this.graph.nodes, root)) {\n                throw \"The given root is not in the graph.\";\n              }\n\n              this.center = root;\n              this.graph.cacheRelationships();\n              /* var nonull = this.graph.nodes.where(function (n) {\n               return n.associatedShape != null;\n               });*/\n              // transfer the rects\n\n              /*nonull.forEach(function (n) {\n               n.Location = n.associatedShape.Position;\n               n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n               }\n                );*/\n              // caching the children\n\n              /* nonull.forEach(function (n) {\n               n.children = n.getChildren();\n               });*/\n\n              this.layoutSwitch(); // apply the layout to the actual visuals\n              // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n            },\n            layoutLeft: function (left) {\n              this.setChildrenDirection(this.center, \"Left\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              var h = 0,\n                  w = 0,\n                  y,\n                  i,\n                  node;\n\n              for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = \"Left\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n              }\n\n              h -= this.options.verticalSeparation;\n              var x = this.center.x - this.options.horizontalSeparation;\n              y = this.center.y + (this.center.height - h) / 2;\n\n              for (i = 0; i < left.length; i++) {\n                node = left[i];\n                var p = new Point(x - node.Size.width, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n              }\n            },\n            layoutRight: function (right) {\n              this.setChildrenDirection(this.center, \"Right\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              var h = 0,\n                  w = 0,\n                  y,\n                  i,\n                  node;\n\n              for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = \"Right\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n              }\n\n              h -= this.options.verticalSeparation;\n              var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n              y = this.center.y + (this.center.height - h) / 2;\n\n              for (i = 0; i < right.length; i++) {\n                node = right[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n              }\n            },\n            layoutUp: function (up) {\n              this.setChildrenDirection(this.center, \"Up\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              var w = 0,\n                  y,\n                  node,\n                  i;\n\n              for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = \"Up\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n              }\n\n              w -= this.options.horizontalSeparation;\n              var x = this.center.x + this.center.width / 2 - w / 2; // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n\n              for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n              }\n            },\n            layoutDown: function (down) {\n              var node, i;\n              this.setChildrenDirection(this.center, \"Down\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              var w = 0,\n                  y;\n\n              for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n              }\n\n              w -= this.options.horizontalSeparation;\n              var x = this.center.x + this.center.width / 2 - w / 2;\n              y = this.center.y + this.options.verticalSeparation + this.center.height;\n\n              for (i = 0; i < down.length; i++) {\n                node = down[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n              }\n            },\n            layoutRadialTree: function () {\n              // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n              this.setChildrenDirection(this.center, \"Radial\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              this.previousRoot = null;\n              var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n              var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n\n              if (endAngle <= startAngle) {\n                throw \"Final angle should not be less than the start angle.\";\n              }\n\n              this.maxDepth = 0;\n              this.origin = new Point(this.center.x, this.center.y);\n              this.calculateAngularWidth(this.center, 0); // perform the layout\n\n              if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n              } // update properties of the root node\n\n\n              this.center.Angle = endAngle - startAngle;\n            },\n            tipOverTree: function (down, startFromLevel) {\n              if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n              }\n\n              this.setChildrenDirection(this.center, \"Down\", false);\n              this.setChildrenLayout(this.center, \"Default\", false);\n              this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n              var w = 0,\n                  y,\n                  node,\n                  i;\n\n              for (i = 0; i < down.length; i++) {\n                node = down[i]; // if (node.IsSpecial) continue;\n\n                node.TreeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n              }\n\n              w -= this.options.horizontalSeparation; // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n\n              w -= down[down.length - 1].width;\n              w += down[down.length - 1].associatedShape.bounds().width;\n              var x = this.center.x + this.center.width / 2 - w / 2;\n              y = this.center.y + this.options.verticalSeparation + this.center.height;\n\n              for (i = 0; i < down.length; i++) {\n                node = down[i]; // if (node.IsSpecial) continue;\n\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n              }\n              /*//let's place the special node, assuming there is only one\n               if (down.Count(n => n.IsSpecial) > 0)\n               {\n               var special = (from n in down where n.IsSpecial select n).First();\n               if (special.Children.Count > 0)\n               throw new DiagramException(\"The 'special' element should not have children.\");\n               special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n               }*/\n\n            },\n            calculateAngularWidth: function (n, d) {\n              if (d > this.maxDepth) {\n                this.maxDepth = d;\n              }\n\n              var aw = 0,\n                  w = 1000,\n                  h = 1000,\n                  diameter = d === 0 ? 0 : Math.sqrt(w * w + h * h) / d;\n\n              if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (var i = 0, len = n.children.length; i < len; i++) {\n                  var child = n.children[i];\n                  aw += this.calculateAngularWidth(child, d + 1);\n                }\n\n                aw = Math.max(diameter, aw);\n              } else {\n                aw = diameter;\n              }\n\n              n.sectorAngle = aw;\n              return aw;\n            },\n            sortChildren: function (n) {\n              var basevalue = 0,\n                  i; // update basevalue angle for node ordering\n\n              if (n.parents.length > 1) {\n                throw \"Node is not part of a tree.\";\n              }\n\n              var p = n.parents[0];\n\n              if (p) {\n                var pl = new Point(p.x, p.y);\n                var nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n              }\n\n              var count = n.children.length;\n\n              if (count === 0) {\n                return null;\n              }\n\n              var angle = [];\n              var idx = [];\n\n              for (i = 0; i < count; ++i) {\n                var c = n.children[i];\n                var l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n              }\n\n              Utils.bisort(angle, idx);\n              var col = []; // list of nodes\n\n              var children = n.children;\n\n              for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n              }\n\n              return col;\n            },\n            normalizeAngle: function (angle) {\n              while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n              }\n\n              while (angle < 0) {\n                angle += Math.PI * 2;\n              }\n\n              return angle;\n            },\n            radialLayout: function (node, radius, startAngle, endAngle) {\n              var deltaTheta = endAngle - startAngle;\n              var deltaThetaHalf = deltaTheta / 2.0;\n              var parentSector = node.sectorAngle;\n              var fraction = 0;\n              var sorted = this.sortChildren(node);\n\n              for (var i = 0, len = sorted.length; i < len; i++) {\n                var childNode = sorted[i];\n                var cp = childNode;\n                var childAngleFraction = cp.sectorAngle / parentSector;\n\n                if (childNode.children.length > 0) {\n                  this.radialLayout(childNode, radius + this.options.radialSeparation, startAngle + fraction * deltaTheta, startAngle + (fraction + childAngleFraction) * deltaTheta);\n                }\n\n                this.setPolarLocation(childNode, radius, startAngle + fraction * deltaTheta + childAngleFraction * deltaThetaHalf);\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n              }\n            },\n            setPolarLocation: function (node, radius, angle) {\n              node.x = this.origin.x + radius * Math.cos(angle);\n              node.y = this.origin.y + radius * Math.sin(angle);\n              node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n            },\n\n            /**\n             * Sets the children direction recursively.\n             * @param node\n             * @param direction\n             * @param includeStart\n             */\n            setChildrenDirection: function (node, direction, includeStart) {\n              var rootDirection = node.treeDirection;\n              this.graph.depthFirstTraversal(node, function (n) {\n                n.treeDirection = direction;\n              });\n\n              if (!includeStart) {\n                node.treeDirection = rootDirection;\n              }\n            },\n\n            /**\n             * Sets the children layout recursively.\n             * @param node\n             * @param layout\n             * @param includeStart\n             * @param startFromLevel\n             */\n            setChildrenLayout: function (node, layout, includeStart, startFromLevel) {\n              if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n              }\n\n              var rootLayout = node.childrenLayout;\n\n              if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node); // assign the layout on the condition that the level is at least the 'startFromLevel'\n\n                this.graph.depthFirstTraversal(node, function (s) {\n                  if (s.level >= startFromLevel + 1) {\n                    s.childrenLayout = layout;\n                  }\n                });\n              } else {\n                this.graph.depthFirstTraversal(node, function (s) {\n                  s.childrenLayout = layout;\n                }); // if the start should not be affected we put the state back\n\n                if (!includeStart) {\n                  node.childrenLayout = rootLayout;\n                }\n              }\n            },\n\n            /**\n             * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n             * @param node\n             * @param givenSize\n             * @returns {Size}\n             */\n            measure: function (node, givenSize) {\n              var w = 0,\n                  h = 0,\n                  s;\n              var result = new Size(0, 0);\n\n              if (!node) {\n                throw \"\";\n              }\n\n              var b = node.associatedShape.bounds();\n              var shapeWidth = b.width;\n              var shapeHeight = b.height;\n\n              if (node.parents.length !== 1) {\n                throw \"Node not in a spanning tree.\";\n              }\n\n              var parent = node.parents[0];\n\n              if (node.treeDirection === \"Undefined\") {\n                node.treeDirection = parent.treeDirection;\n              }\n\n              if (Utils.isEmpty(node.children)) {\n                result = new Size(Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth, Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n              } else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                  case \"Radial\":\n                    s = this.measure(node.children[0], givenSize); // child size\n\n                    w = shapeWidth + this.options.radialSeparation * Math.cos(node.AngleToParent) + s.width;\n                    h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                    break;\n\n                  case \"Left\":\n                  case \"Right\":\n                    switch (node.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                        break;\n\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        s = this.measure(node.children[0], givenSize);\n                        w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                        h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                        break;\n\n                      case \"Default\":\n                        s = this.measure(node.children[0], givenSize);\n                        w = shapeWidth + this.options.horizontalSeparation + s.width;\n                        h = Math.max(shapeHeight, s.height);\n                        break;\n\n                      default:\n                        throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                    }\n\n                    break;\n\n                  case \"Up\":\n                  case \"Down\":\n                    switch (node.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        s = this.measure(node.children[0], givenSize);\n                        w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                        h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                        break;\n\n                      case \"Default\":\n                        s = this.measure(node.children[0], givenSize);\n                        h = shapeHeight + this.options.verticalSeparation + s.height;\n                        w = Math.max(shapeWidth, s.width);\n                        break;\n\n                      default:\n                        throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                    }\n\n                    break;\n\n                  default:\n                    throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n              } else {\n                var i, childNode;\n\n                switch (node.treeDirection) {\n                  case \"Left\":\n                  case \"Right\":\n                    switch (node.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        w = shapeWidth;\n                        h = shapeHeight + this.options.underneathVerticalTopOffset;\n\n                        for (i = 0; i < node.children.length; i++) {\n                          childNode = node.children[i];\n                          s = this.measure(childNode, givenSize);\n                          w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                          h += s.height + this.options.underneathVerticalSeparation;\n                        }\n\n                        h -= this.options.underneathVerticalSeparation;\n                        break;\n\n                      case \"Default\":\n                        w = shapeWidth;\n                        h = 0;\n\n                        for (i = 0; i < node.children.length; i++) {\n                          childNode = node.children[i];\n                          s = this.measure(childNode, givenSize);\n                          w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                          h += s.height + this.options.verticalSeparation;\n                        }\n\n                        h -= this.options.verticalSeparation;\n                        break;\n\n                      default:\n                        throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                    }\n\n                    break;\n\n                  case \"Up\":\n                  case \"Down\":\n                    switch (node.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        w = shapeWidth;\n                        h = shapeHeight + this.options.underneathVerticalTopOffset;\n\n                        for (i = 0; i < node.children.length; i++) {\n                          childNode = node.children[i];\n                          s = this.measure(childNode, givenSize);\n                          w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                          h += s.height + this.options.underneathVerticalSeparation;\n                        }\n\n                        h -= this.options.underneathVerticalSeparation;\n                        break;\n\n                      case \"Default\":\n                        w = 0;\n                        h = 0;\n\n                        for (i = 0; i < node.children.length; i++) {\n                          childNode = node.children[i];\n                          s = this.measure(childNode, givenSize);\n                          w += s.width + this.options.horizontalSeparation;\n                          h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                        }\n\n                        w -= this.options.horizontalSeparation;\n                        break;\n\n                      default:\n                        throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                    }\n\n                    break;\n\n                  default:\n                    throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n              }\n\n              node.SectorAngle = Math.sqrt(w * w / 4 + h * h / 4);\n              node.Size = result;\n              return result;\n            },\n            arrange: function (n, p) {\n              var i,\n                  pp,\n                  child,\n                  node,\n                  childrenwidth,\n                  b = n.associatedShape.bounds();\n              var shapeWidth = b.width;\n              var shapeHeight = b.height;\n\n              if (Utils.isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n              } else {\n                var x, y;\n                var selfLocation;\n\n                switch (n.treeDirection) {\n                  case \"Left\":\n                    switch (n.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        selfLocation = p;\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                        for (i = 0; i < node.children.length; i++) {\n                          node = node.children[i];\n                          x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                          pp = new Point(x, y);\n                          this.arrange(node, pp);\n                          y += node.Size.height + this.options.underneathVerticalSeparation;\n                        }\n\n                        break;\n\n                      case \"Default\":\n                        selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + (n.Size.height - shapeHeight) / 2);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n\n                        y = p.y;\n\n                        for (i = 0; i < n.children.length; i++) {\n                          node = n.children[i];\n                          pp = new Point(x - node.Size.width, y);\n                          this.arrange(node, pp);\n                          y += node.Size.height + this.options.verticalSeparation;\n                        }\n\n                        break;\n\n                      default:\n                        throw \"Unsupported TreeDirection\";\n                    }\n\n                    break;\n\n                  case \"Right\":\n                    switch (n.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        selfLocation = p;\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        x = p.x + shapeWidth + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n\n                        y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                        for (i = 0; i < n.children.length; i++) {\n                          node = n.children[i];\n                          pp = new Point(x, y);\n                          this.arrange(node, pp);\n                          y += node.Size.height + this.options.underneathVerticalSeparation;\n                        }\n\n                        break;\n\n                      case \"Default\":\n                        selfLocation = new Point(p.x, p.y + (n.Size.height - shapeHeight) / 2);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n\n                        y = p.y;\n\n                        for (i = 0; i < n.children.length; i++) {\n                          node = n.children[i];\n                          pp = new Point(x, y);\n                          this.arrange(node, pp);\n                          y += node.Size.height + this.options.verticalSeparation;\n                        }\n\n                        break;\n\n                      default:\n                        throw \"Unsupported TreeDirection\";\n                    }\n\n                    break;\n\n                  case \"Up\":\n                    selfLocation = new Point(p.x + (n.Size.width - shapeWidth) / 2, p.y + n.Size.height - shapeHeight);\n                    n.x = selfLocation.x;\n                    n.y = selfLocation.y;\n                    n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n\n                    if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                      childrenwidth = 0; // means there is an aberration due to the oversized Element with respect to the children\n\n                      for (i = 0; i < n.children.length; i++) {\n                        child = n.children[i];\n                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                      }\n\n                      childrenwidth -= this.options.horizontalSeparation;\n                      x = p.x + (shapeWidth - childrenwidth) / 2;\n                    } else {\n                      x = p.x;\n                    }\n\n                    for (i = 0; i < n.children.length; i++) {\n                      node = n.children[i];\n                      y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                      pp = new Point(x, y);\n                      this.arrange(node, pp);\n                      x += node.Size.width + this.options.horizontalSeparation;\n                    }\n\n                    break;\n\n                  case \"Down\":\n                    switch (n.childrenLayout) {\n                      case \"TopAlignedWithParent\":\n                      case \"BottomAlignedWithParent\":\n                        break;\n\n                      case \"Underneath\":\n                        selfLocation = p;\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n\n                        y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n\n                        for (i = 0; i < n.children.length; i++) {\n                          node = n.children[i];\n                          pp = new Point(x, y);\n                          this.arrange(node, pp);\n                          y += node.Size.height + this.options.underneathVerticalSeparation;\n                        }\n\n                        break;\n\n                      case \"Default\":\n                        selfLocation = new Point(p.x + (n.Size.width - shapeWidth) / 2, p.y);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                          childrenwidth = 0; // means there is an aberration due to the oversized Element with respect to the children\n\n                          for (i = 0; i < n.children.length; i++) {\n                            child = n.children[i];\n                            childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                          }\n\n                          childrenwidth -= this.options.horizontalSeparation;\n                          x = p.x + (shapeWidth - childrenwidth) / 2;\n                        } else {\n                          x = p.x;\n                        }\n\n                        for (i = 0; i < n.children.length; i++) {\n                          node = n.children[i];\n                          y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                          pp = new Point(x, y);\n                          this.arrange(node, pp);\n                          x += node.Size.width + this.options.horizontalSeparation;\n                        }\n\n                        break;\n\n                      default:\n                        throw \"Unsupported TreeDirection\";\n                    }\n\n                    break;\n\n                  case \"None\":\n                    break;\n\n                  default:\n                    throw \"Unsupported TreeDirection\";\n                }\n              }\n            },\n            layoutSwitch: function () {\n              if (!this.center) {\n                return;\n              }\n\n              if (Utils.isEmpty(this.center.children)) {\n                return;\n              }\n\n              var type = this.options.subtype;\n\n              if (Utils.isUndefined(type)) {\n                type = \"Down\";\n              }\n\n              var single, male, female, leftcount;\n              var children = this.center.children;\n\n              switch (type.toLowerCase()) {\n                case \"radial\":\n                case \"radialtree\":\n                  this.layoutRadialTree();\n                  break;\n\n                case \"mindmaphorizontal\":\n                case \"mindmap\":\n                  single = this.center.children;\n\n                  if (this.center.children.length === 1) {\n                    this.layoutRight(single);\n                  } else {\n                    // odd number will give one more at the right\n                    leftcount = children.length / 2;\n                    male = grep(this.center.children, function (n) {\n                      return Utils.indexOf(children, n) < leftcount;\n                    });\n                    female = grep(this.center.children, function (n) {\n                      return Utils.indexOf(children, n) >= leftcount;\n                    });\n                    this.layoutLeft(male);\n                    this.layoutRight(female);\n                  }\n\n                  break;\n\n                case \"mindmapvertical\":\n                  single = this.center.children;\n\n                  if (this.center.children.length === 1) {\n                    this.layoutDown(single);\n                  } else {\n                    // odd number will give one more at the right\n                    leftcount = children.length / 2;\n                    male = grep(this.center.children, function (n) {\n                      return Utils.indexOf(children, n) < leftcount;\n                    });\n                    female = grep(this.center.children, function (n) {\n                      return Utils.indexOf(children, n) >= leftcount;\n                    });\n                    this.layoutUp(male);\n                    this.layoutDown(female);\n                  }\n\n                  break;\n\n                case \"right\":\n                  this.layoutRight(this.center.children);\n                  break;\n\n                case \"left\":\n                  this.layoutLeft(this.center.children);\n                  break;\n\n                case \"up\":\n                case \"bottom\":\n                  this.layoutUp(this.center.children);\n                  break;\n\n                case \"down\":\n                case \"top\":\n                  this.layoutDown(this.center.children);\n                  break;\n\n                case \"tipover\":\n                case \"tipovertree\":\n                  if (this.options.tipOverTreeStartLevel < 0) {\n                    throw \"The tip-over level should be a positive integer.\";\n                  }\n\n                  this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                  break;\n\n                case \"undefined\":\n                case \"none\":\n                  break;\n              }\n            }\n          });\n          /**\n           * The various tree layout algorithms.\n           * @type {*}\n           */\n\n          var TreeLayout = LayoutBase.extend({\n            init: function (diagram) {\n              var that = this;\n              LayoutBase.fn.init.call(that);\n\n              if (Utils.isUndefined(diagram)) {\n                throw \"No diagram specified.\";\n              }\n\n              this.diagram = diagram;\n            },\n\n            /**\n             * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n             */\n            layout: function (options) {\n              this.transferOptions(options); // transform the diagram into a Graph\n\n              var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n              /**\n               * The Graph reduction from the given diagram.\n               * @type {*}\n               */\n\n              this.graph = adapter.convert();\n              var finalNodeSet = this.layoutComponents(); // note that the graph contains the original data and\n              // the components are another instance of nodes referring to the same set of shapes\n\n              return new diagram.LayoutState(this.diagram, finalNodeSet);\n            },\n            layoutComponents: function () {\n              if (this.graph.isEmpty()) {\n                return;\n              } // split into connected components\n\n\n              var components = this.graph.getConnectedComponents();\n\n              if (Utils.isEmpty(components)) {\n                return;\n              }\n\n              var layout = new TreeLayoutProcessor(this.options);\n              var trees = []; // find a spanning tree for each component\n\n              for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                var treeGraph = this.getTree(component);\n\n                if (!treeGraph) {\n                  throw \"Failed to find a spanning tree for the component.\";\n                }\n\n                var root = treeGraph.root;\n                var tree = treeGraph.tree;\n                layout.layout(tree, root);\n                trees.push(tree);\n              }\n\n              return this.gridLayoutComponents(trees);\n            },\n\n            /**\n             * Gets a spanning tree (and root) for the given graph.\n             * Ensure that the given graph is connected!\n             * @param graph\n             * @returns {*} A literal object consisting of the found root and the spanning tree.\n             */\n            getTree: function (graph) {\n              var root = null;\n\n              if (this.options.roots && this.options.roots.length > 0) {\n                for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                  var node = graph.nodes[i];\n\n                  for (var j = 0; j < this.options.roots.length; j++) {\n                    var givenRootShape = this.options.roots[j];\n\n                    if (givenRootShape === node.associatedShape) {\n                      root = node;\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root(); // should not happen really\n\n                if (!root) {\n                  throw \"Unable to find a root for the tree.\";\n                }\n              }\n\n              return this.getTreeForRoot(graph, root);\n            },\n            getTreeForRoot: function (graph, root) {\n              var tree = graph.getSpanningTree(root);\n\n              if (Utils.isUndefined(tree) || tree.isEmpty()) {\n                return null;\n              }\n\n              return {\n                tree: tree,\n                root: tree.root\n              };\n            }\n          });\n          /**\n           * The Sugiyama aka layered layout algorithm.\n           * @type {*}\n           */\n\n          var LayeredLayout = LayoutBase.extend({\n            init: function (diagram) {\n              var that = this;\n              LayoutBase.fn.init.call(that);\n\n              if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n              }\n\n              this.diagram = diagram;\n            },\n            layout: function (options) {\n              this.transferOptions(options);\n              var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n              var graph = adapter.convert(options);\n\n              if (graph.isEmpty()) {\n                return;\n              } // split into connected components\n\n\n              var components = graph.getConnectedComponents();\n\n              if (Utils.isEmpty(components)) {\n                return;\n              }\n\n              for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n              }\n\n              var finalNodeSet = this.gridLayoutComponents(components);\n              return new diagram.LayoutState(this.diagram, finalNodeSet);\n            },\n\n            /**\n             * Initializes the runtime data properties of the layout.\n             * @private\n             */\n            _initRuntimeProperties: function () {\n              for (var k = 0; k < this.graph.nodes.length; k++) {\n                var node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n                node.isVirtual = false;\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n                node.gridPosition = 0;\n              }\n            },\n            _prepare: function (graph) {\n              var current = [],\n                  i,\n                  l,\n                  link; // defines a mapping of a node to the layer index\n\n              var layerMap = new Dictionary();\n              var layerCount = 0;\n              var targetLayer, next, target;\n              Utils.forEach(graph.nodes, function (node) {\n                if (node.incoming.length === 0) {\n                  layerMap.set(node, 0);\n                  current.push(node);\n                }\n              });\n\n              while (current.length > 0) {\n                next = current.shift();\n\n                for (i = 0; i < next.outgoing.length; i++) {\n                  link = next.outgoing[i];\n                  target = link.target;\n\n                  if (layerMap.containsKey(target)) {\n                    targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                  } else {\n                    targetLayer = layerMap.get(next) + 1;\n                  }\n\n                  layerMap.set(target, targetLayer);\n\n                  if (targetLayer > layerCount) {\n                    layerCount = targetLayer;\n                  }\n\n                  if (!contains(current, target)) {\n                    current.push(target);\n                  }\n                }\n              }\n\n              var sortedNodes = layerMap.keys();\n              sortedNodes.sort(function (o1, o2) {\n                var o1layer = layerMap.get(o1);\n                var o2layer = layerMap.get(o2);\n                return Utils.sign(o2layer - o1layer);\n              });\n\n              for (var n = 0; n < sortedNodes.length; ++n) {\n                var node = sortedNodes[n];\n                var minLayer = Number.MAX_VALUE;\n\n                if (node.outgoing.length === 0) {\n                  continue;\n                }\n\n                for (l = 0; l < node.outgoing.length; ++l) {\n                  link = node.outgoing[l];\n                  minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n\n                if (minLayer > 1) {\n                  layerMap.set(node, minLayer - 1);\n                }\n              }\n\n              this.layers = [];\n              var layer;\n\n              for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n              }\n\n              layerMap.forEach(function (node, layer) {\n                node.layer = layer;\n                this.layers[layer].push(node);\n              }, this); // set initial grid positions\n\n              for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (i = 0; i < layer.length; i++) {\n                  layer[i].gridPosition = i;\n                }\n              }\n            },\n\n            /**\n             * Performs the layout of a single component.\n             */\n            layoutGraph: function (graph, options) {\n              if (Utils.isUndefined(graph)) {\n                throw \"No graph given or graph analysis of the diagram failed.\";\n              }\n\n              if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n              }\n\n              this.graph = graph; // sets unique indices on the nodes\n\n              graph.setItemIndices(); // ensures no cycles present for this layout\n\n              var reversedEdges = graph.makeAcyclic(); // define the runtime props being used by the layout algorithm\n\n              this._initRuntimeProperties();\n\n              this._prepare(graph, options);\n\n              this._dummify();\n\n              this._optimizeCrossings();\n\n              this._swapPairs();\n\n              this.arrangeNodes();\n\n              this._moveThingsAround();\n\n              this._dedummify(); // re-reverse the links which were switched earlier\n\n\n              Utils.forEach(reversedEdges, function (e) {\n                if (e.points) {\n                  e.points.reverse();\n                }\n              });\n            },\n            setMinDist: function (m, n, minDist) {\n              var l = m.layer;\n              var i = m.layerIndex;\n              this.minDistances[l][i] = minDist;\n            },\n            getMinDist: function (m, n) {\n              var dist = 0,\n                  i1 = m.layerIndex,\n                  i2 = n.layerIndex,\n                  l = m.layer,\n                  min = Math.min(i1, i2),\n                  max = Math.max(i1, i2); // use Sum()?\n\n              for (var k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n              }\n\n              return dist;\n            },\n            placeLeftToRight: function (leftClasses) {\n              var leftPos = new Dictionary(),\n                  n,\n                  node;\n\n              for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = leftClasses[c];\n\n                if (!classNodes) {\n                  continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n\n                  if (!leftPos.containsKey(node)) {\n                    this.placeLeft(node, leftPos, c);\n                  }\n                } // adjust class\n\n\n                var d = Number.POSITIVE_INFINITY;\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  var rightSibling = this.rightSibling(node);\n\n                  if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                    d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                  }\n                }\n\n                if (d === Number.POSITIVE_INFINITY) {\n                  var D = [];\n\n                  for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var neighbors = [];\n                    Utils.addRange(neighbors, this.upNodes.get(node));\n                    Utils.addRange(neighbors, this.downNodes.get(node));\n\n                    for (var e = 0; e < neighbors.length; e++) {\n                      var neighbor = neighbors[e];\n\n                      if (this.nodeLeftClass.get(neighbor) < c) {\n                        D.push(leftPos.get(neighbor) - leftPos.get(node));\n                      }\n                    }\n                  }\n\n                  D.sort();\n\n                  if (D.length === 0) {\n                    d = 0;\n                  } else if (D.length % 2 === 1) {\n                    d = D[this.intDiv(D.length, 2)];\n                  } else {\n                    d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                  }\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  leftPos.set(node, leftPos.get(node) + d);\n                }\n              }\n\n              return leftPos;\n            },\n            placeRightToLeft: function (rightClasses) {\n              var rightPos = new Dictionary(),\n                  n,\n                  node;\n\n              for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = rightClasses[c];\n\n                if (!classNodes) {\n                  continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n\n                  if (!rightPos.containsKey(node)) {\n                    this.placeRight(node, rightPos, c);\n                  }\n                } // adjust class\n\n\n                var d = Number.NEGATIVE_INFINITY;\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  var leftSibling = this.leftSibling(node);\n\n                  if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                    d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                  }\n                }\n\n                if (d === Number.NEGATIVE_INFINITY) {\n                  var D = [];\n\n                  for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var neighbors = [];\n                    Utils.addRange(neighbors, this.upNodes.get(node));\n                    Utils.addRange(neighbors, this.downNodes.get(node));\n\n                    for (var e = 0; e < neighbors.length; e++) {\n                      var neighbor = neighbors[e];\n\n                      if (this.nodeRightClass.get(neighbor) < c) {\n                        D.push(rightPos.get(node) - rightPos.get(neighbor));\n                      }\n                    }\n                  }\n\n                  D.sort();\n\n                  if (D.length === 0) {\n                    d = 0;\n                  } else if (D.length % 2 === 1) {\n                    d = D[this.intDiv(D.length, 2)];\n                  } else {\n                    d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                  }\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                  node = classNodes[n];\n                  rightPos.set(node, rightPos.get(node) + d);\n                }\n              }\n\n              return rightPos;\n            },\n            _getLeftWing: function () {\n              var leftWing = {\n                value: null\n              };\n              var result = this.computeClasses(leftWing, 1);\n              this.nodeLeftClass = leftWing.value;\n              return result;\n            },\n            _getRightWing: function () {\n              var rightWing = {\n                value: null\n              };\n              var result = this.computeClasses(rightWing, -1);\n              this.nodeRightClass = rightWing.value;\n              return result;\n            },\n            computeClasses: function (wingPair, d) {\n              var currentWing = 0,\n                  wing = wingPair.value = new Dictionary();\n\n              for (var l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n                var layer = this.layers[l];\n\n                for (var n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                  var node = layer[n];\n\n                  if (!wing.containsKey(node)) {\n                    wing.set(node, currentWing);\n\n                    if (node.isVirtual) {\n                      var ndsinl = this._nodesInLink(node);\n\n                      for (var kk = 0; kk < ndsinl.length; kk++) {\n                        var vnode = ndsinl[kk];\n                        wing.set(vnode, currentWing);\n                      }\n                    }\n                  } else {\n                    currentWing = wing.get(node);\n                  }\n                }\n              }\n\n              var wings = [];\n\n              for (var i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n              }\n\n              wing.forEach(function (node, classIndex) {\n                if (wings[classIndex] === null) {\n                  wings[classIndex] = [];\n                }\n\n                wings[classIndex].push(node);\n              });\n              return wings;\n            },\n            _isVerticalLayout: function () {\n              return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n            },\n            _isHorizontalLayout: function () {\n              return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n            },\n            _isIncreasingLayout: function () {\n              // meaning that the visiting of the layers goes in the natural order of increasing layer index\n              return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n            },\n            _moveThingsAround: function () {\n              var i, l, node, layer, n, w; // sort the layers by their grid position\n\n              for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer);\n              }\n\n              this.minDistances = [];\n\n              for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n\n                for (n = 0; n < layer.length; ++n) {\n                  node = layer[n];\n                  node.layerIndex = n;\n                  this.minDistances[l][n] = this.options.nodeDistance;\n\n                  if (n < layer.length - 1) {\n                    if (this._isVerticalLayout()) {\n                      this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                    } else {\n                      this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                    }\n                  }\n                }\n              }\n\n              this.downNodes = new Dictionary();\n              this.upNodes = new Dictionary();\n              Utils.forEach(this.graph.nodes, function (node) {\n                this.downNodes.set(node, []);\n                this.upNodes.set(node, []);\n              }, this);\n              Utils.forEach(this.graph.links, function (link) {\n                var origin = link.source;\n                var dest = link.target;\n                var down = null,\n                    up = null;\n\n                if (origin.layer > dest.layer) {\n                  down = link.source;\n                  up = link.target;\n                } else {\n                  up = link.source;\n                  down = link.target;\n                }\n\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n              }, this);\n              this.downNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n              }, this);\n              this.upNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n              }, this);\n\n              for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n\n                for (w = 0; w < layer.length - 1; w++) {\n                  var currentNode = layer[w];\n\n                  if (!currentNode.isVirtual) {\n                    continue;\n                  }\n\n                  var currDown = this.downNodes.get(currentNode)[0];\n\n                  if (!currDown.isVirtual) {\n                    continue;\n                  }\n\n                  for (n = w + 1; n < layer.length; ++n) {\n                    node = layer[n];\n\n                    if (!node.isVirtual) {\n                      continue;\n                    }\n\n                    var downNode = this.downNodes.get(node)[0];\n\n                    if (!downNode.isVirtual) {\n                      continue;\n                    }\n\n                    if (currDown.gridPosition > downNode.gridPosition) {\n                      var pos = currDown.gridPosition;\n                      currDown.gridPosition = downNode.gridPosition;\n                      downNode.gridPosition = pos;\n                      var i1 = currDown.layerIndex;\n                      var i2 = downNode.layerIndex;\n                      this.layers[l + 1][i1] = downNode;\n                      this.layers[l + 1][i2] = currDown;\n                      currDown.layerIndex = i2;\n                      downNode.layerIndex = i1;\n                    }\n                  }\n                }\n              }\n\n              var leftClasses = this._getLeftWing();\n\n              var rightClasses = this._getRightWing();\n\n              var leftPos = this.placeLeftToRight(leftClasses);\n              var rightPos = this.placeRightToLeft(rightClasses);\n              var x = new Dictionary();\n              Utils.forEach(this.graph.nodes, function (node) {\n                x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n              });\n              var order = new Dictionary();\n              var placed = new Dictionary();\n\n              for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                var sequenceStart = -1,\n                    sequenceEnd = -1;\n\n                for (n = 0; n < layer.length; ++n) {\n                  node = layer[n];\n                  order.set(node, 0);\n                  placed.set(node, false);\n\n                  if (node.isVirtual) {\n                    if (sequenceStart === -1) {\n                      sequenceStart = n;\n                    } else if (sequenceStart === n - 1) {\n                      sequenceStart = n;\n                    } else {\n                      sequenceEnd = n;\n                      order.set(layer[sequenceStart], 0);\n\n                      if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                        placed.set(layer[sequenceStart], true);\n                      } else {\n                        placed.set(layer[sequenceStart], false);\n                      }\n\n                      sequenceStart = n;\n                    }\n                  }\n                }\n              }\n\n              var directions = [1, -1];\n              Utils.forEach(directions, function (d) {\n                var start = d === 1 ? 0 : this.layers.length - 1;\n\n                for (var l = start; l >= 0 && l < this.layers.length; l += d) {\n                  var layer = this.layers[l];\n\n                  var virtualStartIndex = this._firstVirtualNode(layer);\n\n                  var virtualStart = null;\n                  var sequence = null;\n\n                  if (virtualStartIndex !== -1) {\n                    virtualStart = layer[virtualStartIndex];\n                    sequence = [];\n\n                    for (i = 0; i < virtualStartIndex; i++) {\n                      sequence.push(layer[i]);\n                    }\n                  } else {\n                    virtualStart = null;\n                    sequence = layer;\n                  }\n\n                  if (sequence.length > 0) {\n                    this._sequencer(x, null, virtualStart, d, sequence);\n\n                    for (i = 0; i < sequence.length - 1; ++i) {\n                      this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                    }\n\n                    if (virtualStart) {\n                      this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                    }\n                  }\n\n                  while (virtualStart) {\n                    var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n\n                    if (!virtualEnd) {\n                      virtualStartIndex = virtualStart.layerIndex;\n                      sequence = [];\n\n                      for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                        sequence.push(layer[i]);\n                      }\n\n                      if (sequence.length > 0) {\n                        this._sequencer(x, virtualStart, null, d, sequence);\n\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                          this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n\n                        this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                      }\n                    } else if (order.get(virtualStart) === d) {\n                      virtualStartIndex = virtualStart.layerIndex;\n                      var virtualEndIndex = virtualEnd.layerIndex;\n                      sequence = [];\n\n                      for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                        sequence.push(layer[i]);\n                      }\n\n                      if (sequence.length > 0) {\n                        this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                      }\n\n                      placed.set(virtualStart, true);\n                    }\n\n                    virtualStart = virtualEnd;\n                  }\n\n                  this.adjustDirections(l, d, order, placed);\n                }\n              }, this);\n              var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n\n              var reachedFinalLayerIndex = function (k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                  return k < ctx.layers.length;\n                } else {\n                  return k >= 0;\n                }\n              };\n\n              var layerIncrement = this._isIncreasingLayout() ? +1 : -1,\n                  offset = 0;\n              /**\n               * Calcs the max height of the given layer.\n               */\n\n              function maximumHeight(layer, ctx) {\n                var height = Number.MIN_VALUE;\n\n                for (var n = 0; n < layer.length; ++n) {\n                  var node = layer[n];\n\n                  if (ctx._isVerticalLayout()) {\n                    height = Math.max(height, node.height);\n                  } else {\n                    height = Math.max(height, node.width);\n                  }\n                }\n\n                return height;\n              }\n\n              for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                var height = maximumHeight(layer, this);\n\n                for (n = 0; n < layer.length; ++n) {\n                  node = layer[n];\n\n                  if (this._isVerticalLayout()) {\n                    node.x = x.get(node);\n                    node.y = offset + height / 2;\n                  } else {\n                    node.x = offset + height / 2;\n                    node.y = x.get(node);\n                  }\n                }\n\n                offset += this.options.layerSeparation + height;\n              }\n            },\n            adjustDirections: function (l, d, order, placed) {\n              if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n              }\n\n              var prevBridge = null,\n                  prevBridgeTarget = null;\n              var layer = this.layers[l + d];\n\n              for (var n = 0; n < layer.length; ++n) {\n                var nextBridge = layer[n];\n\n                if (nextBridge.isVirtual) {\n                  var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n\n                  if (nextBridgeTarget.isVirtual) {\n                    if (prevBridge) {\n                      var p = placed.get(prevBridgeTarget);\n                      var clayer = this.layers[l];\n                      var i1 = prevBridgeTarget.layerIndex;\n                      var i2 = nextBridgeTarget.layerIndex;\n\n                      for (var i = i1 + 1; i < i2; ++i) {\n                        if (clayer[i].isVirtual) {\n                          p = p && placed.get(clayer[i]);\n                        }\n                      }\n\n                      if (p) {\n                        order.set(prevBridge, d);\n                        var j1 = prevBridge.layerIndex;\n                        var j2 = nextBridge.layerIndex;\n\n                        for (var j = j1 + 1; j < j2; ++j) {\n                          if (layer[j].isVirtual) {\n                            order.set(layer[j], d);\n                          }\n                        }\n                      }\n                    }\n\n                    prevBridge = nextBridge;\n                    prevBridgeTarget = nextBridgeTarget;\n                  }\n                }\n              }\n            },\n            getNeighborOnLayer: function (node, l) {\n              var neighbor = this.upNodes.get(node)[0];\n\n              if (neighbor.layer === l) {\n                return neighbor;\n              }\n\n              neighbor = this.downNodes.get(node)[0];\n\n              if (neighbor.layer === l) {\n                return neighbor;\n              }\n\n              return null;\n            },\n            _sequencer: function (x, virtualStart, virtualEnd, dir, sequence) {\n              if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n              }\n\n              if (sequence.length > 1) {\n                var r = sequence.length,\n                    t = this.intDiv(r, 2);\n\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n              }\n            },\n            _sequenceSingle: function (x, virtualStart, virtualEnd, dir, node) {\n              var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n              var n = neighbors.length;\n\n              if (n !== 0) {\n                if (n % 2 === 1) {\n                  x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                } else {\n                  x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n\n                if (virtualStart) {\n                  x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n\n                if (virtualEnd) {\n                  x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n              }\n            },\n            combineSequences: function (x, virtualStart, virtualEnd, dir, sequence) {\n              var r = sequence.length,\n                  t = this.intDiv(r, 2); // collect left changes\n\n              var leftHeap = [],\n                  i,\n                  c,\n                  n,\n                  neighbors,\n                  neighbor,\n                  pair;\n\n              for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n\n                for (n = 0; n < neighbors.length; ++n) {\n                  neighbor = neighbors[n];\n\n                  if (x.get(neighbor) >= x.get(sequence[i])) {\n                    c++;\n                  } else {\n                    c--;\n                    leftHeap.push({\n                      k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]),\n                      v: 2\n                    });\n                  }\n                }\n\n                leftHeap.push({\n                  k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]),\n                  v: c\n                });\n              }\n\n              if (virtualStart) {\n                leftHeap.push({\n                  k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]),\n                  v: Number.MAX_VALUE\n                });\n              }\n\n              leftHeap.sort(this._positionDescendingComparer); // collect right changes\n\n              var rightHeap = [];\n\n              for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n\n                for (n = 0; n < neighbors.length; ++n) {\n                  neighbor = neighbors[n];\n\n                  if (x.get(neighbor) <= x.get(sequence[i])) {\n                    c++;\n                  } else {\n                    c--;\n                    rightHeap.push({\n                      k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]),\n                      v: 2\n                    });\n                  }\n                }\n\n                rightHeap.push({\n                  k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]),\n                  v: c\n                });\n              }\n\n              if (virtualEnd) {\n                rightHeap.push({\n                  k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]),\n                  v: Number.MAX_VALUE\n                });\n              }\n\n              rightHeap.sort(this._positionAscendingComparer);\n              var leftRes = 0,\n                  rightRes = 0;\n              var m = this.getMinDist(sequence[t - 1], sequence[t]);\n\n              while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                  if (leftHeap.length === 0) {\n                    x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                    break;\n                  } else {\n                    pair = leftHeap.shift();\n                    leftRes = leftRes + pair.v;\n                    x.set(sequence[t - 1], pair.k);\n                    x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                  }\n                } else {\n                  if (rightHeap.length === 0) {\n                    x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                    break;\n                  } else {\n                    pair = rightHeap.shift();\n                    rightRes = rightRes + pair.v;\n                    x.set(sequence[t], pair.k);\n                    x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                  }\n                }\n              }\n\n              for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n              }\n\n              for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n              }\n            },\n            placeLeft: function (node, leftPos, leftClass) {\n              var pos = Number.NEGATIVE_INFINITY;\n              Utils.forEach(this._getComposite(node), function (v) {\n                var leftSibling = this.leftSibling(v);\n\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                  if (!leftPos.containsKey(leftSibling)) {\n                    this.placeLeft(leftSibling, leftPos, leftClass);\n                  }\n\n                  pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n              }, this);\n\n              if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n              }\n\n              Utils.forEach(this._getComposite(node), function (v) {\n                leftPos.set(v, pos);\n              });\n            },\n            placeRight: function (node, rightPos, rightClass) {\n              var pos = Number.POSITIVE_INFINITY;\n              Utils.forEach(this._getComposite(node), function (v) {\n                var rightSibling = this.rightSibling(v);\n\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                  if (!rightPos.containsKey(rightSibling)) {\n                    this.placeRight(rightSibling, rightPos, rightClass);\n                  }\n\n                  pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n              }, this);\n\n              if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n              }\n\n              Utils.forEach(this._getComposite(node), function (v) {\n                rightPos.set(v, pos);\n              });\n            },\n            leftSibling: function (node) {\n              var layer = this.layers[node.layer],\n                  layerIndex = node.layerIndex;\n              return layerIndex === 0 ? null : layer[layerIndex - 1];\n            },\n            rightSibling: function (node) {\n              var layer = this.layers[node.layer];\n              var layerIndex = node.layerIndex;\n              return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n            },\n            _getComposite: function (node) {\n              return node.isVirtual ? this._nodesInLink(node) : [node];\n            },\n            arrangeNodes: function () {\n              var i, l, ni, layer, node; // Initialize node's base priority\n\n              for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                  node = layer[ni];\n                  node.upstreamPriority = node.upstreamLinkCount;\n                  node.downstreamPriority = node.downstreamLinkCount;\n                }\n              } // Layout is invoked after MinimizeCrossings\n              // so we may assume node's barycenters are initially correct\n\n\n              var maxLayoutIterations = 2;\n\n              for (var it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                  this.layoutLayer(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                  this.layoutLayer(true, i);\n                }\n              } // Offset the whole structure so that there are no gridPositions < 0\n\n\n              var gridPos = Number.MAX_VALUE;\n\n              for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                  node = layer[ni];\n                  gridPos = Math.min(gridPos, node.gridPosition);\n                }\n              }\n\n              if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                  layer = this.layers[l];\n\n                  for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.gridPosition = node.gridPosition - gridPos;\n                  }\n                }\n              }\n            },\n            /// <summary>\n            /// Layout of a single layer.\n            /// </summary>\n            /// <param name=\"layerIndex\">The layer to organize.</param>\n            /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n            /// <seealso cref=\"OptimizeCrossings()\"/>\n            layoutLayer: function (down, layer) {\n              var iconsidered;\n              var considered;\n\n              if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n              } else {\n                considered = this.layers[iconsidered = layer - 1];\n              } // list containing the nodes in the considered layer sorted by priority\n\n\n              var sorted = [];\n\n              for (var n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n              }\n\n              sorted.sort(function (n1, n2) {\n                var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                  return 0;\n                }\n\n                if (n1Priority < n2Priority) {\n                  return 1;\n                }\n\n                return -1;\n              }); // each node strives for its barycenter; high priority nodes start first\n\n              Utils.forEach(sorted, function (node) {\n                var nodeGridPos = node.gridPosition;\n                var nodeBaryCenter = this.calcBaryCenter(node);\n                var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                  // This node is exactly at its barycenter -> perfect\n                  return;\n                }\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                  // This node is close enough to the barycenter -> should work\n                  return;\n                }\n\n                if (nodeGridPos < nodeBaryCenter) {\n                  // Try to move the node to the right in an\n                  // attempt to reach its barycenter\n                  while (nodeGridPos < nodeBaryCenter) {\n                    if (!this.moveRight(node, considered, nodePriority)) {\n                      break;\n                    }\n\n                    nodeGridPos = node.gridPosition;\n                  }\n                } else {\n                  // Try to move the node to the left in an\n                  // attempt to reach its barycenter\n                  while (nodeGridPos > nodeBaryCenter) {\n                    if (!this.moveLeft(node, considered, nodePriority)) {\n                      break;\n                    }\n\n                    nodeGridPos = node.gridPosition;\n                  }\n                }\n              }, this); // after the layer has been rearranged we need to recalculate the barycenters\n              // of the nodes in the surrounding layers\n\n              if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n              }\n\n              if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n              }\n            },\n            /// <summary>\n            /// Moves the node to the right and returns <c>true</c> if this was possible.\n            /// </summary>\n            /// <param name=\"node\">The node.</param>\n            /// <param name=\"layer\">The layer.</param>\n            /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n            moveRight: function (node, layer, priority) {\n              var index = Utils.indexOf(layer, node);\n\n              if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n              }\n\n              var rightNode = layer[index + 1];\n              var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2; // check if there is space between the right and the current node\n\n              if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n              } // we have reached a node with higher priority; no movement is allowed\n\n\n              if (rightNodePriority > priority || Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n              } // the right node has lower priority - try to move it\n\n\n              if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n              }\n\n              return false;\n            },\n            /// <summary>\n            /// Moves the node to the left and returns <c>true</c> if this was possible.\n            /// </summary>\n            /// <param name=\"node\">The node.</param>\n            /// <param name=\"layer\">The layer.</param>\n            /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n            moveLeft: function (node, layer, priority) {\n              var index = Utils.indexOf(layer, node);\n\n              if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n              }\n\n              var leftNode = layer[index - 1];\n              var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2; // check if there is space between the left and the current node\n\n              if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n              } // we have reached a node with higher priority; no movement is allowed\n\n\n              if (leftNodePriority > priority || Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n              } // The left node has lower priority - try to move it\n\n\n              if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n              }\n\n              return false;\n            },\n            mapVirtualNode: function (node, link) {\n              this.nodeToLinkMap.set(node, link);\n\n              if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n              }\n\n              this.linkToNodeMap.get(link).push(node);\n            },\n            _nodesInLink: function (node) {\n              return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n            },\n            /// <summary>\n            /// Inserts dummy nodes to break long links.\n            /// </summary>\n            _dummify: function () {\n              this.linkToNodeMap = new Dictionary();\n              this.nodeToLinkMap = new Dictionary();\n              var layer,\n                  pos,\n                  newNode,\n                  node,\n                  r,\n                  newLink,\n                  i,\n                  l,\n                  links = this.graph.links.slice(0);\n              var layers = this.layers;\n\n              var addLinkBetweenLayers = function (upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n              };\n\n              for (l = 0; l < links.length; l++) {\n                var link = links[l];\n                var o = link.source;\n                var d = link.target;\n                var oLayer = o.layer;\n                var dLayer = d.layer;\n                var oPos = o.gridPosition;\n                var dPos = d.gridPosition;\n                var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n                var p = o;\n\n                if (oLayer - dLayer > 1) {\n                  for (i = oLayer - 1; i > dLayer; i--) {\n                    newNode = new Node();\n                    newNode.x = o.x;\n                    newNode.y = o.y;\n                    newNode.width = o.width / 100;\n                    newNode.height = o.height / 100;\n                    layer = layers[i];\n                    pos = (i - dLayer) * step + oPos;\n\n                    if (pos > layer.length) {\n                      pos = layer.length;\n                    } // check if origin and dest are both last\n\n\n                    if (oPos >= layers[oLayer].length - 1 && dPos >= layers[dLayer].length - 1) {\n                      pos = layer.length;\n                    } // check if origin and destination are both first\n                    else if (oPos === 0 && dPos === 0) {\n                      pos = 0;\n                    }\n\n                    newNode.layer = i;\n                    newNode.uBaryCenter = 0.0;\n                    newNode.dBaryCenter = 0.0;\n                    newNode.upstreamLinkCount = 0;\n                    newNode.downstreamLinkCount = 0;\n                    newNode.gridPosition = pos;\n                    newNode.isVirtual = true;\n                    Utils.insert(layer, newNode, pos); // translate rightwards nodes' positions\n\n                    for (r = pos + 1; r < layer.length; r++) {\n                      node = layer[r];\n                      node.gridPosition = node.gridPosition + 1;\n                    }\n\n                    newLink = new Link(p, newNode);\n                    newLink.depthOfDumminess = 0;\n                    addLinkBetweenLayers(i - 1, i, newLink);\n                    p = newNode; // add the new node and the new link to the graph\n\n                    this.graph._addNode(newNode);\n\n                    this.graph.addLink(newLink);\n                    newNode.index = this.graph.nodes.length - 1;\n                    this.mapVirtualNode(newNode, link);\n                  } // set the origin of the real arrow to the last dummy\n\n\n                  addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                  link.changeSource(p);\n                  link.depthOfDumminess = oLayer - dLayer - 1;\n                } else if (oLayer - dLayer < -1) {\n                  for (i = oLayer + 1; i < dLayer; i++) {\n                    newNode = new Node();\n                    newNode.x = o.x;\n                    newNode.y = o.y;\n                    newNode.width = o.width / 100;\n                    newNode.height = o.height / 100;\n                    layer = layers[i];\n                    pos = (i - oLayer) * step + oPos;\n\n                    if (pos > layer.length) {\n                      pos = layer.length;\n                    } // check if origin and dest are both last\n\n\n                    if (oPos >= layers[oLayer].length - 1 && dPos >= layers[dLayer].length - 1) {\n                      pos = layer.length;\n                    } // check if origin and destination are both first\n                    else if (oPos === 0 && dPos === 0) {\n                      pos = 0;\n                    }\n\n                    newNode.layer = i;\n                    newNode.uBaryCenter = 0.0;\n                    newNode.dBaryCenter = 0.0;\n                    newNode.upstreamLinkCount = 0;\n                    newNode.downstreamLinkCount = 0;\n                    newNode.gridPosition = pos;\n                    newNode.isVirtual = true;\n                    pos &= pos; // truncates to int\n\n                    Utils.insert(layer, newNode, pos); // translate rightwards nodes' positions\n\n                    for (r = pos + 1; r < layer.length; r++) {\n                      node = layer[r];\n                      node.gridPosition = node.gridPosition + 1;\n                    }\n\n                    newLink = new Link(p, newNode);\n                    newLink.depthOfDumminess = 0;\n                    addLinkBetweenLayers(i - 1, i, newLink);\n                    p = newNode; // add the new node and the new link to the graph\n\n                    this.graph._addNode(newNode);\n\n                    this.graph.addLink(newLink);\n                    newNode.index = this.graph.nodes.length - 1;\n                    this.mapVirtualNode(newNode, link);\n                  }\n\n                  addLinkBetweenLayers(dLayer - 1, dLayer, link); // Set the origin of the real arrow to the last dummy\n\n                  link.changeSource(p);\n                  link.depthOfDumminess = dLayer - oLayer - 1;\n                } else {\n                  addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n              }\n            },\n            /// <summary>\n            /// Removes the dummy nodes inserted earlier to break long links.\n            /// </summary>\n            /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n            _dedummify: function () {\n              var dedum = true;\n\n              while (dedum) {\n                dedum = false;\n\n                for (var l = 0; l < this.graph.links.length; l++) {\n                  var link = this.graph.links[l];\n\n                  if (!link.depthOfDumminess) {\n                    continue;\n                  }\n\n                  var points = []; // add points in reverse order\n\n                  points.unshift({\n                    x: link.target.x,\n                    y: link.target.y\n                  });\n                  points.unshift({\n                    x: link.source.x,\n                    y: link.source.y\n                  }); // _dedummify the link\n\n                  var temp = link;\n                  var depthOfDumminess = link.depthOfDumminess;\n\n                  for (var d = 0; d < depthOfDumminess; d++) {\n                    var node = temp.source;\n                    var prevLink = node.incoming[0];\n                    points.unshift({\n                      x: prevLink.source.x,\n                      y: prevLink.source.y\n                    });\n                    temp = prevLink;\n                  } // restore the original link origin\n\n\n                  link.changeSource(temp.source); // reset dummification flag\n\n                  link.depthOfDumminess = 0; // note that we only need the intermediate points, floating links have been dropped in the analysis\n\n                  if (points.length > 2) {\n                    // first and last are the endpoints\n                    points.splice(0, 1);\n                    points.splice(points.length - 1);\n                    link.points = points;\n                  } else {\n                    link.points = [];\n                  } // we are not going to delete the dummy elements;\n                  // they won't be needed anymore anyway.\n\n\n                  dedum = true;\n                  break;\n                }\n              }\n            },\n            /// <summary>\n            /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n            /// </summary>\n            _optimizeCrossings: function () {\n              var moves = -1,\n                  i;\n              var maxIterations = 3;\n              var iter = 0;\n\n              while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                  break;\n                }\n\n                moves = 0;\n\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                  moves += this.optimizeLayerCrossings(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                  moves += this.optimizeLayerCrossings(true, i);\n                }\n              }\n            },\n            calcUpData: function (layer) {\n              if (layer === 0) {\n                return;\n              }\n\n              var considered = this.layers[layer],\n                  i,\n                  l,\n                  link;\n              var upLayer = new Set();\n              var temp = this.layers[layer - 1];\n\n              for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n              }\n\n              for (i = 0; i < considered.length; i++) {\n                var node = considered[i]; // calculate barycenter\n\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                  link = node.incoming[l];\n\n                  if (upLayer.contains(link.source)) {\n                    total++;\n                    sum += link.source.gridPosition;\n                  }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                  link = node.outgoing[l];\n\n                  if (upLayer.contains(link.target)) {\n                    total++;\n                    sum += link.target.gridPosition;\n                  }\n                }\n\n                if (total > 0) {\n                  node.uBaryCenter = sum / total;\n                  node.upstreamLinkCount = total;\n                } else {\n                  node.uBaryCenter = i;\n                  node.upstreamLinkCount = 0;\n                }\n              }\n            },\n            calcDownData: function (layer) {\n              if (layer === this.layers.length - 1) {\n                return;\n              }\n\n              var considered = this.layers[layer],\n                  i,\n                  l,\n                  link;\n              var downLayer = new Set();\n              var temp = this.layers[layer + 1];\n\n              for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n              }\n\n              for (i = 0; i < considered.length; i++) {\n                var node = considered[i]; // calculate barycenter\n\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                  link = node.incoming[l];\n\n                  if (downLayer.contains(link.source)) {\n                    total++;\n                    sum += link.source.gridPosition;\n                  }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                  link = node.outgoing[l];\n\n                  if (downLayer.contains(link.target)) {\n                    total++;\n                    sum += link.target.gridPosition;\n                  }\n                }\n\n                if (total > 0) {\n                  node.dBaryCenter = sum / total;\n                  node.downstreamLinkCount = total;\n                } else {\n                  node.dBaryCenter = i;\n                  node.downstreamLinkCount = 0;\n                }\n              }\n            },\n            /// <summary>\n            /// Optimizes the crossings.\n            /// </summary>\n            /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n            /// to an a problem of ordering numbers.</remarks>\n            /// <param name=\"layerIndex\">The layer index.</param>\n            /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n            /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n            optimizeLayerCrossings: function (down, layer) {\n              var iconsidered;\n              var considered;\n\n              if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n              } else {\n                considered = this.layers[iconsidered = layer - 1];\n              } // remember what it was\n\n\n              var presorted = considered.slice(0); // calculate barycenters for all nodes in the considered layer\n\n              if (down) {\n                this.calcUpData(iconsidered);\n              } else {\n                this.calcDownData(iconsidered);\n              }\n\n              var that = this; // sort nodes within this layer according to the barycenters\n\n              considered.sort(function (n1, n2) {\n                var n1BaryCenter = that.calcBaryCenter(n1),\n                    n2BaryCenter = that.calcBaryCenter(n2);\n\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                  // in case of coinciding barycenters compare by the count of in/out links\n                  if (n1.degree() === n2.degree()) {\n                    return that.compareByIndex(n1, n2);\n                  } else if (n1.degree() < n2.degree()) {\n                    return 1;\n                  }\n\n                  return -1;\n                }\n\n                var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n\n                if (compareValue > 0) {\n                  return -1;\n                } else if (compareValue < 0) {\n                  return 1;\n                }\n\n                return that.compareByIndex(n1, n2);\n              }); // count relocations\n\n              var i,\n                  moves = 0;\n\n              for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                  moves++;\n                }\n              }\n\n              if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                var inode = 0;\n\n                for (i = 0; i < considered.length; i++) {\n                  var node = considered[i];\n                  node.gridPosition = inode++;\n                }\n              }\n\n              return moves;\n            },\n            /// <summary>\n            /// Swaps a pair of nodes in a layer.\n            /// </summary>\n            /// <param name=\"layerIndex\">Index of the layer.</param>\n            /// <param name=\"n\">The Nth node in the layer.</param>\n            _swapPairs: function () {\n              var maxIterations = this.options.layeredIterations;\n              var iter = 0;\n\n              while (true) {\n                if (iter++ > maxIterations) {\n                  break;\n                }\n\n                var downwards = iter % 4 <= 1;\n                var secondPass = iter % 4 === 1;\n\n                for (var l = downwards ? 0 : this.layers.length - 1; downwards ? l <= this.layers.length - 1 : l >= 0; l += downwards ? 1 : -1) {\n                  var layer = this.layers[l];\n                  var hasSwapped = false; // there is no need to recalculate crossings if they were calculated\n                  // on the previous step and nothing has changed\n\n                  var calcCrossings = true;\n                  var memCrossings = 0;\n\n                  for (var n = 0; n < layer.length - 1; n++) {\n                    // count crossings\n                    var up = 0;\n                    var down = 0;\n                    var crossBefore = 0;\n\n                    if (calcCrossings) {\n                      if (l !== 0) {\n                        up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                      }\n\n                      if (l !== this.layers.length - 1) {\n                        down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                      }\n\n                      if (downwards) {\n                        up *= 2;\n                      } else {\n                        down *= 2;\n                      }\n\n                      crossBefore = up + down;\n                    } else {\n                      crossBefore = memCrossings;\n                    }\n\n                    if (crossBefore === 0) {\n                      continue;\n                    } // Swap nodes\n\n\n                    var node1 = layer[n];\n                    var node2 = layer[n + 1];\n                    var node1GridPos = node1.gridPosition;\n                    var node2GridPos = node2.gridPosition;\n                    layer[n] = node2;\n                    layer[n + 1] = node1;\n                    node1.gridPosition = node2GridPos;\n                    node2.gridPosition = node1GridPos; // count crossings again and if worse than before, restore swapping\n\n                    up = 0;\n\n                    if (l !== 0) {\n                      up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                    }\n\n                    down = 0;\n\n                    if (l !== this.layers.length - 1) {\n                      down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                    }\n\n                    if (downwards) {\n                      up *= 2;\n                    } else {\n                      down *= 2;\n                    }\n\n                    var crossAfter = up + down;\n                    var revert = false;\n\n                    if (secondPass) {\n                      revert = crossAfter >= crossBefore;\n                    } else {\n                      revert = crossAfter > crossBefore;\n                    }\n\n                    if (revert) {\n                      node1 = layer[n];\n                      node2 = layer[n + 1];\n                      node1GridPos = node1.gridPosition;\n                      node2GridPos = node2.gridPosition;\n                      layer[n] = node2;\n                      layer[n + 1] = node1;\n                      node1.gridPosition = node2GridPos;\n                      node2.gridPosition = node1GridPos; // nothing has changed, remember the crossings so that\n                      // they are not calculated again on the next step\n\n                      memCrossings = crossBefore;\n                      calcCrossings = false;\n                    } else {\n                      hasSwapped = true;\n                      calcCrossings = true;\n                    }\n                  }\n\n                  if (hasSwapped) {\n                    if (l !== this.layers.length - 1) {\n                      this.calcUpData(l + 1);\n                    }\n\n                    if (l !== 0) {\n                      this.calcDownData(l - 1);\n                    }\n                  }\n                }\n              }\n            },\n            /// <summary>\n            /// Counts the number of links crossing between two layers.\n            /// </summary>\n            /// <param name=\"layerIndex1\">The layer index.</param>\n            /// <param name=\"layerIndex2\">Another layer index.</param>\n            /// <returns></returns>\n            countLinksCrossingBetweenTwoLayers: function (ulayer, dlayer) {\n              var links = this.layers[ulayer].linksTo[dlayer];\n              var link1, link2, n11, n12, n21, n22, l1, l2;\n              var crossings = 0;\n              var length = links.length;\n\n              for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n\n                for (l2 = l1 + 1; l2 < length; l2++) {\n                  link2 = links[l2];\n\n                  if (link1.target.layer === dlayer) {\n                    n11 = link1.source;\n                    n12 = link1.target;\n                  } else {\n                    n11 = link1.target;\n                    n12 = link1.source;\n                  }\n\n                  if (link2.target.layer === dlayer) {\n                    n21 = link2.source;\n                    n22 = link2.target;\n                  } else {\n                    n21 = link2.target;\n                    n22 = link2.source;\n                  }\n\n                  var n11gp = n11.gridPosition;\n                  var n12gp = n12.gridPosition;\n                  var n21gp = n21.gridPosition;\n                  var n22gp = n22.gridPosition;\n\n                  if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                    crossings++;\n                  }\n                }\n              }\n\n              return crossings;\n            },\n            calcBaryCenter: function (node) {\n              var upstreamLinkCount = node.upstreamLinkCount;\n              var downstreamLinkCount = node.downstreamLinkCount;\n              var uBaryCenter = node.uBaryCenter;\n              var dBaryCenter = node.dBaryCenter;\n\n              if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n              }\n\n              if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n              }\n\n              if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n              }\n\n              return 0;\n            },\n            _gridPositionComparer: function (x, y) {\n              if (x.gridPosition < y.gridPosition) {\n                return -1;\n              }\n\n              if (x.gridPosition > y.gridPosition) {\n                return 1;\n              }\n\n              return 0;\n            },\n            _positionAscendingComparer: function (x, y) {\n              return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n            },\n            _positionDescendingComparer: function (x, y) {\n              return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n            },\n            _firstVirtualNode: function (layer) {\n              for (var c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                  return c;\n                }\n              }\n\n              return -1;\n            },\n            compareByIndex: function (o1, o2) {\n              var i1 = o1.index;\n              var i2 = o2.index;\n\n              if (i1 < i2) {\n                return 1;\n              }\n\n              if (i1 > i2) {\n                return -1;\n              }\n\n              return 0;\n            },\n            intDiv: function (numerator, denominator) {\n              return (numerator - numerator % denominator) / denominator;\n            },\n            nextVirtualNode: function (layer, node) {\n              var nodeIndex = node.layerIndex;\n\n              for (var i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                  return layer[i];\n                }\n              }\n\n              return null;\n            }\n          });\n          /**\n           * Captures the state of a diagram; node positions, link points and so on.\n           * @type {*}\n           */\n\n          var LayoutState = kendo.Class.extend({\n            init: function (diagram, graphOrNodes) {\n              if (Utils.isUndefined(diagram)) {\n                throw \"No diagram given\";\n              }\n\n              this.diagram = diagram;\n              this.nodeMap = new Dictionary();\n              this.linkMap = new Dictionary();\n              this.capture(graphOrNodes ? graphOrNodes : diagram);\n            },\n\n            /**\n             * Will capture either\n             * - the state of the shapes and the intermediate points of the connections in the diagram\n             * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n             * - the bounds of the nodes in the Array<Node>\n             * - the links points and node bounds in the literal object\n             * @param diagramOrGraphOrNodes\n             */\n            capture: function (diagramOrGraphOrNodes) {\n              var node, nodes, shape, i, conn, link, links;\n\n              if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                  node = diagramOrGraphOrNodes.nodes[i];\n                  shape = node.associatedShape; //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n\n                  this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                  link = diagramOrGraphOrNodes.links[i];\n                  conn = link.associatedConnection;\n                  this.linkMap.set(conn.visual.id, link.points());\n                }\n              } else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n\n                for (i = 0; i < nodes.length; i++) {\n                  node = nodes[i];\n                  shape = node.associatedShape;\n\n                  if (shape) {\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                  }\n                }\n              } else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n\n                for (i = 0; i < nodes.length; i++) {\n                  node = nodes[i];\n                  shape = node.associatedShape;\n\n                  if (shape) {\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                  }\n                }\n\n                for (i = 0; i < links.length; i++) {\n                  link = links[i];\n                  conn = link.associatedConnection;\n\n                  if (conn) {\n                    this.linkMap.set(conn.visual.id, link.points);\n                  }\n                }\n              } else {\n                // capture the diagram\n                var shapes = this.diagram.shapes;\n                var connections = this.diagram.connections;\n\n                for (i = 0; i < shapes.length; i++) {\n                  shape = shapes[i];\n                  this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n\n                for (i = 0; i < connections.length; i++) {\n                  conn = connections[i];\n                  this.linkMap.set(conn.visual.id, conn.points());\n                }\n              }\n            }\n          });\n          deepExtend(diagram, {\n            init: function (element) {\n              kendo.init(element, diagram.ui);\n            },\n            SpringLayout: SpringLayout,\n            TreeLayout: TreeLayout,\n            GraphAdapter: DiagramToHyperTreeAdapter,\n            LayeredLayout: LayeredLayout,\n            LayoutBase: LayoutBase,\n            LayoutState: LayoutState\n          });\n        })(window.kendo.jQuery);\n      }, __webpack_require__.amdD);\n      /***/\n\n    },\n\n    /***/\n    76837:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"./math\");\n      /***/\n    }\n    /******/\n\n  };\n  /************************************************************************/\n\n  /******/\n  // The module cache\n\n  /******/\n\n  var __webpack_module_cache__ = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n\n    if (cachedModule !== undefined) {\n      /******/\n      return cachedModule.exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/\n      // no module.id needed\n\n      /******/\n      // no module.loaded needed\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /* webpack/runtime/amd define */\n\n  /******/\n\n\n  !function () {\n    /******/\n    __webpack_require__.amdD = function () {\n      /******/\n      throw new Error('define cannot be used indirect');\n      /******/\n    };\n    /******/\n\n  }();\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /******/\n  // startup\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n  // This entry module used 'module' so it can't be inlined\n\n  /******/\n\n  var __webpack_exports__ = __webpack_require__(92735);\n  /******/\n\n\n  module.exports = __webpack_exports__;\n  /******/\n\n  /******/\n})();","map":{"version":3,"names":["__webpack_modules__","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","f","define","apply","undefined","$","kendo","window","diagram","dataviz","Graph","Node","Link","deepExtend","Size","Rect","Dictionary","Set","HyperTree","Utils","Point","EPSILON","DEG_TO_RAD","Math","PI","contains","grep","LayoutBase","Class","extend","defaultOptions","type","subtype","roots","animate","limitToView","friction","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","width","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","init","gridLayoutComponents","components","forEach","c","calcBounds","sort","a","b","bounds","maxWidth","options","height","startX","startY","x","y","i","resultLinkSet","resultNodeSet","length","component","pop","moveToOffset","nodes","push","links","boundingRect","currentHeight","isNaN","currentWidth","p","j","deltax","deltay","node","nodeBounds","link","points","newpoints","pt","currentHorizontalOffset","transferOptions","isUndefined","DiagramToHyperTreeAdapter","nodeMap","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","convert","clear","_renormalizeShapes","_renormalizeConnections","n","addNode","l","addExistingLink","mapConnection","connection","get","id","mapShape","shape","getEdge","first","getComplement","listToRoot","containerGraph","list","s","container","parentContainer","reverse","firstNonIgnorableContainer","isContainer","_isIgnorableItem","isContainerConnection","isDescendantOf","scope","children","containers","len","isIgnorableItem","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","bl","found","isEmpty","root","data","xa","xb","item","visible","_isCollapsed","shapes","isVirtual","add","connections","conn","source","sourceConnector","sink","targetConnector","containsKey","sourceNode","sinkNode","areConnectedAlready","newEdge","m","any","target","SpringLayout","that","fn","call","layout","adapter","graph","getConnectedComponents","layoutGraph","finalNodeSet","LayoutState","isDefined","initialTemperature","temperature","guessBounds","_expectedBounds","step","refineStage","tick","_repulsion","_attraction","offset","sqrt","dx","dy","min","max","_shake","rho","random","alpha","cos","sin","_InverseSquareForce","d","force","pow","wn","hn","wm","hm","_SquareForce","vx","vy","distance","r","t","size","N","ratio","multiplier","fold","area","av","squareSize","ceil","TreeLayoutProcessor","center","treeGraph","cacheRelationships","layoutSwitch","layoutLeft","left","setChildrenDirection","setChildrenLayout","h","w","TreeDirection","measure","Empty","Width","arrange","layoutRight","right","layoutUp","up","layoutDown","down","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","origin","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","associatedShape","aw","diameter","child","sectorAngle","sortChildren","basevalue","parents","pl","nl","normalizeAngle","atan2","count","angle","idx","bisort","col","radius","deltaTheta","deltaThetaHalf","parentSector","fraction","sorted","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","depthFirstTraversal","rootLayout","childrenLayout","assignLevels","level","givenSize","result","shapeWidth","shapeHeight","parent","abs","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","toLowerCase","indexOf","tipOverTreeStartLevel","TreeLayout","layoutComponents","trees","getTree","tree","givenRootShape","getTreeForRoot","getSpanningTree","LayeredLayout","_initRuntimeProperties","k","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","current","layerMap","layerCount","targetLayer","next","incoming","set","shift","outgoing","sortedNodes","keys","o1","o2","o1layer","o2layer","sign","minLayer","Number","MAX_VALUE","layers","linksTo","setItemIndices","reversedEdges","makeAcyclic","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","e","setMinDist","minDist","layerIndex","minDistances","getMinDist","dist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","neighbors","addRange","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","value","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","kk","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","dest","forEachValue","currentNode","currDown","downNode","pos","order","placed","sequenceStart","sequenceEnd","directions","start","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","fromLayerIndex","reachedFinalLayerIndex","ctx","layerIncrement","maximumHeight","MIN_VALUE","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","slice","combineSequences","leftHeap","pair","v","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","ni","maxLayoutIterations","it","layoutLayer","gridPos","iconsidered","considered","n1","n2","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","index","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","newNode","newLink","addLinkBetweenLayers","upLayer","downLayer","o","oLayer","dLayer","oPos","dPos","insert","depthOfDumminess","_addNode","addLink","changeSource","dedum","unshift","temp","prevLink","splice","moves","maxIterations","iter","optimizeLayerCrossings","sum","total","presorted","n1BaryCenter","n2BaryCenter","degree","compareByIndex","compareValue","inode","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node2","node1GridPos","node2GridPos","crossAfter","revert","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","n21gp","n22gp","numerator","denominator","nodeIndex","graphOrNodes","linkMap","capture","diagramOrGraphOrNodes","visual","associatedConnection","Array","hasOwnProperty","element","ui","GraphAdapter","jQuery","amdD","require","__webpack_module_cache__","moduleId","cachedModule","Error","__webpack_exports__"],"sources":["C:/Users/abodean/restapi-nodejs/client/app-router/node_modules/@progress/kendo-ui/js/dataviz/diagram/layout.js"],"sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 92735:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(76837) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(function() {\n\n(function($, undefined) {\n    var kendo = window.kendo,\n        diagram = kendo.dataviz.diagram,\n        Graph = diagram.Graph,\n        Node = diagram.Node,\n        Link = diagram.Link,\n        deepExtend = kendo.deepExtend,\n        Size = diagram.Size,\n        Rect = diagram.Rect,\n        Dictionary = diagram.Dictionary,\n        Set = diagram.Set,\n        HyperTree = diagram.Graph,\n        Utils = diagram.Utils,\n        Point = diagram.Point,\n        EPSILON = 1e-06,\n        DEG_TO_RAD = Math.PI / 180,\n        contains = Utils.contains,\n        grep = $.grep;\n\n    /**\n     * Base class for layout algorithms.\n     * @type {*}\n     */\n    var LayoutBase = kendo.Class.extend({\n        defaultOptions: {\n            type: \"Tree\",\n            subtype: \"Down\",\n            roots: null,\n            animate: false,\n            //-------------------------------------------------------------------\n            /**\n             * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n             */\n            limitToView: false,\n            /**\n             * Force-directed option: the amount of friction applied to the motion of the nodes.\n             */\n            friction: 0.9,\n            /**\n             * Force-directed option: the optimal distance between nodes (minimum energy).\n             */\n            nodeDistance: 50,\n            /**\n             * Force-directed option: the number of time things are being calculated.\n             */\n            iterations: 300,\n            //-------------------------------------------------------------------\n            /**\n             * Tree option: the separation in one direction (depends on the subtype what direction this is).\n             */\n            horizontalSeparation: 90,\n            /**\n             * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n             */\n            verticalSeparation: 50,\n\n            //-------------------------------------------------------------------\n            /**\n             * Tip-over tree option: children-to-parent vertical distance.\n             */\n            underneathVerticalTopOffset: 15,\n            /**\n             * Tip-over tree option: children-to-parent horizontal distance.\n             */\n            underneathHorizontalOffset: 15,\n            /**\n             * Tip-over tree option: leaf-to-next-branch vertical distance.\n             */\n            underneathVerticalSeparation: 15,\n            //-------------------------------------------------------------------\n            /**\n             * Settings object to organize the different components of the diagram in a grid layout structure\n             */\n            grid: {\n                /**\n                 * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n                 */\n                width: 1500,\n                /**\n                 * The left offset of the grid.\n                 */\n                offsetX: 50,\n                /**\n                 * The top offset of the grid.\n                 */\n                offsetY: 50,\n                /**\n                 * The horizontal padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingX: 20,\n                /**\n                 * The vertical padding within a cell of the grid where a single component resides.\n                 */\n                componentSpacingY: 20\n            },\n\n            //-------------------------------------------------------------------\n            /**\n             * Layered option: the separation height/width between the layers.\n             */\n            layerSeparation: 50,\n            /**\n             * Layered option: how many rounds of shifting and fine-tuning.\n             */\n            layeredIterations: 2,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            startRadialAngle: 0,\n            /**\n             * Tree-radial option: the angle at which the layout starts.\n             */\n            endRadialAngle: 360,\n            /**\n             * Tree-radial option: the separation between levels.\n             */\n            radialSeparation: 150,\n            /**\n             * Tree-radial option: the separation between the root and the first level.\n             */\n            radialFirstLevelSeparation: 200,\n            /**\n             * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n             */\n            keepComponentsInOneRadialLayout: false,\n            //-------------------------------------------------------------------\n\n            // TODO: ensure to change this to false when containers are around\n            ignoreContainers: true,\n            layoutContainerChildren: false,\n            ignoreInvisible: true,\n            animateTransitions: false\n        },\n        init: function() {\n        },\n\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         * @param components\n         */\n        gridLayoutComponents: function(components) {\n            if (!components) {\n                throw \"No components supplied.\";\n            }\n\n            // calculate and cache the bounds of the components\n            Utils.forEach(components, function(c) {\n                c.calcBounds();\n            });\n\n            // order by decreasing width\n            components.sort(function(a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n\n            var maxWidth = this.options.grid.width,\n                offsetX = this.options.grid.componentSpacingX,\n                offsetY = this.options.grid.componentSpacingY,\n                height = 0,\n                startX = this.options.grid.offsetX,\n                startY = this.options.grid.offsetY,\n                x = startX,\n                y = startY,\n                i,\n                resultLinkSet = [],\n                resultNodeSet = [];\n\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                var component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                var boundingRect = component.bounds;\n                var currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                var currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        },\n\n        moveToOffset: function(component, p) {\n            var i, j,\n                bounds = component.bounds,\n                deltax = p.x - bounds.x,\n                deltay = p.y - bounds.y;\n\n            for (i = 0; i < component.nodes.length; i++) {\n                var node = component.nodes[i];\n                var nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltax;\n                nodeBounds.y += deltay;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                var link = component.links[i];\n                if (link.points) {\n                    var newpoints = [];\n                    var points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        var pt = points[j];\n                        pt.x += deltax;\n                        pt.y += deltay;\n                        newpoints.push(pt);\n                    }\n                    link.points = newpoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltax, deltay);\n        },\n\n        transferOptions: function(options) {\n\n            // Size options lead to stackoverflow and need special handling\n\n            this.options = kendo.deepExtend({}, this.defaultOptions);\n            if (Utils.isUndefined(options)) {\n                return;\n            }\n\n            this.options = kendo.deepExtend(this.options, options || {});\n        }\n    });\n\n    /**\n     * The data bucket a hypertree holds in its nodes.     *\n     * @type {*}\n     */\n    /* var ContainerGraph = kendo.Class.extend({\n     init: function (diagram) {\n     this.diagram = diagram;\n     this.graph = new Graph(diagram);\n     this.container = null;\n     this.containerNode = null;\n     }\n\n     });*/\n\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     * @type {*}\n     */\n    var DiagramToHyperTreeAdapter = kendo.Class.extend({\n        init: function(diagram) {\n\n            /**\n             * The mapping to/from the original nodes.\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n\n            /**\n             * The nodes being mapped.\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n\n            /**\n             * The connections being mapped.\n             * @type {Dictionary}\n             */\n            this.edges = [];\n\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalNodes = [];\n\n            /**\n             * The resulting set of Links when the analysis has finished.\n             * @type {Array}\n             */\n            this.finalLinks = [];\n\n            /**\n             * The items being omitted because of multigraph edges.\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             * @type {null}\n             */\n            this.finalGraph = null;\n\n            this.diagram = diagram;\n        },\n\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         *  - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         *    since there is no node mapped for the container.\n         *  - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         *  - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         *    The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         * @param options\n         */\n        convert: function(options) {\n\n            if (Utils.isUndefined(this.diagram)) {\n                throw \"No diagram to convert.\";\n            }\n\n            this.options = kendo.deepExtend({\n                    ignoreInvisible: true,\n                    ignoreContainers: true,\n                    layoutContainerChildren: false\n                },\n                options || {}\n            );\n\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function(n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function(l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        },\n\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection: function(connection) {\n            return this.edgeMap.get(connection.id);\n        },\n\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         * @param shape\n         * @returns {*}\n         */\n        mapShape: function(shape) {\n            return this.nodeMap.get(shape.id);\n        },\n\n        /**\n         * Gets the edge, if any, between the given nodes.\n         * @param a\n         * @param b\n         */\n        getEdge: function(a, b) {\n            return Utils.first(a.links, function(link) {\n                return link.getComplement(a) === b;\n            });\n        },\n\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear: function() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new HyperTree() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        },\n\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot: function(containerGraph) {\n            var list = [];\n            var s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        },\n\n        firstNonIgnorableContainer: function(shape) {\n\n            if (shape.isContainer && !this._isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        },\n        isContainerConnection: function(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        },\n\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf: function(scope, a) {\n            if (!scope.isContainer) {\n                throw \"Expecting a container.\";\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            var containers = [];\n            for (var i = 0, len = scope.children.length; i < len; i++) {\n                var c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n\n            return containers.length > 0;\n        },\n        isIgnorableItem: function(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        },\n\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         * a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         * necessarily a container in the parent hierarchy of the shape.\n         * @param shape\n         */\n        isShapeMapped: function(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        },\n\n        leastCommonAncestor: function(a, b) {\n            if (!a) {\n                throw \"Parameter should not be null.\";\n            }\n            if (!b) {\n                throw \"Parameter should not be null.\";\n            }\n\n            if (!this.hyperTree) {\n                throw \"No hypertree available.\";\n            }\n            var al = this.listToRoot(a);\n            var bl = this.listToRoot(b);\n            var found = null;\n            if (Utils.isEmpty(al) || Utils.isEmpty(bl)) {\n                return this.hyperTree.root.data;\n            }\n            var xa = al[0];\n            var xb = bl[0];\n            var i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root.data;\n            }\n            else {\n                return grep(this.hyperTree.nodes, function(n) {\n                    return n.data.container === found;\n                });\n            }\n        },\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop: function(item) {\n            return !item.parentContainer;\n        },\n\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible: function(shape) {\n\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        },\n\n        _isCollapsed: function(shape) {\n\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        },\n\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         * @private\n         */\n        _renormalizeShapes: function() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (var i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    var shape = this.diagram.shapes[i];\n\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    var node = new Node(shape.id, shape);\n                    node.isVirtual = false;\n\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw \"Containers are not supported yet, but stay tuned.\";\n            }\n        },\n\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         * @private\n         */\n        _renormalizeConnections: function() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (var i = 0, len = this.diagram.connections.length; i < len; i++) {\n                var conn = this.diagram.connections[i];\n\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                var source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                var sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n\n                var sourceNode = this.mapShape(source);\n                var sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n\n                if (sourceNode === null || sinkNode === null) {\n                    throw \"A shape was not mapped to a node.\";\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    var newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw \"Containers are not supported yet, but stay tuned.\";\n                }\n            }\n        },\n\n        areConnectedAlready: function(n, m) {\n            return Utils.any(this.edges, function(l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n\n        /**\n         * Depth-first traversal of the given container.\n         * @param container\n         * @param action\n         * @param includeStart\n         * @private\n         */\n        /* _visitContainer: function (container, action, includeStart) {\n\n         *//*if (container == null) throw new ArgumentNullException(\"container\");\n         if (action == null) throw new ArgumentNullException(\"action\");\n         if (includeStart) action(container);\n         if (container.children.isEmpty()) return;\n         foreach(\n         var item\n         in\n         container.children.OfType < IShape > ()\n         )\n         {\n         var childContainer = item\n         as\n         IContainerShape;\n         if (childContainer != null) this.VisitContainer(childContainer, action);\n         else action(item);\n         }*//*\n         }*/\n\n\n    });\n\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     *  - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     *  - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     *  - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     * @type {*}\n     */\n    var SpringLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutGraph: function(graph, options) {\n\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            var initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n\n            var guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n\n            for (var step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations ));\n            }\n        },\n\n        /**\n         * Single iteration of the simulation.\n         */\n        tick: function() {\n            var i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                var node = this.graph.nodes[i];\n                var offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        },\n\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         * @param node A Node.\n         * @private\n         */\n        _shake: function(node) {\n            // just a simple polar neighborhood\n            var rho = Math.random() * this.options.nodeDistance / 4;\n            var alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        },\n\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce: function(d, n, m) {\n            var force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                var deltax = n.x - m.x;\n                var deltay = n.y - m.y;\n\n                var wn = n.width / 2;\n                var hn = n.height / 2;\n                var wm = m.width / 2;\n                var hm = m.height / 2;\n\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        },\n\n        /**\n         * The typical Hooke force law F=kr^2\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce: function(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        },\n\n        _repulsion: function(n) {\n            n.dx = 0;\n            n.dy = 0;\n            Utils.forEach(this.graph.nodes, function(m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                var vx = n.x - m.x;\n                var vy = n.y - m.y;\n                var distance = Math.sqrt(vx * vx + vy * vy);\n                var r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        },\n        _attraction: function(link) {\n            var t = link.target;\n            var s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n\n            var vx = s.x - t.x;\n            var vy = s.y - t.y;\n            var distance = Math.sqrt(vx * vx + vy * vy);\n\n            var a = this._InverseSquareForce(distance, s, t) * 5;\n            var dx = (vx / distance) * a;\n            var dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        },\n\n        /**\n         * Calculates the expected bounds after layout.\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds: function() {\n\n            var size, N = this.graph.nodes.length, /*golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return size;\n            }\n            size = Utils.fold(this.graph.nodes, function(s, node) {\n                var area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            var av = size / N;\n            var squareSize = av * Math.ceil(Math.sqrt(N));\n            var width = squareSize * Math.sqrt(ratio);\n            var height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n\n    });\n\n    var TreeLayoutProcessor = kendo.Class.extend({\n\n        init: function(options) {\n            this.center = null;\n            this.options = options;\n        },\n        layout: function(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n\n            if (!contains(this.graph.nodes, root)) {\n                throw \"The given root is not in the graph.\";\n            }\n\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n\n            // transfer the rects\n            /*nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n\n            this.layoutSwitch();\n\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        },\n\n        layoutLeft: function(left) {\n            this.setChildrenDirection(this.center, \"Left\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = \"Left\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                var p = new Point(x - node.Size.width, y);\n\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutRight: function(right) {\n            this.setChildrenDirection(this.center, \"Right\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = \"Right\";\n                var s = this.measure(node, Size.Empty);\n                w = Math.max(w, s.Width);\n                h += s.height + this.options.verticalSeparation;\n            }\n\n            h -= this.options.verticalSeparation;\n            var x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        },\n\n        layoutUp: function(up) {\n            this.setChildrenDirection(this.center, \"Up\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = \"Up\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutDown: function(down) {\n            var node, i;\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            var w = 0, y;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        },\n\n        layoutRadialTree: function() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, \"Radial\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.previousRoot = null;\n            var startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            var endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw \"Final angle should not be less than the start angle.\";\n            }\n\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        },\n\n        tipOverTree: function(down, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n\n            this.setChildrenDirection(this.center, \"Down\", false);\n            this.setChildrenLayout(this.center, \"Default\", false);\n            this.setChildrenLayout(this.center, \"Underneath\", false, startFromLevel);\n            var w = 0, y, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = \"Down\";\n                var s = this.measure(node, Size.Empty);\n                w += s.width + this.options.horizontalSeparation;\n            }\n\n            w -= this.options.horizontalSeparation;\n\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n\n            var x = this.center.x + (this.center.width / 2) - (w / 2);\n            y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                var p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n\n            /*//let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        },\n        calculateAngularWidth: function(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n\n            var aw = 0, w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (var i = 0, len = n.children.length; i < len; i++) {\n                    var child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n\n            n.sectorAngle = aw;\n            return aw;\n        },\n        sortChildren: function(n) {\n            var basevalue = 0, i;\n\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw \"Node is not part of a tree.\";\n            }\n            var p = n.parents[0];\n            if (p) {\n                var pl = new Point(p.x, p.y);\n                var nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n\n            var count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n\n            var angle = [];\n            var idx = [];\n\n            for (i = 0; i < count; ++i) {\n                var c = n.children[i];\n                var l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n\n            Utils.bisort(angle, idx);\n            var col = []; // list of nodes\n            var children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n\n            return col;\n        },\n\n        normalizeAngle: function(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        },\n        radialLayout: function(node, radius, startAngle, endAngle) {\n            var deltaTheta = endAngle - startAngle;\n            var deltaThetaHalf = deltaTheta / 2.0;\n            var parentSector = node.sectorAngle;\n            var fraction = 0;\n            var sorted = this.sortChildren(node);\n            for (var i = 0, len = sorted.length; i < len; i++) {\n                var childNode = sorted[i];\n                var cp = childNode;\n                var childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode,\n                        radius + this.options.radialSeparation,\n                        startAngle + (fraction * deltaTheta),\n                        startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        },\n        setPolarLocation: function(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        },\n\n        /**\n         * Sets the children direction recursively.\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection: function(node, direction, includeStart) {\n            var rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, function(n) {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        },\n\n        /**\n         * Sets the children layout recursively.\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout: function(node, layout, includeStart, startFromLevel) {\n            if (Utils.isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            var rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(\n                    node, function(s) {\n                        if (s.level >= startFromLevel + 1) {\n                            s.childrenLayout = layout;\n                        }\n                    }\n                );\n            }\n            else {\n                this.graph.depthFirstTraversal(node, function(s) {\n                    s.childrenLayout = layout;\n                });\n\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        },\n\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure: function(node, givenSize) {\n            var w = 0, h = 0, s;\n            var result = new Size(0, 0);\n            if (!node) {\n                throw \"\";\n            }\n            var b = node.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw \"Node not in a spanning tree.\";\n            }\n\n            var parent = node.parents[0];\n            if (node.treeDirection === \"Undefined\") {\n                node.treeDirection = parent.treeDirection;\n            }\n\n            if (Utils.isEmpty(node.children)) {\n                result = new Size(\n                    Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth,\n                    Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case \"Radial\":\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                                break;\n\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Radial layout measuring.\";\n                        }\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n\n                            case \"Default\":\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n            else {\n                var i, childNode;\n                switch (node.treeDirection) {\n                    case \"Left\":\n                    case \"Right\":\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Right layout measuring.\";\n                        }\n\n                        break;\n                    case \"Up\":\n                    case \"Down\":\n\n                        switch (node.childrenLayout) {\n\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n\n                            case \"Default\":\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n\n                                w -= this.options.horizontalSeparation;\n                                break;\n\n                            default:\n                                throw \"Unhandled TreeDirection in the Down layout measuring.\";\n                        }\n\n                        break;\n                    default:\n                        throw \"Unhandled TreeDirection in the layout measuring.\";\n                }\n\n                result = new Size(w, h);\n            }\n\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        },\n        arrange: function(n, p) {\n            var i, pp, child, node, childrenwidth, b = n.associatedShape.bounds();\n            var shapeWidth = b.width;\n            var shapeHeight = b.height;\n            if (Utils.isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                var x, y;\n                var selfLocation;\n                switch (n.treeDirection) {\n                    case \"Left\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Right\":\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n\n                        break;\n                    case \"Up\":\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n\n                    case \"Down\":\n\n                        switch (n.childrenLayout) {\n                            case \"TopAlignedWithParent\":\n                            case \"BottomAlignedWithParent\":\n                                break;\n                            case \"Underneath\":\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n\n                            case \"Default\":\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n\n                            default:\n                                throw \"Unsupported TreeDirection\";\n                        }\n                        break;\n\n                    case \"None\":\n                        break;\n\n                    default:\n                        throw \"Unsupported TreeDirection\";\n                }\n            }\n        },\n        layoutSwitch: function() {\n            if (!this.center) {\n                return;\n            }\n\n            if (Utils.isEmpty(this.center.children)) {\n                return;\n            }\n\n            var type = this.options.subtype;\n            if (Utils.isUndefined(type)) {\n                type = \"Down\";\n            }\n            var single, male, female, leftcount;\n            var children = this.center.children;\n            switch (type.toLowerCase()) {\n                case \"radial\":\n                case \"radialtree\":\n                    this.layoutRadialTree();\n                    break;\n\n                case \"mindmaphorizontal\":\n                case \"mindmap\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n\n                case \"mindmapvertical\":\n                    single = this.center.children;\n\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) < leftcount;\n                        });\n                        female = grep(this.center.children, function(n) {\n                            return Utils.indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n\n                case \"right\":\n                    this.layoutRight(this.center.children);\n                    break;\n\n                case \"left\":\n                    this.layoutLeft(this.center.children);\n                    break;\n\n                case \"up\":\n                case \"bottom\":\n                    this.layoutUp(this.center.children);\n                    break;\n\n                case \"down\":\n                case \"top\":\n                    this.layoutDown(this.center.children);\n                    break;\n\n                case \"tipover\":\n                case \"tipovertree\":\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw \"The tip-over level should be a positive integer.\";\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n\n                case \"undefined\":\n                case \"none\":\n                    break;\n            }\n        }\n    });\n\n    /**\n     * The various tree layout algorithms.\n     * @type {*}\n     */\n    var TreeLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            // transform the diagram into a Graph\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n\n            /**\n             * The Graph reduction from the given diagram.\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n\n            var finalNodeSet = this.layoutComponents();\n\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n        },\n\n        layoutComponents: function() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n\n            // split into connected components\n            var components = this.graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n\n            var layout = new TreeLayoutProcessor(this.options);\n            var trees = [];\n            // find a spanning tree for each component\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n\n                var treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw \"Failed to find a spanning tree for the component.\";\n                }\n                var root = treeGraph.root;\n                var tree = treeGraph.tree;\n                layout.layout(tree, root);\n\n                trees.push(tree);\n            }\n\n            return this.gridLayoutComponents(trees);\n\n        },\n\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree: function(graph) {\n            var root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (var i = 0, len = graph.nodes.length; i < len; i++) {\n                    var node = graph.nodes[i];\n                    for (var j = 0; j < this.options.roots.length; j++) {\n                        var givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw \"Unable to find a root for the tree.\";\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        },\n\n        getTreeForRoot: function(graph, root) {\n\n            var tree = graph.getSpanningTree(root);\n            if (Utils.isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root\n            };\n        }\n\n    });\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     * @type {*}\n     */\n    var LayeredLayout = LayoutBase.extend({\n        init: function(diagram) {\n            var that = this;\n            LayoutBase.fn.init.call(that);\n            if (Utils.isUndefined(diagram)) {\n                throw \"Diagram is not specified.\";\n            }\n            this.diagram = diagram;\n        },\n\n        layout: function(options) {\n\n            this.transferOptions(options);\n\n            var adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            var graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            var components = graph.getConnectedComponents();\n            if (Utils.isEmpty(components)) {\n                return;\n            }\n            for (var i = 0; i < components.length; i++) {\n                var component = components[i];\n                this.layoutGraph(component, options);\n            }\n            var finalNodeSet = this.gridLayoutComponents(components);\n            return new diagram.LayoutState(this.diagram, finalNodeSet);\n\n        },\n\n        /**\n         * Initializes the runtime data properties of the layout.\n         * @private\n         */\n        _initRuntimeProperties: function() {\n            for (var k = 0; k < this.graph.nodes.length; k++) {\n                var node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n\n                node.isVirtual = false;\n\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n\n                node.gridPosition = 0;\n            }\n        },\n        _prepare: function(graph) {\n            var current = [], i, l, link;\n\n            // defines a mapping of a node to the layer index\n            var layerMap = new Dictionary();\n            var layerCount = 0;\n            var targetLayer, next, target;\n\n            Utils.forEach(graph.nodes, function(node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    } else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n\n            var sortedNodes = layerMap.keys();\n\n            sortedNodes.sort(function(o1, o2) {\n                var o1layer = layerMap.get(o1);\n                var o2layer = layerMap.get(o2);\n                return Utils.sign(o2layer - o1layer);\n            });\n\n            for (var n = 0; n < sortedNodes.length; ++n) {\n                var node = sortedNodes[n];\n                var minLayer = Number.MAX_VALUE;\n\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n\n            this.layers = [];\n            var layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n\n            layerMap.forEach(function(node, layer) {\n                node.layer = layer;\n                this.layers[layer].push(node);\n            }, this);\n\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        },\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph: function(graph, options) {\n            if (Utils.isUndefined(graph)) {\n                throw \"No graph given or graph analysis of the diagram failed.\";\n            }\n            if (Utils.isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n\n            // ensures no cycles present for this layout\n            var reversedEdges = graph.makeAcyclic();\n\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n\n            this._prepare(graph, options);\n\n            this._dummify();\n\n            this._optimizeCrossings();\n\n            this._swapPairs();\n\n            this.arrangeNodes();\n\n            this._moveThingsAround();\n\n            this._dedummify();\n\n            // re-reverse the links which were switched earlier\n            Utils.forEach(reversedEdges, function(e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        },\n\n        setMinDist: function(m, n, minDist) {\n            var l = m.layer;\n            var i = m.layerIndex;\n            this.minDistances[l][i] = minDist;\n        },\n\n        getMinDist: function(m, n) {\n            var dist = 0,\n                i1 = m.layerIndex,\n                i2 = n.layerIndex,\n                l = m.layer,\n                min = Math.min(i1, i2),\n                max = Math.max(i1, i2);\n            // use Sum()?\n            for (var k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        },\n\n        placeLeftToRight: function(leftClasses) {\n            var leftPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        },\n\n        placeRightToLeft: function(rightClasses) {\n            var rightPos = new Dictionary(), n, node;\n            for (var c = 0; c < this.layers.length; ++c) {\n                var classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n\n                // adjust class\n                var d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    var leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    var D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        var neighbors = [];\n                        Utils.addRange(neighbors, this.upNodes.get(node));\n                        Utils.addRange(neighbors, this.downNodes.get(node));\n\n                        for (var e = 0; e < neighbors.length; e++) {\n                            var neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        },\n\n        _getLeftWing: function() {\n            var leftWing = { value: null };\n            var result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        },\n\n        _getRightWing: function() {\n            var rightWing = { value: null };\n            var result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        },\n\n        computeClasses: function(wingPair, d) {\n            var currentWing = 0,\n                wing = wingPair.value = new Dictionary();\n\n            for (var l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n\n                var layer = this.layers[l];\n                for (var n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    var node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            var ndsinl = this._nodesInLink(node);\n                            for (var kk = 0; kk < ndsinl.length; kk++) {\n                                var vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n\n            var wings = [];\n            for (var i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function(node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n\n            return wings;\n        },\n        _isVerticalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"up\" || this.options.subtype.toLowerCase() === \"down\" || this.options.subtype.toLowerCase() === \"vertical\";\n        },\n\n        _isHorizontalLayout: function() {\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"left\" || this.options.subtype.toLowerCase() === \"horizontal\";\n        },\n        _isIncreasingLayout: function() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === \"right\" || this.options.subtype.toLowerCase() === \"down\";\n        },\n        _moveThingsAround: function() {\n            var i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer);\n            }\n\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                this.downNodes.set(node, []);\n                this.upNodes.set(node, []);\n            }, this);\n            Utils.forEach(this.graph.links, function(link) {\n                var origin = link.source;\n                var dest = link.target;\n                var down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function(list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    var currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n\n                    var currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n\n                        var downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            var pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            var i1 = currDown.layerIndex;\n                            var i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n\n\n            var leftClasses = this._getLeftWing();\n            var rightClasses = this._getRightWing();\n\n\n            var leftPos = this.placeLeftToRight(leftClasses);\n            var rightPos = this.placeRightToLeft(rightClasses);\n            var x = new Dictionary();\n            Utils.forEach(this.graph.nodes, function(node) {\n                x.set(node, (leftPos.get(node) + rightPos.get(node)) / 2);\n            });\n\n\n            var order = new Dictionary();\n            var placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                var sequenceStart = -1, sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            var directions = [1, -1];\n            Utils.forEach(directions, function(d) {\n                var start = d === 1 ? 0 : this.layers.length - 1;\n                for (var l = start; l >= 0 && l < this.layers.length; l += d) {\n                    var layer = this.layers[l];\n                    var virtualStartIndex = this._firstVirtualNode(layer);\n                    var virtualStart = null;\n                    var sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n\n                    while (virtualStart) {\n                        var virtualEnd = this.nextVirtualNode(layer, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer.length; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            var virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(l, d, order, placed);\n                }\n            }, this);\n\n\n            var fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            var reachedFinalLayerIndex = function(k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            var layerIncrement = this._isIncreasingLayout() ? +1 : -1, offset = 0;\n\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer, ctx) {\n                var height = Number.MIN_VALUE;\n                for (var n = 0; n < layer.length; ++n) {\n                    var node = layer[n];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node.height);\n                    }\n                    else {\n                        height = Math.max(height, node.width);\n                    }\n                }\n                return height;\n            }\n\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                var height = maximumHeight(layer, this);\n\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n\n                offset += this.options.layerSeparation + height;\n            }\n        },\n\n        adjustDirections: function(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n\n            var prevBridge = null, prevBridgeTarget = null;\n            var layer = this.layers[l + d];\n            for (var n = 0; n < layer.length; ++n) {\n                var nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    var nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            var p = placed.get(prevBridgeTarget);\n                            var clayer = this.layers[l];\n                            var i1 = prevBridgeTarget.layerIndex;\n                            var i2 = nextBridgeTarget.layerIndex;\n                            for (var i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                var j1 = prevBridge.layerIndex;\n                                var j2 = nextBridge.layerIndex;\n                                for (var j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        },\n\n        getNeighborOnLayer: function(node, l) {\n            var neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        },\n\n        _sequencer: function(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n\n            if (sequence.length > 1) {\n                var r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        },\n\n        _sequenceSingle: function(x, virtualStart, virtualEnd, dir, node) {\n            var neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n\n            var n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        },\n\n        combineSequences: function(x, virtualStart, virtualEnd, dir, sequence) {\n            var r = sequence.length, t = this.intDiv(r, 2);\n\n            // collect left changes\n            var leftHeap = [], i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer);\n\n            // collect right changes\n            var rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer);\n\n            var leftRes = 0, rightRes = 0;\n            var m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        },\n\n        placeLeft: function(node, leftPos, leftClass) {\n            var pos = Number.NEGATIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                leftPos.set(v, pos);\n            });\n        },\n\n        placeRight: function(node, rightPos, rightClass) {\n            var pos = Number.POSITIVE_INFINITY;\n            Utils.forEach(this._getComposite(node), function(v) {\n                var rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            Utils.forEach(this._getComposite(node), function(v) {\n                rightPos.set(v, pos);\n            });\n        },\n\n        leftSibling: function(node) {\n            var layer = this.layers[node.layer],\n                layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        },\n\n        rightSibling: function(node) {\n            var layer = this.layers[node.layer];\n            var layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n\n        },\n\n        _getComposite: function(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        },\n\n        arrangeNodes: function() {\n            var i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n\n            var maxLayoutIterations = 2;\n            for (var it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n\n            // Offset the whole structure so that there are no gridPositions < 0\n            var gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // list containing the nodes in the considered layer sorted by priority\n            var sorted = [];\n            for (var n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function(n1, n2) {\n                var n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                var n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n\n            // each node strives for its barycenter; high priority nodes start first\n            Utils.forEach(sorted, function(node) {\n                var nodeGridPos = node.gridPosition;\n                var nodeBaryCenter = this.calcBaryCenter(node);\n                var nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        },\n\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            var rightNode = layer[index + 1];\n            var rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft: function(node, layer, priority) {\n            var index = Utils.indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            var leftNode = layer[index - 1];\n            var leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n\n            return false;\n        },\n\n        mapVirtualNode: function(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        },\n\n        _nodesInLink: function(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        },\n\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify: function() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n\n            var layer, pos, newNode, node, r, newLink, i, l, links = this.graph.links.slice(0);\n            var layers = this.layers;\n\n            var addLinkBetweenLayers = function(upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n\n            for (l = 0; l < links.length; l++) {\n                var link = links[l];\n                var o = link.source;\n                var d = link.target;\n\n                var oLayer = o.layer;\n                var dLayer = d.layer;\n                var oPos = o.gridPosition;\n                var dPos = d.gridPosition;\n\n                var step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n\n                var p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                } else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n\n                        // check if origin and destination are both first\n                        else if (oPos === 0 && dPos === 0) {\n                            pos = 0;\n                        }\n\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n\n                        pos &= pos; // truncates to int\n                        Utils.insert(layer, newNode, pos);\n\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n\n                        p = newNode;\n\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                } else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        },\n\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify: function() {\n            var dedum = true;\n            while (dedum) {\n                dedum = false;\n\n                for (var l = 0; l < this.graph.links.length; l++) {\n                    var link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n\n                    var points = [];\n\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n\n                    // _dedummify the link\n                    var temp = link;\n                    var depthOfDumminess = link.depthOfDumminess;\n                    for (var d = 0; d < depthOfDumminess; d++) {\n                        var node = temp.source;\n                        var prevLink = node.incoming[0];\n\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n\n                        temp = prevLink;\n                    }\n\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n\n                    dedum = true;\n                    break;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings: function() {\n            var moves = -1, i;\n            var maxIterations = 3;\n            var iter = 0;\n\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                moves = 0;\n\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        },\n\n        calcUpData: function(layer) {\n            if (layer === 0) {\n                return;\n            }\n\n            var considered = this.layers[layer], i, l, link;\n            var upLayer = new Set();\n            var temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        },\n\n        calcDownData: function(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n\n            var considered = this.layers[layer], i , l, link;\n            var downLayer = new Set();\n            var temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n\n            for (i = 0; i < considered.length; i++) {\n                var node = considered[i];\n\n                // calculate barycenter\n                var sum = 0;\n                var total = 0;\n\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        },\n\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings: function(down, layer) {\n            var iconsidered;\n            var considered;\n\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n\n            // remember what it was\n            var presorted = considered.slice(0);\n\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n\n            var that = this;\n            // sort nodes within this layer according to the barycenters\n            considered.sort(function(n1, n2) {\n                var n1BaryCenter = that.calcBaryCenter(n1),\n                    n2BaryCenter = that.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return that.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                var compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return that.compareByIndex(n1, n2);\n            });\n\n            // count relocations\n            var i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                var inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    var node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n\n            return moves;\n        },\n\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs: function() {\n            var maxIterations = this.options.layeredIterations;\n            var iter = 0;\n\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n\n                var downwards = (iter % 4 <= 1);\n                var secondPass = (iter % 4 === 1);\n\n                for (var l = (downwards ? 0 : this.layers.length - 1);\n                     downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    var layer = this.layers[l];\n                    var hasSwapped = false;\n\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    var calcCrossings = true;\n                    var memCrossings = 0;\n\n                    for (var n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        var up = 0;\n                        var down = 0;\n                        var crossBefore = 0;\n\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n\n                        // Swap nodes\n                        var node1 = layer[n];\n                        var node2 = layer[n + 1];\n\n                        var node1GridPos = node1.gridPosition;\n                        var node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        var crossAfter = up + down;\n\n                        var revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        },\n\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers: function(ulayer, dlayer) {\n            var links = this.layers[ulayer].linksTo[dlayer];\n            var link1, link2, n11, n12, n21, n22, l1, l2;\n            var crossings = 0;\n            var length = links.length;\n\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n\n                    link2 = links[l2];\n\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n\n                    var n11gp = n11.gridPosition;\n                    var n12gp = n12.gridPosition;\n                    var n21gp = n21.gridPosition;\n                    var n22gp = n22.gridPosition;\n\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n\n            return crossings;\n        },\n\n        calcBaryCenter: function(node) {\n            var upstreamLinkCount = node.upstreamLinkCount;\n            var downstreamLinkCount = node.downstreamLinkCount;\n            var uBaryCenter = node.uBaryCenter;\n            var dBaryCenter = node.dBaryCenter;\n\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n\n            return 0;\n        },\n\n        _gridPositionComparer: function(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        },\n\n        _positionAscendingComparer: function(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        },\n\n        _positionDescendingComparer: function(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        },\n\n        _firstVirtualNode: function(layer) {\n            for (var c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        },\n\n        compareByIndex: function(o1, o2) {\n            var i1 = o1.index;\n            var i2 = o2.index;\n\n            if (i1 < i2) {\n                return 1;\n            }\n\n            if (i1 > i2) {\n                return -1;\n            }\n\n            return 0;\n        },\n\n        intDiv: function(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        },\n\n        nextVirtualNode: function(layer, node) {\n            var nodeIndex = node.layerIndex;\n            for (var i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n\n    });\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     * @type {*}\n     */\n    var LayoutState = kendo.Class.extend({\n        init: function(diagram, graphOrNodes) {\n            if (Utils.isUndefined(diagram)) {\n                throw \"No diagram given\";\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        },\n\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         * @param diagramOrGraphOrNodes\n         */\n        capture: function(diagramOrGraphOrNodes) {\n            var node,\n                nodes,\n                shape,\n                i,\n                conn,\n                link,\n                links;\n\n            if (diagramOrGraphOrNodes instanceof diagram.Graph) {\n\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    //shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (diagramOrGraphOrNodes.hasOwnProperty(\"links\") && diagramOrGraphOrNodes.hasOwnProperty(\"nodes\")) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                var shapes = this.diagram.shapes;\n                var connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    });\n\n    deepExtend(diagram, {\n        init: function(element) {\n            kendo.init(element, diagram.ui);\n        },\n        SpringLayout: SpringLayout,\n        TreeLayout: TreeLayout,\n        GraphAdapter: DiagramToHyperTreeAdapter,\n        LayeredLayout: LayeredLayout,\n        LayoutBase: LayoutBase,\n        LayoutState: LayoutState\n    });\n})(window.kendo.jQuery);\n\n}, __webpack_require__.amdD);\n\n\n/***/ }),\n\n/***/ 76837:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"./math\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/amd define */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.amdD = function () {\n/******/ \t\t\tthrow new Error('define cannot be used indirect');\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module used 'module' so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(92735);\n/******/ \tmodule.exports = __webpack_exports__;\n/******/ \t\n/******/ })()\n;"],"mappings":"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"},"metadata":{},"sourceType":"script"}