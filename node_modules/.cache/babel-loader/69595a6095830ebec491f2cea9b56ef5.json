{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\n    30616:\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // -*- fill-column: 100 -*-\n\n\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(22360)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        \"use strict\"; // WARNING: removing the following jshint declaration and turning\n        // == into === to make JSHint happy will break functionality.\n\n        var util = kendo.util;\n        var spreadsheet = kendo.spreadsheet;\n        var Ref = spreadsheet.Ref;\n        var RangeRef = spreadsheet.RangeRef;\n        var CellRef = spreadsheet.CellRef;\n        var NameRef = spreadsheet.NameRef;\n        var exports = spreadsheet.calc;\n        var runtime = exports.runtime; // Excel formula parser and compiler to JS.\n        // some code adapted from http://lisperator.net/pltut/\n        // these two will hold the same operators, except that when the comma is used as decimal\n        // separator, the union operator must be the semicolon (;) instead of comma.\n\n        var OPERATORS_STANDARD = Object.create(null);\n        var OPERATORS_COMMA = Object.create(null);\n\n        (function (ops) {\n          ops.forEach(function (cls, i) {\n            cls.forEach(function (op) {\n              OPERATORS_STANDARD[op] = ops.length - i;\n              OPERATORS_COMMA[op == \",\" ? \";\" : op] = ops.length - i;\n            });\n          });\n        })([[\":\"], [\" \"], [\",\"], [\"%\"], [\"^\"], [\"*\", \"/\"], [\"+\", \"-\"], [\"&\"], [\"=\", \"<\", \">\", \"<=\", \">=\", \"<>\"]]);\n\n        var OPERATORS = OPERATORS_STANDARD;\n        var SEPARATORS = {\n          DEC: \".\",\n          ARG: \",\",\n          COL: \",\"\n        };\n\n        function setDecimalSeparator(sep) {\n          SEPARATORS.DEC = sep;\n          SEPARATORS.ARG = sep == \",\" ? \";\" : \",\";\n          SEPARATORS.COL = sep == \",\" ? \"\\\\\" : \",\";\n          OPERATORS = sep == \",\" ? OPERATORS_COMMA : OPERATORS_STANDARD;\n        }\n\n        exports.withDecimalSeparator = function (sep, f) {\n          if (SEPARATORS.DEC == sep) {\n            return f();\n          }\n\n          var save = SEPARATORS.DEC;\n          setDecimalSeparator(sep);\n\n          try {\n            return f();\n          } finally {\n            setDecimalSeparator(save);\n          }\n        };\n\n        exports._separators = SEPARATORS;\n        var ParseError = kendo.Class.extend({\n          init: function ParseError(message, pos) {\n            this.message = message;\n            this.pos = pos;\n          },\n          toString: function () {\n            return this.message;\n          }\n        });\n        var TRUE = {\n          type: \"bool\",\n          value: true\n        };\n        var FALSE = {\n          type: \"bool\",\n          value: false\n        };\n\n        function getcol(str) {\n          str = str.toUpperCase();\n\n          for (var col = 0, i = 0; i < str.length; ++i) {\n            col = col * 26 + str.charCodeAt(i) - 64;\n          }\n\n          return col - 1;\n        }\n\n        function getrow(str) {\n          return parseInt(str, 10) - 1;\n        }\n\n        function parseReference(name, noThrow) {\n          if (name.toLowerCase() == \"#sheet\") {\n            return spreadsheet.SHEETREF;\n          }\n\n          OUT: {\n            // this is redundant, but let's keep it fast for the most\n            // common case — A1.  If this fails, we'll try to employ the\n            // whole tokenizer.\n            var m;\n\n            if (m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name)) {\n              var row = getrow(m[4]),\n                  col = getcol(m[2]);\n\n              if (row < 0x100000 && col < 0x4000) {\n                return new CellRef(getrow(m[4]), getcol(m[2]));\n              } // no NameRef-s from this function\n\n\n              break OUT;\n            }\n\n            var stream = TokenStream(name, {});\n            var a = [];\n\n            while (true) {\n              var ref = stream.next();\n\n              if (ref instanceof CellRef) {\n                // this function always makes absolute references\n                ref.rel = 0;\n              } else if (ref instanceof RangeRef) {\n                ref.topLeft.rel = 0;\n                ref.bottomRight.rel = 0;\n              } else {\n                break OUT;\n              }\n\n              a.push(ref);\n\n              if (stream.eof()) {\n                break;\n              }\n\n              if (!stream.is(\"op\", SEPARATORS.ARG)) {\n                break OUT;\n              }\n\n              stream.next();\n            }\n\n            return a.length == 1 ? a[0] : new spreadsheet.UnionRef(a);\n          }\n\n          if (!noThrow) {\n            throw new Error(\"Cannot parse reference: \" + name);\n          }\n        }\n\n        function parseFormula(sheet, row, col, input) {\n          var refs = [];\n          input = TokenStream(input, {\n            row: row,\n            col: col\n          });\n          var is = input.is;\n          return {\n            type: \"exp\",\n            ast: parseExpression(true),\n            refs: refs,\n            sheet: sheet,\n            row: row,\n            col: col\n          };\n\n          function addReference(ref) {\n            ref.index = refs.length;\n            refs.push(ref);\n            return ref;\n          }\n\n          function skip(type, value, allowEOF) {\n            if (is(type, value)) {\n              return input.next();\n            } else {\n              var tok = input.peek();\n\n              if (tok) {\n                input.croak(\"Expected \" + type + \" «\" + value + \"» but found \" + tok.type + \" «\" + tok.value + \"»\");\n              } else if (!allowEOF) {\n                input.croak(\"Expected \" + type + \" «\" + value + \"»\");\n              }\n            }\n          }\n\n          function parseExpression(commas) {\n            return maybeBinary(maybeIntersect(parseAtom()), 0, commas);\n          }\n\n          function parseSymbol(tok) {\n            if (tok.upper == \"TRUE\" || tok.upper == \"FALSE\") {\n              return tok.upper == \"TRUE\" ? TRUE : FALSE;\n            }\n\n            return addReference(new NameRef(tok.value));\n          }\n\n          function parseFuncall() {\n            var fname = input.next();\n            fname = fname.value;\n            skip(\"punc\", \"(\");\n            var args = [];\n\n            while (1) {\n              if (is(\"punc\", \")\")) {\n                break;\n              }\n\n              if (is(\"op\", SEPARATORS.ARG)) {\n                args.push({\n                  type: \"null\"\n                });\n                input.next();\n                continue;\n              }\n\n              args.push(parseExpression(false));\n\n              if (input.eof() || is(\"punc\", \")\")) {\n                break;\n              }\n\n              skip(\"op\", SEPARATORS.ARG);\n            }\n\n            skip(\"punc\", \")\", true);\n            return {\n              type: \"func\",\n              func: fname,\n              args: args\n            };\n          }\n\n          function fixReference(ref) {\n            if (!ref.hasSheet()) {\n              ref.setSheet(sheet);\n            }\n\n            return addReference(ref);\n          }\n\n          function parseAtom() {\n            var exp;\n\n            if (is(\"ref\")) {\n              exp = fixReference(input.next());\n            } else if (is(\"func\")) {\n              exp = parseFuncall();\n            } else if (is(\"punc\", \"(\")) {\n              input.next();\n              exp = parseExpression(true);\n              skip(\"punc\", \")\", true);\n            } else if (is(\"punc\", \"{\")) {\n              input.next();\n              exp = parseArray();\n              skip(\"punc\", \"}\", true);\n            } else if (is(\"num\") || is(\"str\") || is(\"error\")) {\n              exp = input.next();\n            } else if (is(\"sym\")) {\n              exp = parseSymbol(input.next());\n            } else if (is(\"op\", \"+\") || is(\"op\", \"-\")) {\n              exp = {\n                type: \"prefix\",\n                op: input.next().value,\n                exp: parseAtom()\n              };\n            } else if (!input.peek()) {\n              input.croak(\"Incomplete expression\");\n            } else if (is(\"punc\", \"[\")) {\n              input.croak(\"External reference not supported\");\n            } else {\n              input.croak(\"Parse error\");\n            }\n\n            return maybePercent(exp);\n          }\n\n          function parseArray() {\n            var row = [],\n                value = [row],\n                first = true;\n\n            while (!input.eof() && !is(\"punc\", \"}\")) {\n              if (first) {\n                first = false;\n              } else if (is(null, \";\")) {\n                value.push(row = []);\n                input.next();\n              } else {\n                skip(null, SEPARATORS.COL);\n              }\n\n              row.push(parseExpression(false));\n            }\n\n            return {\n              type: \"matrix\",\n              value: value\n            };\n          }\n\n          function maybeIntersect(exp) {\n            if (is(\"punc\", \"(\") || is(\"ref\") || is(\"num\") || is(\"func\")) {\n              return {\n                type: \"binary\",\n                op: \" \",\n                left: exp,\n                right: parseExpression(false)\n              };\n            } else {\n              return exp;\n            }\n          }\n\n          function maybePercent(exp) {\n            if (is(\"op\", \"%\")) {\n              input.next();\n              return maybePercent({\n                type: \"postfix\",\n                op: \"%\",\n                exp: exp\n              });\n            } else {\n              return exp;\n            }\n          }\n\n          function maybeBinary(left, my_prec, commas) {\n            var tok = is(\"op\");\n\n            if (tok && (commas || tok.value != SEPARATORS.ARG)) {\n              var his_prec = OPERATORS[tok.value];\n\n              if (his_prec > my_prec) {\n                input.next();\n                var right = maybeBinary(parseAtom(), his_prec, commas);\n                return maybeBinary({\n                  type: \"binary\",\n                  op: tok.value == \";\" ? \",\" : tok.value,\n                  // translate union back to comma\n                  left: left,\n                  right: right\n                }, my_prec, commas);\n              }\n            }\n\n            return left;\n          }\n        }\n\n        function parseNameDefinition(name, def) {\n          var nameRef = parseFormula(null, 0, 0, name);\n\n          if (!(nameRef.ast instanceof NameRef)) {\n            throw new ParseError(\"Invalid name: \" + name);\n          }\n\n          nameRef = nameRef.ast;\n\n          if (!(def instanceof Ref)) {\n            var defAST = parseFormula(nameRef.sheet, 0, 0, def);\n\n            if (defAST.ast instanceof Ref) {\n              def = defAST.ast; // single reference\n            } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {\n              def = defAST.ast.value; // constant\n            } else {\n              def = makeFormula(defAST); // formula\n            }\n          }\n\n          return {\n            name: nameRef,\n            value: def\n          };\n        }\n\n        var makeClosure = function (cache) {\n          return function (code) {\n            var f = cache[code];\n\n            if (!f) {\n              f = cache[code] = new Function(\"'use strict';return(\" + code + \")\")();\n            }\n\n            return f;\n          };\n        }(Object.create(null));\n\n        function makePrinter(exp) {\n          return makeClosure(\"function(row, col, mod){return(\" + print(exp.ast, exp, 0) + \")}\");\n\n          function print(node, parent, prec) {\n            switch (node.type) {\n              case \"num\":\n                return \"(kendo.spreadsheet.calc._separators.DEC == '.' ? \" + JSON.stringify(JSON.stringify(node.value)) + \" : \" + JSON.stringify(JSON.stringify(node.value)) + \".replace('.' , kendo.spreadsheet.calc._separators.DEC))\";\n\n              case \"bool\":\n                return JSON.stringify(node.value);\n\n              case \"error\":\n                return JSON.stringify(\"#\" + node.value);\n\n              case \"str\":\n                return JSON.stringify(JSON.stringify(node.value));\n\n              case \"ref\":\n                return \"this.refs[\" + node.index + \"].print(row, col, mod)\";\n\n              case \"prefix\":\n                return withParens(function () {\n                  return JSON.stringify(node.op) + \" + \" + print(node.exp, node, OPERATORS[node.op]);\n                });\n\n              case \"postfix\":\n                return withParens(function () {\n                  return print(node.exp, node, OPERATORS[node.op]) + \" + \" + JSON.stringify(node.op);\n                });\n\n              case \"binary\":\n                return withParens(function () {\n                  var left = parenthesize(print(node.left, node, OPERATORS[node.op]), node.left instanceof NameRef && node.op == \":\");\n                  var right = parenthesize(print(node.right, node, OPERATORS[node.op]), node.right instanceof NameRef && node.op == \":\");\n\n                  if (/^[,;]/.test(node.op)) {\n                    return left + \" + kendo.spreadsheet.calc._separators.ARG + \" + right;\n                  } else {\n                    return left + \" + \" + JSON.stringify(node.op) + \" + \" + right;\n                  }\n                });\n\n              case \"func\":\n                return JSON.stringify(node.func + \"(\") + \" + \" + (node.args.length > 0 ? node.args.map(function (arg) {\n                  return print(arg, node, 0);\n                }).join(\" + kendo.spreadsheet.calc._separators.ARG + ' ' + \") : \"''\") + \" + ')'\";\n\n              case \"matrix\":\n                return \"'{ ' + \" + node.value.map(function (el) {\n                  return el.map(function (el) {\n                    return print(el, node, 0);\n                  }).join(\" + kendo.spreadsheet.calc._separators.COL + ' ' + \");\n                }).join(\" + '; ' + \") + \"+ ' }'\";\n\n              case \"null\":\n                return \"''\";\n            }\n\n            throw new Error(\"Cannot make printer for node \" + node.type);\n\n            function withParens(f) {\n              var op = node.op;\n              var needParens = OPERATORS[op] < prec || !prec && op == \",\" || parent.type == \"prefix\" && prec == OPERATORS[op] && parent.op == \"-\" || parent.type == \"binary\" && prec == OPERATORS[op] && node === parent.right;\n              return parenthesize(f(), needParens);\n            }\n          }\n\n          function parenthesize(code, cond) {\n            return cond ? \"'(' + \" + code + \" + ')'\" : code;\n          }\n        }\n\n        function toCPS(ast, k) {\n          var GENSYM = 0;\n          return cps(ast, k);\n\n          function cps(node, k) {\n            switch (node.type) {\n              case \"ref\":\n                return cpsRef(node, k);\n\n              case \"num\":\n              case \"str\":\n              case \"null\":\n              case \"error\":\n              case \"bool\":\n                return cpsAtom(node, k);\n\n              case \"prefix\":\n              case \"postfix\":\n                return cpsUnary(node, k);\n\n              case \"binary\":\n                return cpsBinary(node, k);\n\n              case \"func\":\n                return cpsFunc(node, k);\n\n              case \"lambda\":\n                return cpsLambda(node, k);\n\n              case \"matrix\":\n                return cpsMatrix(node.value, k, true);\n            }\n\n            throw new Error(\"Cannot CPS \" + node.type);\n          }\n\n          function cpsRef(node, k) {\n            return node.ref == \"name\" ? cpsNameRef(node, k) : cpsAtom(node, k);\n          }\n\n          function cpsAtom(node, k) {\n            return k(node);\n          }\n\n          function cpsNameRef(node, k) {\n            return {\n              type: \"func\",\n              func: \",getname\",\n              args: [makeContinuation(k), node]\n            };\n          }\n\n          function cpsUnary(node, k) {\n            return cps({\n              type: \"func\",\n              func: \"unary\" + node.op,\n              args: [node.exp]\n            }, k);\n          }\n\n          function cpsBinary(node, k) {\n            return cps({\n              type: \"func\",\n              func: \"binary\" + node.op,\n              args: [node.left, node.right]\n            }, k);\n          }\n\n          function cpsIf(co, th, el, k) {\n            return cps(co, function (co) {\n              // compile THEN and ELSE into a lambda which takes a callback to invoke with the\n              // result of the branches, and the IF itself will become a call the internal \"if\"\n              // function.\n              var rest = makeContinuation(k);\n              var thenK = gensym(\"T\");\n              var elseK = gensym(\"E\");\n              return {\n                type: \"func\",\n                func: \"if\",\n                args: [rest, co, // condition\n                {\n                  // then\n                  type: \"lambda\",\n                  vars: [thenK],\n                  body: cps(th || TRUE, function (th) {\n                    return {\n                      type: \"call\",\n                      func: {\n                        type: \"var\",\n                        name: thenK\n                      },\n                      args: [th]\n                    };\n                  })\n                }, {\n                  // else\n                  type: \"lambda\",\n                  vars: [elseK],\n                  body: cps(el || FALSE, function (el) {\n                    return {\n                      type: \"call\",\n                      func: {\n                        type: \"var\",\n                        name: elseK\n                      },\n                      args: [el]\n                    };\n                  })\n                }]\n              };\n            });\n          }\n\n          function cpsAnd(args, k) {\n            if (args.length === 0) {\n              return cpsAtom(TRUE, k);\n            }\n\n            return cps({\n              type: \"func\",\n              func: \"IF\",\n              args: [// first item\n              args[0], // if true, apply AND for the rest\n              {\n                type: \"func\",\n                func: \"AND\",\n                args: args.slice(1)\n              }, // otherwise return false\n              FALSE]\n            }, k);\n          }\n\n          function cpsOr(args, k) {\n            if (args.length === 0) {\n              return cpsAtom(FALSE, k);\n            }\n\n            return cps({\n              type: \"func\",\n              func: \"IF\",\n              args: [// first item\n              args[0], // if true, return true\n              TRUE, // otherwise apply OR for the rest\n              {\n                type: \"func\",\n                func: \"OR\",\n                args: args.slice(1)\n              }]\n            }, k);\n          }\n\n          function cpsFunc(node, k) {\n            switch (node.func.toLowerCase()) {\n              case \"if\":\n                return cpsIf(node.args[0], node.args[1], node.args[2], k);\n\n              case \"and\":\n                return cpsAnd(node.args, k);\n\n              case \"or\":\n                return cpsOr(node.args, k);\n\n              case \"true\":\n                return k(TRUE);\n\n              case \"false\":\n                return k(FALSE);\n            } // actual function\n\n\n            return function loop(args, i) {\n              if (i == node.args.length) {\n                return {\n                  type: \"func\",\n                  func: node.func,\n                  args: args\n                };\n              } else {\n                return cps(node.args[i], function (value) {\n                  return loop(args.concat([value]), i + 1);\n                });\n              }\n            }([makeContinuation(k)], 0);\n          }\n\n          function cpsLambda(node, k) {\n            var cont = gensym(\"K\");\n            var body = cps(node.body, function (body) {\n              return {\n                type: \"call\",\n                func: {\n                  type: \"var\",\n                  value: cont\n                },\n                args: [body]\n              };\n            });\n            return k({\n              type: \"lambda\",\n              vars: [cont].concat(node.vars),\n              body: body\n            });\n          }\n\n          function cpsMatrix(elements, k, isMatrix) {\n            var a = [];\n            return function loop(i) {\n              if (i == elements.length) {\n                return k({\n                  type: \"matrix\",\n                  value: a\n                });\n              } else {\n                return (isMatrix ? cpsMatrix : cps)(elements[i], function (val) {\n                  a[i] = val;\n                  return loop(i + 1);\n                });\n              }\n            }(0);\n          }\n\n          function makeContinuation(k) {\n            var cont = gensym(\"R\");\n            return {\n              type: \"lambda\",\n              vars: [cont],\n              body: k({\n                type: \"var\",\n                name: cont\n              })\n            };\n          }\n\n          function gensym(name) {\n            if (!name) {\n              name = \"\";\n            }\n\n            name = \"_\" + name;\n            return name + ++GENSYM;\n          }\n        }\n\n        var FORMULA_CACHE = Object.create(null);\n\n        function makeFormula(exp) {\n          var printer = makePrinter(exp);\n          var hash = printer.call(exp); // needs .refs\n\n          var formula = FORMULA_CACHE[hash];\n\n          if (formula) {\n            // we need to clone because formulas cache the result; even if the formula is the same,\n            // its value will depend on its location, hence we need different objects.  Still, using\n            // this cache is a good idea because we'll reuse the same refs array, handler and\n            // printer instead of allocating new ones (and we skip compiling it).\n            return formula.clone(exp.sheet, exp.row, exp.col);\n          }\n\n          var code = js(toCPS(exp.ast, function (ret) {\n            return {\n              type: \"return\",\n              value: ret\n            };\n          }));\n          code = [\"function(){\", \"var context = this, refs = context.formula.absrefs\", code, \"}\"].join(\";\\n\");\n          formula = new runtime.Formula(exp.refs, makeClosure(code), printer, exp.sheet, exp.row, exp.col);\n          FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);\n          return formula;\n\n          function js(node) {\n            var type = node.type;\n\n            if (type == \"num\") {\n              return node.value + \"\";\n            } else if (type == \"str\") {\n              return JSON.stringify(node.value);\n            } else if (type == \"error\") {\n              return \"context.error(\" + JSON.stringify(node.value) + \")\";\n            } else if (type == \"return\") {\n              return \"context.resolve(\" + js(node.value) + \")\";\n            } else if (type == \"func\") {\n              return \"context.func(\" + JSON.stringify(node.func) + \", \" + js(node.args[0]) + \", \" // the callback\n              + jsArray(node.args.slice(1)) // the arguments\n              + \")\";\n            } else if (type == \"call\") {\n              return js(node.func) + \"(\" + node.args.map(js).join(\", \") + \")\";\n            } else if (type == \"ref\") {\n              return \"refs[\" + node.index + \"]\";\n            } else if (type == \"bool\") {\n              return \"\" + node.value;\n            } else if (type == \"if\") {\n              return \"(context.bool(\" + js(node.co) + \") ? \" + js(node.th) + \" : \" + js(node.el) + \")\";\n            } else if (type == \"lambda\") {\n              return \"(function(\" + node.vars.join(\", \") + \"){ return(\" + js(node.body) + \") })\";\n            } else if (type == \"var\") {\n              return node.name;\n            } else if (type == \"matrix\") {\n              return jsArray(node.value);\n            } else if (type == \"null\") {\n              return \"null\";\n            } else {\n              throw new Error(\"Cannot compile expression \" + type);\n            }\n          }\n\n          function jsArray(a) {\n            return \"[ \" + a.map(js).join(\", \") + \" ]\";\n          }\n        }\n\n        function identity(x) {\n          return x;\n        }\n\n        function TokenStream(input, options) {\n          input = RawTokenStream(InputStream(input), options);\n          var ahead = input.ahead;\n          var skip = input.skip;\n          var token = null;\n          var fixCell = options.row != null && options.col != null ? function (cell) {\n            if (cell.rel & 1) {\n              cell.col -= options.col;\n            }\n\n            if (cell.rel & 2) {\n              cell.row -= options.row;\n            }\n\n            return cell;\n          } : identity;\n          var addPos = options.forEditor ? function (thing, startToken, endToken) {\n            thing.begin = startToken.begin;\n            thing.end = endToken.end;\n            return thing;\n          } : identity;\n          return {\n            peek: peek,\n            next: next,\n            croak: input.croak,\n            eof: input.eof,\n            is: is\n          };\n\n          function is(type, value) {\n            var tok = peek();\n            return tok != null && (type == null || tok.type === type) && (value == null || tok.value === value) ? tok : null;\n          }\n\n          function peek() {\n            if (token == null) {\n              token = readNext();\n            }\n\n            return token;\n          }\n\n          function next() {\n            if (token != null) {\n              var tmp = token;\n              token = null;\n              return tmp;\n            }\n\n            return readNext();\n          }\n\n          function readNext() {\n            var ret;\n            var t = input.peek();\n\n            if (t) {\n              if (t.type == \"sym\" || t.type == \"rc\" || t.type == \"num\") {\n                ret = ahead(8, refRange3D) || ahead(6, refCell3D) || ahead(6, refSheetRange) || ahead(4, refSheetCell) || ahead(4, refRange) || ahead(2, refCell) || ahead(2, funcall);\n              }\n\n              if (!ret) {\n                ret = input.next();\n              }\n            }\n\n            return ret;\n          }\n\n          function toCell(tok, isFirst) {\n            if (tok.type == \"rc\") {\n              // RC notation is read properly without knowing where\n              // we are, so no need to fixCell on this one.\n              // However, if only absolute refs were asked for (from\n              // i.e. parseReference) I feel it's alright to yell\n              // about it here.\n              if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {\n                input.croak(\"Cannot read relative cell in RC notation\");\n              }\n\n              return new CellRef(tok.row, tok.col, tok.rel);\n            }\n\n            if (tok.type == \"num\") {\n              if (tok.value <= 1048577) {\n                // whole row\n                return fixCell(new CellRef(getrow(tok.value), isFirst ? -Infinity : +Infinity, 2));\n              } else {\n                return null;\n              }\n            } // otherwise it's \"sym\".  The OOXML spec (SpreadsheetML\n            // 18.2.5) defines the maximum value to be interpreted as\n            // a cell reference to be XFD1048576.\n\n\n            var name = tok.value;\n            var m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name);\n\n            if (m) {\n              var row = getrow(m[4]),\n                  col = getcol(m[2]);\n\n              if (row <= 1048576 && col <= 16383) {\n                return fixCell(new CellRef(getrow(m[4]), getcol(m[2]), (m[1] ? 0 : 1) | (m[3] ? 0 : 2)));\n              } else {\n                return null;\n              }\n            }\n\n            var abs = name.charAt(0) == \"$\";\n\n            if (abs) {\n              name = name.substr(1);\n            }\n\n            if (/^\\d+$/.test(name)) {\n              var row = getrow(name);\n\n              if (row <= 1048576) {\n                return fixCell(new CellRef(getrow(name), isFirst ? -Infinity : +Infinity, abs ? 0 : 2));\n              }\n            } else {\n              var col = getcol(name);\n\n              if (col <= 16383) {\n                return fixCell(new CellRef(isFirst ? -Infinity : +Infinity, getcol(name), abs ? 0 : 1));\n              }\n            }\n          } // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)\n\n\n          function refRange3D(a, b, c, d, e, f, g, h) {\n            if (a.type == \"sym\" && b.type == \"op\" && b.value == \":\" && c.type == \"sym\" && d.type == \"punc\" && d.value == \"!\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && f.type == \"op\" && f.value == \":\" && (g.type == \"sym\" || g.type == \"rc\" || g.type == \"num\" && g.value == g.value | 0) && g.type == e.type && !(h.type == \"punc\" && h.value == \"(\" && !g.space)) {\n              var tl = toCell(e, true),\n                  br = toCell(g, false);\n\n              if (tl && br) {\n                // skip them except the last one, we only wanted to\n                // ensure it's not paren.\n                skip(7);\n                return addPos(new RangeRef(tl.setSheet(a.value, true), br.setSheet(c.value, true)).setSheet(a.value, true), a, g);\n              }\n            }\n          } // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)\n\n\n          function refCell3D(a, b, c, d, e, f) {\n            if (a.type == \"sym\" && b.type == \"op\" && b.value == \":\" && c.type == \"sym\" && d.type == \"punc\" && d.value == \"!\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && !(f.type == \"punc\" && f.value == \"(\" && !e.space)) {\n              var tl = toCell(e);\n\n              if (tl) {\n                skip(5);\n                var br = tl.clone();\n                return addPos(new RangeRef(tl.setSheet(a.value, true), br.setSheet(c.value, true)).setSheet(a.value, true), a, e);\n              }\n            }\n          } // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)\n\n\n          function refSheetRange(a, b, c, d, e, f) {\n            if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"!\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && d.type == \"op\" && d.value == \":\" && (e.type == \"sym\" || e.type == \"rc\" || e.type == \"num\" && e.value == e.value | 0) && !(f.type == \"punc\" && f.value == \"(\" && !e.space)) {\n              var tl = toCell(c, true),\n                  br = toCell(e, false);\n\n              if (tl && br) {\n                skip(5);\n                return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);\n              }\n            }\n          } // Sheet1(a) !(b) A1(c) not followed by paren (d)\n\n\n          function refSheetCell(a, b, c, d) {\n            if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"!\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && !(d.type == \"punc\" && d.value == \"(\" && !c.space)) {\n              skip(3);\n              var x = toCell(c);\n\n              if (!x || !isFinite(x.row)) {\n                x = new NameRef(c.value);\n              }\n\n              return addPos(x.setSheet(a.value, true), a, c);\n            }\n          } // A1(a) :(b) C3(c) not followed by paren (d)\n\n\n          function refRange(a, b, c, d) {\n            if ((a.type == \"sym\" || a.type == \"rc\" || a.type == \"num\" && a.value == a.value | 0) && b.type == \"op\" && b.value == \":\" && (c.type == \"sym\" || c.type == \"rc\" || c.type == \"num\" && c.value == c.value | 0) && !(d.type == \"punc\" && d.value == \"(\" && !c.space)) {\n              var tl = toCell(a, true),\n                  br = toCell(c, false);\n\n              if (tl && br) {\n                skip(3);\n                return addPos(new RangeRef(tl, br), a, c);\n              }\n            }\n          } // A1(a) not followed by paren (b)\n\n\n          function refCell(a, b) {\n            if ((a.type == \"sym\" || a.type == \"rc\") && !(b.type == \"punc\" && b.value == \"(\" && !a.space)) {\n              var x = toCell(a);\n\n              if (x && isFinite(x.row) && isFinite(x.col)) {\n                skip(1);\n                return addPos(x, a, a);\n              }\n            }\n          }\n\n          function funcall(a, b) {\n            if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"(\" && !a.space) {\n              a.type = \"func\";\n              skip(1);\n              return a; // already has position\n            }\n          }\n        }\n\n        function isWhitespace(ch) {\n          return \" \\t\\r\\n\\xa0\\u200b\".indexOf(ch) >= 0;\n        }\n\n        var EOF = {\n          type: \"eof\"\n        };\n\n        function RawTokenStream(input, options) {\n          var tokens = [],\n              index = 0;\n          var readWhile = input.readWhile;\n          return {\n            next: next,\n            peek: peek,\n            eof: eof,\n            croak: input.croak,\n            ahead: ahead,\n            skip: skip\n          };\n\n          function isDigit(ch) {\n            return /[0-9]/i.test(ch);\n          }\n\n          function isIdStart(ch) {\n            return /[a-z$_]/i.test(ch) || util.isUnicodeLetter(ch);\n          }\n\n          function isId(ch) {\n            return isIdStart(ch) || isDigit(ch) || ch == \".\";\n          }\n\n          function isOpChar(ch) {\n            return ch in OPERATORS;\n          }\n\n          function isPunc(ch) {\n            return \"\\\\!;(){}[]\".indexOf(ch) >= 0;\n          }\n\n          function readNumber() {\n            // XXX: TODO: exponential notation\n            var has_dot = false;\n            var number = readWhile(function (ch) {\n              if (ch == SEPARATORS.DEC) {\n                if (has_dot) {\n                  return false;\n                }\n\n                has_dot = true;\n                return true;\n              }\n\n              return isDigit(ch);\n            });\n\n            if (number == SEPARATORS.DEC) {\n              return {\n                type: \"punc\",\n                value: SEPARATORS.DEC\n              };\n            } else {\n              return {\n                type: \"num\",\n                value: parseFloat(number.replace(SEPARATORS.DEC, \".\"))\n              };\n            }\n          }\n\n          function symbol(id, quote) {\n            return {\n              type: \"sym\",\n              value: id,\n              upper: id.toUpperCase(),\n              space: isWhitespace(input.peek()),\n              quote: quote\n            };\n          }\n\n          function getRC(a, b, c) {\n            if (!a && !b && !c) {\n              return null;\n            }\n\n            if (!a && !c || a && c) {\n              var num = b ? parseInt(b, 10) : 0;\n              return a ? num : num - 1;\n            }\n          }\n\n          function readSymbol() {\n            var m = input.lookingAt(/^R(\\[)?(-?[0-9]+)?(\\])?C(\\[)?(-?[0-9]+)?(\\])?/i);\n\n            if (m) {\n              var row = getRC(m[1], m[2], m[3]);\n              var col = getRC(m[4], m[5], m[6]);\n\n              if (row != null && col != null) {\n                input.skip(m);\n                return {\n                  type: \"rc\",\n                  row: row,\n                  col: col,\n                  rel: (m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0 // col\n                  ) | (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row\n\n                };\n              }\n            }\n\n            return symbol(readWhile(isId));\n          }\n\n          function readString() {\n            input.next();\n            return {\n              type: \"str\",\n              value: input.readEscaped('\"')\n            };\n          }\n\n          function readSheetName() {\n            input.next();\n            return symbol(input.readEscaped(\"'\"), true);\n          }\n\n          function readOperator() {\n            return {\n              type: \"op\",\n              value: readWhile(function (ch, op) {\n                return op + ch in OPERATORS;\n              })\n            };\n          }\n\n          function readPunc() {\n            return {\n              type: \"punc\",\n              value: input.next()\n            };\n          }\n\n          function readNext() {\n            if (input.eof()) {\n              return null;\n            }\n\n            var ch = input.peek(),\n                m;\n\n            if (ch == '\"') {\n              return readString();\n            }\n\n            if (ch == \"'\") {\n              return readSheetName();\n            }\n\n            if (isDigit(ch) || ch == SEPARATORS.DEC) {\n              return readNumber();\n            }\n\n            if (isIdStart(ch)) {\n              return readSymbol();\n            }\n\n            if (isOpChar(ch)) {\n              return readOperator();\n            }\n\n            if (isPunc(ch)) {\n              return readPunc();\n            }\n\n            if (m = input.lookingAt(/^#([a-z\\/]+)[?!]?/i)) {\n              input.skip(m);\n              return {\n                type: \"error\",\n                value: m[1]\n              };\n            }\n\n            if (!options.forEditor) {\n              input.croak(\"Can't handle character with code: \" + ch.charCodeAt(0));\n            }\n\n            return {\n              type: \"error\",\n              value: input.next()\n            };\n          }\n\n          function peek() {\n            while (tokens.length <= index) {\n              readWhile(isWhitespace);\n              var begin = input.pos();\n              var tok = readNext();\n\n              if (options.forEditor && tok) {\n                tok.begin = begin;\n                tok.end = input.pos();\n              }\n\n              tokens.push(tok);\n            }\n\n            return tokens[index];\n          }\n\n          function next() {\n            var tok = peek();\n\n            if (tok) {\n              index++;\n            }\n\n            return tok;\n          }\n\n          function ahead(n, f) {\n            var pos = index,\n                a = [];\n\n            while (n-- > 0) {\n              a.push(next() || EOF);\n            }\n\n            index = pos;\n            return f.apply(a, a);\n          }\n\n          function skip(n) {\n            index += n;\n          }\n\n          function eof() {\n            return peek() == null;\n          }\n        }\n\n        function InputStream(input) {\n          var pos = 0,\n              line = 1,\n              col = 0;\n          return {\n            next: next,\n            peek: peek,\n            eof: eof,\n            croak: croak,\n            readWhile: readWhile,\n            readEscaped: readEscaped,\n            lookingAt: lookingAt,\n            skip: skip,\n            forward: forward,\n            pos: location\n          };\n\n          function location() {\n            return pos;\n          }\n\n          function next() {\n            var ch = input.charAt(pos++);\n\n            if (ch == \"\\n\") {\n              line++;\n              col = 0;\n            } else {\n              col++;\n            }\n\n            return ch;\n          }\n\n          function peek() {\n            return input.charAt(pos);\n          }\n\n          function eof() {\n            return peek() === \"\";\n          }\n\n          function croak(msg) {\n            throw new ParseError(msg + \" (input: \" + input + \")\", pos);\n          }\n\n          function skip(ch) {\n            if (typeof ch == \"string\") {\n              if (input.substr(pos, ch.length) != ch) {\n                croak(\"Expected \" + ch);\n              }\n\n              forward(ch.length);\n            } else if (ch instanceof RegExp) {\n              var m = ch.exec(input.substr(pos));\n\n              if (m) {\n                forward(m[0].length);\n                return m;\n              }\n            } else {\n              // assuming RegExp match data\n              forward(ch[0].length);\n            }\n          }\n\n          function forward(n) {\n            while (n-- > 0) {\n              next();\n            }\n          }\n\n          function readEscaped(end) {\n            var escaped = false,\n                str = \"\";\n\n            while (!eof()) {\n              var ch = next();\n\n              if (escaped) {\n                str += ch;\n                escaped = false;\n              } else if (ch == \"\\\\\") {\n                escaped = true;\n              } else if (ch == end) {\n                break;\n              } else {\n                str += ch;\n              }\n            }\n\n            return str;\n          }\n\n          function readWhile(predicate) {\n            var str = \"\";\n\n            while (!eof() && predicate(peek(), str)) {\n              str += next();\n            }\n\n            return str;\n          }\n\n          function lookingAt(rx) {\n            return rx.exec(input.substr(pos));\n          }\n        } //// exports\n\n\n        var FORMAT_PARSERS = [];\n\n        var registerFormatParser = exports.registerFormatParser = function (p) {\n          FORMAT_PARSERS.push(p);\n        };\n\n        exports.parse = function (sheet, row, col, input, format) {\n          if (input instanceof Date) {\n            return {\n              type: \"date\",\n              value: runtime.dateToSerial(input)\n            };\n          }\n\n          if (typeof input == \"number\") {\n            return {\n              type: \"number\",\n              value: input\n            };\n          }\n\n          if (typeof input == \"boolean\") {\n            return {\n              type: \"boolean\",\n              value: input\n            };\n          }\n\n          input += \"\";\n\n          if (/^'/.test(input)) {\n            return {\n              type: \"string\",\n              value: input.substr(1)\n            };\n          } // trivial (integer) percent values; more complex formats are handled below via\n          // registerFormatParser; this case could be dropped completely.\n\n\n          if (/^-?[0-9]+%$/.test(input)) {\n            var str = input.substr(0, input.length - 1);\n            var num = parseFloat(str);\n\n            if (!isNaN(num) && num == str) {\n              return {\n                type: \"percent\",\n                value: num / 100\n              };\n            }\n          }\n\n          if (/^=/.test(input)) {\n            input = input.substr(1);\n\n            if (/\\S/.test(input)) {\n              return parseFormula(sheet, row, col, input);\n            } else {\n              return {\n                type: \"string\",\n                value: \"=\" + input\n              };\n            }\n          }\n\n          for (var i = 0; i < FORMAT_PARSERS.length; ++i) {\n            var result = FORMAT_PARSERS[i](input);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          if (input.toLowerCase() == \"true\") {\n            return {\n              type: \"boolean\",\n              value: true\n            };\n          }\n\n          if (input.toLowerCase() == \"false\") {\n            return {\n              type: \"boolean\",\n              value: false\n            };\n          }\n\n          var date = runtime.parseDate(input, format);\n\n          if (date) {\n            return {\n              type: \"date\",\n              value: runtime.dateToSerial(date)\n            };\n          }\n\n          var num = parseFloat(input);\n\n          if (!isNaN(num) && input.length > 0 && num == input) {\n            format = null;\n\n            if (num != Math.floor(num)) {\n              format = \"0.\" + String(num).split(\".\")[1].replace(/\\d/g, \"0\");\n            }\n\n            return {\n              type: \"number\",\n              value: num,\n              format: format\n            };\n          }\n\n          return {\n            type: \"string\",\n            value: input\n          };\n        };\n\n        function tokenize(input, row, col) {\n          var tokens = [];\n          input = TokenStream(input, {\n            forEditor: true,\n            row: row,\n            col: col\n          });\n\n          while (!input.eof()) {\n            tokens.push(next());\n          }\n\n          var tok = tokens[0];\n\n          if (tok.type == \"op\" && tok.value == \"=\") {\n            tok.type = \"startexp\";\n          }\n\n          return tokens;\n\n          function next() {\n            var tok = input.next();\n\n            if (tok.type == \"sym\") {\n              if (tok.upper == \"TRUE\") {\n                tok.type = \"bool\";\n                tok.value = true;\n              } else if (tok.upper == \"FALSE\") {\n                tok.type = \"bool\";\n                tok.value = false;\n              }\n            } else if (tok.type == \"ref\") {\n              tok = {\n                type: \"ref\",\n                ref: row != null && col != null ? tok.absolute(row, col) : tok,\n                begin: tok.begin,\n                end: tok.end\n              };\n            }\n\n            return tok;\n          }\n        } // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of\n        // references.  This helper is called from excel-reader.js to parse them.\n\n\n        function parseSqref(input, row, col) {\n          row = row || 0;\n          col = col || 0;\n          input = TokenStream(input, {\n            row: row,\n            col: col\n          });\n          var refs = [];\n\n          while (!input.eof()) {\n            var ref = input.next();\n\n            if (ref.type != \"ref\") {\n              throw new ParseError(\"Expecting a reference but got: \" + JSON.stringify(ref));\n            }\n\n            refs.push(ref.absolute(row, col));\n          }\n\n          return refs;\n        }\n\n        exports.parseNameDefinition = parseNameDefinition;\n        exports.parseFormula = parseFormula;\n        exports.parseReference = parseReference;\n        exports.compile = makeFormula;\n        exports.parseSqref = parseSqref;\n        exports.InputStream = InputStream;\n        exports.ParseError = ParseError;\n        exports.tokenize = tokenize;\n        /* -----[ a few special formats ]----- */\n        // various time formats\n\n        registerFormatParser(function (input) {\n          var m,\n              date = 0,\n              format = \"\"; // have date part?\n\n          if (m = /^(\\d+)([-/.])(\\d+)\\2(\\d{2}(?:\\d{2})?)(\\s*)/.exec(input)) {\n            var mo = parseInt(m[1], 10);\n            var sep = m[2];\n            var da = parseInt(m[3], 10);\n            var yr = parseInt(m[4], 10);\n\n            if (yr < 30) {\n              yr += 2000;\n            } else if (yr < 100) {\n              yr += 1900;\n            }\n\n            var monthFirst = true;\n\n            if (mo > 12) {\n              var tmp = mo;\n              mo = da;\n              da = tmp;\n              monthFirst = false;\n            }\n\n            if (!runtime.validDate(yr, mo, da)) {\n              return null;\n            }\n\n            date = runtime.packDate(yr, mo - 1, da);\n\n            if (date < 0) {\n              date--;\n            }\n\n            if (monthFirst) {\n              format = [\"mm\", \"dd\", \"yyyy\"].join(sep);\n            } else {\n              format = [\"dd\", \"mm\", \"yyyy\"].join(sep);\n            }\n\n            format += m[5];\n            input = input.substr(m[0].length); // skip the date\n          } // hh:mm\n\n\n          if (m = /^(\\d+):(\\d+)$/.exec(input)) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            return {\n              type: \"date\",\n              format: format + \"hh:mm\",\n              value: date + runtime.packTime(hh, mm, 0, 0)\n            };\n          } // mm:ss.ms\n\n\n          if (m = /^(\\d+):(\\d+)(\\.\\d+)$/.exec(input)) {\n            var mm = parseInt(m[1], 10);\n            var ss = parseInt(m[2], 10);\n            var ms = parseFloat(m[3]) * 1000;\n            return {\n              type: \"date\",\n              format: format + \"mm:ss.00\",\n              value: date + runtime.packTime(0, mm, ss, ms)\n            };\n          } // hh:mm:ss\n\n\n          if (m = /^(\\d+):(\\d+):(\\d+)$/.exec(input)) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            var ss = parseInt(m[3], 10);\n            return {\n              type: \"date\",\n              format: format + \"hh:mm:ss\",\n              value: date + runtime.packTime(hh, mm, ss, 0)\n            };\n          } // hh:mm:ss.ms\n\n\n          if (m = /^(\\d+):(\\d+):(\\d+)(\\.\\d+)$/.exec(input)) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            var ss = parseInt(m[3], 10);\n            var ms = parseFloat(m[4]) * 1000;\n            return {\n              type: \"date\",\n              format: format + \"hh:mm:ss.00\",\n              value: date + runtime.packTime(hh, mm, ss, ms)\n            };\n          }\n        }); // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,\n        // `$1234`, `123,456.78 $` etc.  I apologize for this code.\n\n        registerFormatParser(function (input) {\n          var m, n;\n          var culture = kendo.culture();\n          var comma = culture.numberFormat[\",\"];\n          var dot = culture.numberFormat[\".\"];\n          var currency = culture.numberFormat.currency.symbol;\n          var rxnum = getNumberRegexp(comma, dot);\n          var rxcur = new RegExp(\"^\\\\s*\\\\\" + currency + \"\\\\s*\");\n          var sign = 1;\n          var format = \"\";\n          var suffix = \"\";\n          var has_currency = false;\n          var has_percent = false;\n          input = InputStream(input.replace(/^\\s+|\\s+$/g, \"\")); // has minus before currency?\n\n          if (input.skip(/^-\\s*/)) {\n            sign = -1;\n          } // has currency before number?\n\n\n          if (m = input.skip(rxcur)) {\n            has_currency = true;\n            format += '\"' + m[0] + '\"';\n          } // has minus after currency?\n\n\n          if (input.skip(/^-\\s*/)) {\n            if (sign < 0) {\n              return null; // not a number\n            }\n\n            sign = -1;\n          } // read the number itself\n\n\n          if (!(n = input.skip(rxnum))) {\n            return null; // not a number\n          }\n\n          format += \"0\"; // has currency after number?\n\n          if (m = input.skip(rxcur)) {\n            if (has_currency) {\n              return null; // either before or after, not both.\n            }\n\n            has_currency = true;\n            suffix = '\"' + m[0] + '\"';\n          } // has percent after number?\n\n\n          if (!has_currency && (m = input.skip(/^\\s*%\\s*/))) {\n            has_percent = true;\n            suffix = m[0]; // no quotes this time, % is special in format\n          }\n\n          if (!input.eof()) {\n            return null; // should anything else follow, not a number\n          }\n\n          if (n[2] || has_currency) {\n            format = format.replace(\"0\", \"#\");\n            format += \",0\";\n          }\n\n          if (n[3]) {\n            format += \".\" + repeat(\"0\", n[3].length - 1);\n          }\n\n          var value = n[0].replace(new RegExp(\"\\\\\" + comma, \"g\"), \"\").replace(new RegExp(\"\\\\\" + dot, \"g\"), \".\");\n          value = parseFloat(value);\n\n          if (has_percent) {\n            value /= 100;\n          }\n\n          format += suffix;\n\n          if (has_currency) {\n            format += ';-' + format;\n          }\n\n          return {\n            type: \"number\",\n            currency: has_currency,\n            format: format,\n            value: sign * value\n          };\n        });\n        registerFormatParser(function (input) {\n          var m;\n\n          if (m = /^([0-9]*)\\.([0-9]+)(\\s*%)$/.exec(input)) {\n            return {\n              type: \"number\",\n              value: parseFloat(input) / 100,\n              format: \"0.\" + repeat(\"0\", m[2].length) + m[3]\n            };\n          }\n        });\n        var NUMBER_FORMAT_RX = {};\n\n        function getNumberRegexp(comma, dot) {\n          var id = comma + dot;\n          var rx = NUMBER_FORMAT_RX[id];\n\n          if (!rx) {\n            rx = \"^(\\\\d+(COM\\\\d{3})*(DOT\\\\d+)?)\";\n            rx = rx.replace(/DOT/g, \"\\\\\" + dot).replace(/COM/g, \"\\\\\" + comma);\n            rx = new RegExp(rx);\n            NUMBER_FORMAT_RX[id] = rx;\n          }\n\n          return rx;\n        }\n\n        function repeat(str, len) {\n          var out = \"\";\n\n          while (len-- > 0) {\n            out += str;\n          }\n\n          return out;\n        }\n      }, __webpack_require__.amdD);\n      /***/\n\n    },\n\n    /***/\n    22360:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"./runtime\");\n      /***/\n    }\n    /******/\n\n  };\n  /************************************************************************/\n\n  /******/\n  // The module cache\n\n  /******/\n\n  var __webpack_module_cache__ = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n\n    if (cachedModule !== undefined) {\n      /******/\n      return cachedModule.exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/\n      // no module.id needed\n\n      /******/\n      // no module.loaded needed\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /* webpack/runtime/amd define */\n\n  /******/\n\n\n  !function () {\n    /******/\n    __webpack_require__.amdD = function () {\n      /******/\n      throw new Error('define cannot be used indirect');\n      /******/\n    };\n    /******/\n\n  }();\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /******/\n  // startup\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n  // This entry module used 'module' so it can't be inlined\n\n  /******/\n\n  var __webpack_exports__ = __webpack_require__(30616);\n  /******/\n\n\n  module.exports = __webpack_exports__;\n  /******/\n\n  /******/\n})();","map":{"version":3,"names":["__webpack_modules__","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","f","define","apply","undefined","util","kendo","spreadsheet","Ref","RangeRef","CellRef","NameRef","calc","runtime","OPERATORS_STANDARD","Object","create","OPERATORS_COMMA","ops","forEach","cls","i","op","length","OPERATORS","SEPARATORS","DEC","ARG","COL","setDecimalSeparator","sep","withDecimalSeparator","save","_separators","ParseError","Class","extend","init","message","pos","toString","TRUE","type","value","FALSE","getcol","str","toUpperCase","col","charCodeAt","getrow","parseInt","parseReference","name","noThrow","toLowerCase","SHEETREF","OUT","m","exec","row","stream","TokenStream","a","ref","next","rel","topLeft","bottomRight","push","eof","is","UnionRef","Error","parseFormula","sheet","input","refs","ast","parseExpression","addReference","index","skip","allowEOF","tok","peek","croak","commas","maybeBinary","maybeIntersect","parseAtom","parseSymbol","upper","parseFuncall","fname","args","func","fixReference","hasSheet","setSheet","exp","parseArray","maybePercent","first","left","right","my_prec","his_prec","parseNameDefinition","def","nameRef","defAST","test","makeFormula","makeClosure","cache","code","Function","makePrinter","print","node","parent","prec","JSON","stringify","withParens","parenthesize","map","arg","join","el","needParens","cond","toCPS","k","GENSYM","cps","cpsRef","cpsAtom","cpsUnary","cpsBinary","cpsFunc","cpsLambda","cpsMatrix","cpsNameRef","makeContinuation","cpsIf","co","th","rest","thenK","gensym","elseK","vars","body","cpsAnd","slice","cpsOr","loop","concat","cont","elements","isMatrix","val","FORMULA_CACHE","printer","hash","call","formula","clone","js","ret","Formula","jsArray","identity","x","options","RawTokenStream","InputStream","ahead","token","fixCell","cell","addPos","forEditor","thing","startToken","endToken","begin","end","readNext","tmp","t","refRange3D","refCell3D","refSheetRange","refSheetCell","refRange","refCell","funcall","toCell","isFirst","Infinity","abs","charAt","substr","b","c","d","e","g","h","space","tl","br","isFinite","isWhitespace","ch","indexOf","EOF","tokens","readWhile","isDigit","isIdStart","isUnicodeLetter","isId","isOpChar","isPunc","readNumber","has_dot","number","parseFloat","replace","symbol","id","quote","getRC","num","readSymbol","lookingAt","readString","readEscaped","readSheetName","readOperator","readPunc","n","line","forward","location","msg","RegExp","escaped","predicate","rx","FORMAT_PARSERS","registerFormatParser","p","parse","format","Date","dateToSerial","isNaN","result","date","parseDate","Math","floor","String","split","tokenize","absolute","parseSqref","compile","mo","da","yr","monthFirst","validDate","packDate","hh","mm","packTime","ss","ms","culture","comma","numberFormat","dot","currency","rxnum","getNumberRegexp","rxcur","sign","suffix","has_currency","has_percent","repeat","NUMBER_FORMAT_RX","len","out","amdD","require","__webpack_module_cache__","moduleId","cachedModule","__webpack_exports__"],"sources":["C:/Users/abodean/restapi-nodejs/vuejs/app-router/node_modules/@progress/kendo-ui/js/spreadsheet/calc.js"],"sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 30616:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// -*- fill-column: 100 -*-\n\n(function(f, define){\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(22360) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(function(){\n    \"use strict\";\n\n    // WARNING: removing the following jshint declaration and turning\n    // == into === to make JSHint happy will break functionality.\n\n    var util = kendo.util;\n    var spreadsheet = kendo.spreadsheet;\n    var Ref = spreadsheet.Ref;\n    var RangeRef = spreadsheet.RangeRef;\n    var CellRef = spreadsheet.CellRef;\n    var NameRef = spreadsheet.NameRef;\n    var exports = spreadsheet.calc;\n    var runtime = exports.runtime;\n\n    // Excel formula parser and compiler to JS.\n    // some code adapted from http://lisperator.net/pltut/\n\n    // these two will hold the same operators, except that when the comma is used as decimal\n    // separator, the union operator must be the semicolon (;) instead of comma.\n    var OPERATORS_STANDARD = Object.create(null);\n    var OPERATORS_COMMA = Object.create(null);\n\n    (function(ops){\n        ops.forEach(function(cls, i){\n            cls.forEach(function(op){\n                OPERATORS_STANDARD[op] = ops.length - i;\n                OPERATORS_COMMA[op == \",\" ? \";\" : op] = ops.length - i;\n            });\n        });\n    })([\n        [ \":\" ],\n        [ \" \" ],\n        [ \",\" ],\n        [ \"%\" ],\n        [ \"^\" ],\n        [ \"*\", \"/\" ],\n        [ \"+\", \"-\" ],\n        [ \"&\" ],\n        [ \"=\", \"<\", \">\", \"<=\", \">=\", \"<>\" ]\n    ]);\n\n    var OPERATORS = OPERATORS_STANDARD;\n\n    var SEPARATORS = {\n        DEC: \".\",\n        ARG: \",\",\n        COL: \",\"\n    };\n\n    function setDecimalSeparator(sep) {\n        SEPARATORS.DEC = sep;\n        SEPARATORS.ARG = sep == \",\" ? \";\" : \",\";\n        SEPARATORS.COL = sep == \",\" ? \"\\\\\" : \",\";\n        OPERATORS = sep == \",\" ? OPERATORS_COMMA : OPERATORS_STANDARD;\n    }\n\n    exports.withDecimalSeparator = function(sep, f) {\n        if (SEPARATORS.DEC == sep) {\n            return f();\n        }\n        var save = SEPARATORS.DEC;\n        setDecimalSeparator(sep);\n        try {\n            return f();\n        } finally {\n            setDecimalSeparator(save);\n        }\n    };\n\n    exports._separators = SEPARATORS;\n\n    var ParseError = kendo.Class.extend({\n        init: function ParseError(message, pos) {\n            this.message = message;\n            this.pos = pos;\n        },\n        toString: function() {\n            return this.message;\n        }\n    });\n\n    var TRUE = { type: \"bool\", value: true };\n    var FALSE = { type: \"bool\", value: false };\n\n    function getcol(str) {\n        str = str.toUpperCase();\n        for (var col = 0, i = 0; i < str.length; ++i) {\n            col = col * 26 + str.charCodeAt(i) - 64;\n        }\n        return col - 1;\n    }\n\n    function getrow(str) {\n        return parseInt(str, 10) - 1;\n    }\n\n    function parseReference(name, noThrow) {\n        if (name.toLowerCase() == \"#sheet\") {\n            return spreadsheet.SHEETREF;\n        }\n        OUT: {\n            // this is redundant, but let's keep it fast for the most\n            // common case — A1.  If this fails, we'll try to employ the\n            // whole tokenizer.\n            var m;\n            if ((m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name))) {\n                var row = getrow(m[4]), col = getcol(m[2]);\n                if (row < 0x100000 && col < 0x4000) {\n                    return new CellRef(getrow(m[4]), getcol(m[2]));\n                }\n                // no NameRef-s from this function\n                break OUT;\n            }\n            var stream = TokenStream(name, {});\n            var a = [];\n            while (true) {\n                var ref = stream.next();\n                if (ref instanceof CellRef) {\n                    // this function always makes absolute references\n                    ref.rel = 0;\n                } else if (ref instanceof RangeRef) {\n                    ref.topLeft.rel = 0;\n                    ref.bottomRight.rel = 0;\n                } else {\n                    break OUT;\n                }\n                a.push(ref);\n                if (stream.eof()) {\n                    break;\n                }\n                if (!stream.is(\"op\", SEPARATORS.ARG)) {\n                    break OUT;\n                }\n                stream.next();\n            }\n            return a.length == 1 ? a[0] : new spreadsheet.UnionRef(a);\n        }\n        if (!noThrow) {\n            throw new Error(\"Cannot parse reference: \" + name);\n        }\n    }\n\n    function parseFormula(sheet, row, col, input) {\n        var refs = [];\n        input = TokenStream(input, { row: row, col: col });\n        var is = input.is;\n\n        return {\n            type: \"exp\",\n            ast: parseExpression(true),\n            refs: refs,\n            sheet: sheet,\n            row: row,\n            col: col\n        };\n\n        function addReference(ref) {\n            ref.index = refs.length;\n            refs.push(ref);\n            return ref;\n        }\n\n        function skip(type, value, allowEOF) {\n            if (is(type, value)) {\n                return input.next();\n            } else {\n                var tok = input.peek();\n                if (tok) {\n                    input.croak(\"Expected \" + type + \" «\" + value + \"» but found \" + tok.type + \" «\" + tok.value + \"»\");\n                } else if (!allowEOF) {\n                    input.croak(\"Expected \" + type + \" «\" + value + \"»\");\n                }\n            }\n        }\n\n        function parseExpression(commas) {\n            return maybeBinary(maybeIntersect(parseAtom()), 0, commas);\n        }\n\n        function parseSymbol(tok) {\n            if (tok.upper == \"TRUE\" || tok.upper == \"FALSE\") {\n                return tok.upper == \"TRUE\" ? TRUE : FALSE;\n            }\n            return addReference(new NameRef(tok.value));\n        }\n\n        function parseFuncall() {\n            var fname = input.next();\n            fname = fname.value;\n            skip(\"punc\", \"(\");\n            var args = [];\n            while (1) {\n                if (is(\"punc\", \")\")) {\n                    break;\n                }\n                if (is(\"op\", SEPARATORS.ARG)) {\n                    args.push({ type: \"null\" });\n                    input.next();\n                    continue;\n                }\n                args.push(parseExpression(false));\n                if (input.eof() || is(\"punc\", \")\")) {\n                    break;\n                }\n                skip(\"op\", SEPARATORS.ARG);\n            }\n            skip(\"punc\", \")\", true);\n            return {\n                type: \"func\",\n                func: fname,\n                args: args\n            };\n        }\n\n        function fixReference(ref) {\n            if (!ref.hasSheet()) {\n                ref.setSheet(sheet);\n            }\n            return addReference(ref);\n        }\n\n        function parseAtom() {\n            var exp;\n            if (is(\"ref\")) {\n                exp = fixReference(input.next());\n            }\n            else if (is(\"func\")) {\n                exp = parseFuncall();\n            }\n            else if (is(\"punc\", \"(\")) {\n                input.next();\n                exp = parseExpression(true);\n                skip(\"punc\", \")\", true);\n            }\n            else if (is(\"punc\", \"{\")) {\n                input.next();\n                exp = parseArray();\n                skip(\"punc\", \"}\", true);\n            }\n            else if (is(\"num\") || is(\"str\") || is(\"error\")) {\n                exp = input.next();\n            }\n            else if (is(\"sym\")) {\n                exp = parseSymbol(input.next());\n            }\n            else if (is(\"op\", \"+\") || is(\"op\", \"-\")) {\n                exp = {\n                    type: \"prefix\",\n                    op: input.next().value,\n                    exp: parseAtom()\n                };\n            }\n            else if (!input.peek()) {\n                input.croak(\"Incomplete expression\");\n            }\n            else if (is(\"punc\", \"[\")) {\n                input.croak(\"External reference not supported\");\n            }\n            else {\n                input.croak(\"Parse error\");\n            }\n            return maybePercent(exp);\n        }\n\n        function parseArray() {\n            var row = [], value = [ row ], first = true;\n            while (!input.eof() && !is(\"punc\", \"}\")) {\n                if (first) {\n                    first = false;\n                } else if (is(null, \";\")) {\n                    value.push(row = []);\n                    input.next();\n                } else {\n                    skip(null, SEPARATORS.COL);\n                }\n                row.push(parseExpression(false));\n            }\n            return {\n                type: \"matrix\",\n                value: value\n            };\n        }\n\n        function maybeIntersect(exp) {\n            if (is(\"punc\", \"(\") || is(\"ref\") || is(\"num\") || is(\"func\")) {\n                return {\n                    type: \"binary\",\n                    op: \" \",\n                    left: exp,\n                    right: parseExpression(false)\n                };\n            } else {\n                return exp;\n            }\n        }\n\n        function maybePercent(exp) {\n            if (is(\"op\", \"%\")) {\n                input.next();\n                return maybePercent({\n                    type: \"postfix\",\n                    op: \"%\",\n                    exp: exp\n                });\n            } else {\n                return exp;\n            }\n        }\n\n        function maybeBinary(left, my_prec, commas) {\n            var tok = is(\"op\");\n            if (tok && (commas || tok.value != SEPARATORS.ARG)) {\n                var his_prec = OPERATORS[tok.value];\n                if (his_prec > my_prec) {\n                    input.next();\n                    var right = maybeBinary(parseAtom(), his_prec, commas);\n                    return maybeBinary({\n                        type: \"binary\",\n                        op: tok.value == \";\" ? \",\" : tok.value, // translate union back to comma\n                        left: left,\n                        right: right\n                    }, my_prec, commas);\n                }\n            }\n            return left;\n        }\n    }\n\n    function parseNameDefinition(name, def) {\n        var nameRef = parseFormula(null, 0, 0, name);\n        if (!(nameRef.ast instanceof NameRef)) {\n            throw new ParseError(\"Invalid name: \" + name);\n        }\n        nameRef = nameRef.ast;\n\n        if (!(def instanceof Ref)) {\n            var defAST = parseFormula(nameRef.sheet, 0, 0, def);\n            if (defAST.ast instanceof Ref) {\n                def = defAST.ast;   // single reference\n            } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {\n                def = defAST.ast.value; // constant\n            } else {\n                def = makeFormula(defAST); // formula\n            }\n        }\n\n        return {\n            name: nameRef,\n            value: def\n        };\n    }\n\n    var makeClosure = (function(cache){\n        return function(code) {\n            var f = cache[code];\n            if (!f) {\n                f = cache[code] = new Function(\"'use strict';return(\" + code + \")\")();\n            }\n            return f;\n        };\n    })(Object.create(null));\n\n    function makePrinter(exp) {\n        return makeClosure(\"function(row, col, mod){return(\" + print(exp.ast, exp, 0) + \")}\");\n        function print(node, parent, prec) {\n            switch (node.type) {\n              case \"num\":\n                return \"(kendo.spreadsheet.calc._separators.DEC == '.' ? \"\n                    +  JSON.stringify(JSON.stringify(node.value)) + \" : \"\n                    +  JSON.stringify(JSON.stringify(node.value))\n                    +  \".replace('.' , kendo.spreadsheet.calc._separators.DEC))\";\n              case \"bool\":\n                return JSON.stringify(node.value);\n              case \"error\":\n                return JSON.stringify(\"#\" + node.value);\n              case \"str\":\n                return JSON.stringify(JSON.stringify(node.value));\n              case \"ref\":\n                return \"this.refs[\" + node.index + \"].print(row, col, mod)\";\n              case \"prefix\":\n                return withParens(function(){\n                    return JSON.stringify(node.op) + \" + \" + print(node.exp, node, OPERATORS[node.op]);\n                });\n              case \"postfix\":\n                return withParens(function(){\n                    return print(node.exp, node, OPERATORS[node.op]) + \" + \" + JSON.stringify(node.op);\n                });\n              case \"binary\":\n                return withParens(function(){\n                    var left = parenthesize(\n                        print(node.left, node, OPERATORS[node.op]),\n                        node.left instanceof NameRef && node.op == \":\"\n                    );\n                    var right = parenthesize(\n                        print(node.right, node, OPERATORS[node.op]),\n                        node.right instanceof NameRef && node.op == \":\"\n                    );\n                    if (/^[,;]/.test(node.op)) {\n                        return left + \" + kendo.spreadsheet.calc._separators.ARG + \" + right;\n                    } else {\n                        return left + \" + \" + JSON.stringify(node.op) + \" + \" + right;\n                    }\n                });\n              case \"func\":\n                return JSON.stringify(node.func + \"(\") + \" + \"\n                    + (node.args.length > 0\n                       ? node.args.map(function(arg){\n                           return print(arg, node, 0);\n                       }).join(\" + kendo.spreadsheet.calc._separators.ARG + ' ' + \")\n                       : \"''\")\n                    + \" + ')'\";\n              case \"matrix\":\n                return \"'{ ' + \" + node.value.map(function(el){\n                    return el.map(function(el){\n                        return print(el, node, 0);\n                    }).join(\" + kendo.spreadsheet.calc._separators.COL + ' ' + \");\n                }).join(\" + '; ' + \") + \"+ ' }'\";\n              case \"null\":\n                return \"''\";\n            }\n            throw new Error(\"Cannot make printer for node \" + node.type);\n\n            function withParens(f) {\n                var op = node.op;\n                var needParens = (OPERATORS[op] < prec\n                                  || (!prec && op == \",\")\n                                  || (parent.type == \"prefix\" && prec == OPERATORS[op] && parent.op == \"-\")\n                                  || (parent.type == \"binary\" && prec == OPERATORS[op] && node === parent.right));\n                return parenthesize(f(), needParens);\n            }\n        }\n        function parenthesize(code, cond) {\n            return cond ? \"'(' + \" + code + \" + ')'\" : code;\n        }\n    }\n\n    function toCPS(ast, k) {\n        var GENSYM = 0;\n        return cps(ast, k);\n\n        function cps(node, k){\n            switch (node.type) {\n              case \"ref\"     : return cpsRef(node, k);\n              case \"num\"     :\n              case \"str\"     :\n              case \"null\"    :\n              case \"error\"   :\n              case \"bool\"    : return cpsAtom(node, k);\n              case \"prefix\"  :\n              case \"postfix\" : return cpsUnary(node, k);\n              case \"binary\"  : return cpsBinary(node, k);\n              case \"func\"    : return cpsFunc(node, k);\n              case \"lambda\"  : return cpsLambda(node, k);\n              case \"matrix\"  : return cpsMatrix(node.value, k, true);\n            }\n            throw new Error(\"Cannot CPS \" + node.type);\n        }\n\n        function cpsRef(node, k) {\n            return node.ref == \"name\" ? cpsNameRef(node, k) : cpsAtom(node, k);\n        }\n\n        function cpsAtom(node, k) {\n            return k(node);\n        }\n\n        function cpsNameRef(node, k) {\n            return {\n                type: \"func\",\n                func: \",getname\",\n                args: [ makeContinuation(k), node ]\n            };\n        }\n\n        function cpsUnary(node, k) {\n            return cps({\n                type: \"func\",\n                func: \"unary\" + node.op,\n                args: [ node.exp ]\n            }, k);\n        }\n\n        function cpsBinary(node, k) {\n            return cps({\n                type: \"func\",\n                func: \"binary\" + node.op,\n                args: [ node.left, node.right ]\n            }, k);\n        }\n\n        function cpsIf(co, th, el, k) {\n            return cps(co, function(co){\n                // compile THEN and ELSE into a lambda which takes a callback to invoke with the\n                // result of the branches, and the IF itself will become a call the internal \"if\"\n                // function.\n                var rest = makeContinuation(k);\n                var thenK = gensym(\"T\");\n                var elseK = gensym(\"E\");\n                return {\n                    type: \"func\",\n                    func: \"if\",\n                    args: [\n                        rest,\n                        co, // condition\n                        { // then\n                            type: \"lambda\",\n                            vars: [ thenK ],\n                            body: cps(th || TRUE, function(th){\n                                return {\n                                    type: \"call\",\n                                    func: { type: \"var\", name: thenK },\n                                    args: [ th ]\n                                };\n                            })\n                        },\n                        { // else\n                            type: \"lambda\",\n                            vars: [ elseK ],\n                            body: cps(el || FALSE, function(el){\n                                return {\n                                    type: \"call\",\n                                    func: { type: \"var\", name: elseK },\n                                    args: [ el ]\n                                };\n                            })\n                        }\n                    ]\n                };\n            });\n        }\n\n        function cpsAnd(args, k) {\n            if (args.length === 0) {\n                return cpsAtom(TRUE, k);\n            }\n            return cps({\n                type: \"func\",\n                func: \"IF\",\n                args: [\n                    // first item\n                    args[0],\n                    // if true, apply AND for the rest\n                    {\n                        type: \"func\",\n                        func: \"AND\",\n                        args: args.slice(1)\n                    },\n                    // otherwise return false\n                    FALSE\n                ]\n            }, k);\n        }\n\n        function cpsOr(args, k) {\n            if (args.length === 0) {\n                return cpsAtom(FALSE, k);\n            }\n            return cps({\n                type: \"func\",\n                func: \"IF\",\n                args: [\n                    // first item\n                    args[0],\n                    // if true, return true\n                    TRUE,\n                    // otherwise apply OR for the rest\n                    {\n                        type: \"func\",\n                        func: \"OR\",\n                        args: args.slice(1)\n                    }\n                ]\n            }, k);\n        }\n\n        function cpsFunc(node, k) {\n            switch (node.func.toLowerCase()) {\n              case \"if\":\n                return cpsIf(node.args[0], node.args[1], node.args[2], k);\n              case \"and\":\n                return cpsAnd(node.args, k);\n              case \"or\":\n                return cpsOr(node.args, k);\n              case \"true\":\n                return k(TRUE);\n              case \"false\":\n                return k(FALSE);\n            }\n            // actual function\n            return (function loop(args, i){\n                if (i == node.args.length) {\n                    return {\n                        type : \"func\",\n                        func : node.func,\n                        args : args\n                    };\n                }\n                else {\n                    return cps(node.args[i], function(value){\n                        return loop(args.concat([ value ]), i + 1);\n                    });\n                }\n            })([ makeContinuation(k) ], 0);\n        }\n\n        function cpsLambda(node, k) {\n            var cont = gensym(\"K\");\n            var body = cps(node.body, function(body){\n                return { type: \"call\",\n                         func: { type: \"var\", value: cont },\n                         args: [ body ] };\n            });\n            return k({ type: \"lambda\",\n                       vars: [ cont ].concat(node.vars),\n                       body: body });\n        }\n\n        function cpsMatrix(elements, k, isMatrix) {\n            var a = [];\n            return (function loop(i){\n                if (i == elements.length) {\n                    return k({\n                        type: \"matrix\",\n                        value: a\n                    });\n                } else {\n                    return (isMatrix ? cpsMatrix : cps)(elements[i], function(val){\n                        a[i] = val;\n                        return loop(i + 1);\n                    });\n                }\n            })(0);\n        }\n\n        function makeContinuation(k) {\n            var cont = gensym(\"R\");\n            return {\n                type : \"lambda\",\n                vars : [ cont ],\n                body : k({ type: \"var\", name: cont })\n            };\n        }\n\n        function gensym(name) {\n            if (!name) {\n                name = \"\";\n            }\n            name = \"_\" + name;\n            return name + (++GENSYM);\n        }\n    }\n\n    var FORMULA_CACHE = Object.create(null);\n\n    function makeFormula(exp) {\n        var printer = makePrinter(exp);\n        var hash = printer.call(exp); // needs .refs\n        var formula = FORMULA_CACHE[hash];\n        if (formula) {\n            // we need to clone because formulas cache the result; even if the formula is the same,\n            // its value will depend on its location, hence we need different objects.  Still, using\n            // this cache is a good idea because we'll reuse the same refs array, handler and\n            // printer instead of allocating new ones (and we skip compiling it).\n            return formula.clone(exp.sheet, exp.row, exp.col);\n        }\n        var code = js(toCPS(exp.ast, function(ret){\n            return {\n                type: \"return\",\n                value: ret\n            };\n        }));\n\n        code = [\n            \"function(){\",\n            \"var context = this, refs = context.formula.absrefs\",\n            code,\n            \"}\"\n        ].join(\";\\n\");\n\n        formula = new runtime.Formula(exp.refs, makeClosure(code), printer, exp.sheet, exp.row, exp.col);\n        FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);\n        return formula;\n\n        function js(node){\n            var type = node.type;\n            if (type == \"num\") {\n                return node.value + \"\";\n            }\n            else if (type == \"str\") {\n                return JSON.stringify(node.value);\n            }\n            else if (type == \"error\") {\n                return \"context.error(\" + JSON.stringify(node.value) + \")\";\n            }\n            else if (type == \"return\") {\n                return \"context.resolve(\" + js(node.value) + \")\";\n            }\n            else if (type == \"func\") {\n                return \"context.func(\" + JSON.stringify(node.func) + \", \"\n                    + js(node.args[0]) + \", \" // the callback\n                    + jsArray(node.args.slice(1)) // the arguments\n                    + \")\";\n            }\n            else if (type == \"call\") {\n                return js(node.func) + \"(\" + node.args.map(js).join(\", \") + \")\";\n            }\n            else if (type == \"ref\") {\n                return \"refs[\" + node.index + \"]\";\n            }\n            else if (type == \"bool\") {\n                return \"\" + node.value;\n            }\n            else if (type == \"if\") {\n                return \"(context.bool(\" + js(node.co) + \") ? \" + js(node.th) + \" : \" + js(node.el) + \")\";\n            }\n            else if (type == \"lambda\") {\n                return \"(function(\"\n                    + node.vars.join(\", \")\n                    + \"){ return(\" + js(node.body) + \") })\";\n            }\n            else if (type == \"var\") {\n                return node.name;\n            }\n            else if (type == \"matrix\") {\n                return jsArray(node.value);\n            }\n            else if (type == \"null\") {\n                return \"null\";\n            }\n            else {\n                throw new Error(\"Cannot compile expression \" + type);\n            }\n        }\n\n        function jsArray(a) {\n            return \"[ \" + a.map(js).join(\", \") + \" ]\";\n        }\n    }\n\n    function identity(x) {\n        return x;\n    }\n\n    function TokenStream(input, options) {\n        input = RawTokenStream(InputStream(input), options);\n        var ahead = input.ahead;\n        var skip = input.skip;\n        var token = null;\n        var fixCell = options.row != null && options.col != null\n            ? function(cell) {\n                if (cell.rel & 1) {\n                    cell.col -= options.col;\n                }\n                if (cell.rel & 2) {\n                    cell.row -= options.row;\n                }\n                return cell;\n            }\n            : identity;\n\n        var addPos = options.forEditor\n            ? function(thing, startToken, endToken) {\n                thing.begin = startToken.begin;\n                thing.end = endToken.end;\n                return thing;\n            }\n            : identity;\n\n        return {\n            peek  : peek,\n            next  : next,\n            croak : input.croak,\n            eof   : input.eof,\n            is    : is\n        };\n\n        function is(type, value) {\n            var tok = peek();\n            return tok != null\n                && (type == null || tok.type === type)\n                && (value == null || tok.value === value)\n                ? tok : null;\n        }\n\n        function peek() {\n            if (token == null) {\n                token = readNext();\n            }\n            return token;\n        }\n\n        function next() {\n            if (token != null) {\n                var tmp = token;\n                token = null;\n                return tmp;\n            }\n            return readNext();\n        }\n\n        function readNext() {\n            var ret;\n            var t = input.peek();\n            if (t) {\n                if (t.type == \"sym\" || t.type == \"rc\" || t.type == \"num\") {\n                    ret =  ahead(8, refRange3D)\n                        || ahead(6, refCell3D)\n                        || ahead(6, refSheetRange)\n                        || ahead(4, refSheetCell)\n                        || ahead(4, refRange)\n                        || ahead(2, refCell)\n                        || ahead(2, funcall);\n                }\n                if (!ret) {\n                    ret = input.next();\n                }\n            }\n            return ret;\n        }\n\n        function toCell(tok, isFirst) {\n            if (tok.type == \"rc\") {\n                // RC notation is read properly without knowing where\n                // we are, so no need to fixCell on this one.\n                // However, if only absolute refs were asked for (from\n                // i.e. parseReference) I feel it's alright to yell\n                // about it here.\n                if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {\n                    input.croak(\"Cannot read relative cell in RC notation\");\n                }\n                return new CellRef(tok.row, tok.col, tok.rel);\n            }\n            if (tok.type == \"num\") {\n                if (tok.value <= 1048577) {\n                    // whole row\n                    return fixCell(new CellRef(\n                        getrow(tok.value),\n                        isFirst ? -Infinity : +Infinity,\n                        2\n                    ));\n                } else {\n                    return null;\n                }\n            }\n            // otherwise it's \"sym\".  The OOXML spec (SpreadsheetML\n            // 18.2.5) defines the maximum value to be interpreted as\n            // a cell reference to be XFD1048576.\n            var name = tok.value;\n            var m = /^(\\$)?([a-z]+)(\\$)?(\\d+)$/i.exec(name);\n            if (m) {\n                var row = getrow(m[4]), col = getcol(m[2]);\n                if (row <= 1048576 && col <= 16383) {\n                    return fixCell(new CellRef(\n                        getrow(m[4]),\n                        getcol(m[2]),\n                        (m[1] ? 0 : 1) | (m[3] ? 0 : 2)\n                    ));\n                } else {\n                    return null;\n                }\n            }\n            var abs = name.charAt(0) == \"$\";\n            if (abs) {\n                name = name.substr(1);\n            }\n            if (/^\\d+$/.test(name)) {\n                var row = getrow(name);\n                if (row <= 1048576) {\n                    return fixCell(new CellRef(\n                        getrow(name),\n                        isFirst ? -Infinity : +Infinity,\n                        (abs ? 0 : 2)\n                    ));\n                }\n            } else {\n                var col = getcol(name);\n                if (col <= 16383) {\n                    return fixCell(new CellRef(\n                        isFirst ? -Infinity : +Infinity,\n                        getcol(name),\n                        (abs ? 0 : 1)\n                    ));\n                }\n            }\n        }\n\n        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)\n        function refRange3D(a, b, c, d, e, f, g, h) {\n            if (a.type == \"sym\" &&\n                b.type == \"op\" && b.value == \":\" &&\n                c.type == \"sym\" &&\n                d.type == \"punc\" && d.value == \"!\" &&\n                (e.type == \"sym\" || e.type == \"rc\" || (e.type == \"num\" && e.value == e.value|0)) &&\n                f.type == \"op\" && f.value == \":\" &&\n                (g.type == \"sym\" || g.type == \"rc\" || (g.type == \"num\" && g.value == g.value|0)) &&\n                g.type == e.type &&\n                !(h.type == \"punc\" && h.value == \"(\" && !g.space))\n            {\n                var tl = toCell(e, true), br = toCell(g, false);\n                if (tl && br) {\n                    // skip them except the last one, we only wanted to\n                    // ensure it's not paren.\n                    skip(7);\n                    return addPos(new RangeRef(\n                        tl.setSheet(a.value, true),\n                        br.setSheet(c.value, true)\n                    ).setSheet(a.value, true), a, g);\n                }\n            }\n        }\n\n        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)\n        function refCell3D(a, b, c, d, e, f) {\n            if (a.type == \"sym\" &&\n                b.type == \"op\" && b.value == \":\" &&\n                c.type == \"sym\" &&\n                d.type == \"punc\" && d.value == \"!\" &&\n                (e.type == \"sym\" || e.type == \"rc\" || (e.type == \"num\" && e.value == e.value|0)) &&\n                !(f.type == \"punc\" && f.value == \"(\" && !e.space))\n            {\n                var tl = toCell(e);\n                if (tl) {\n                    skip(5);\n                    var br = tl.clone();\n                    return addPos(new RangeRef(\n                        tl.setSheet(a.value, true),\n                        br.setSheet(c.value, true)\n                    ).setSheet(a.value, true), a, e);\n                }\n            }\n        }\n\n        // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)\n        function refSheetRange(a, b, c, d, e, f) {\n            if (a.type == \"sym\" &&\n                b.type == \"punc\" && b.value == \"!\" &&\n                (c.type == \"sym\" || c.type == \"rc\" || (c.type == \"num\" && c.value == c.value|0)) &&\n                d.type == \"op\" && d.value == \":\" &&\n                (e.type == \"sym\" || e.type == \"rc\" || (e.type == \"num\" && e.value == e.value|0)) &&\n                !(f.type == \"punc\" && f.value == \"(\" && !e.space))\n            {\n                var tl = toCell(c, true), br = toCell(e, false);\n                if (tl && br) {\n                    skip(5);\n                    return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);\n                }\n            }\n        }\n\n        // Sheet1(a) !(b) A1(c) not followed by paren (d)\n        function refSheetCell(a, b, c, d) {\n            if (a.type == \"sym\" &&\n                b.type == \"punc\" && b.value == \"!\" &&\n                (c.type == \"sym\" || c.type == \"rc\" || (c.type == \"num\" && c.value == c.value|0)) &&\n                !(d.type == \"punc\" && d.value == \"(\" && !c.space))\n            {\n                skip(3);\n                var x = toCell(c);\n                if (!x || !isFinite(x.row)) {\n                    x = new NameRef(c.value);\n                }\n                return addPos(x.setSheet(a.value, true), a, c);\n            }\n        }\n\n        // A1(a) :(b) C3(c) not followed by paren (d)\n        function refRange(a, b, c, d) {\n            if ((a.type == \"sym\" || a.type == \"rc\" || (a.type == \"num\" && a.value == a.value|0)) &&\n                (b.type == \"op\" && b.value == \":\") &&\n                (c.type == \"sym\" || c.type == \"rc\" || (c.type == \"num\" && c.value == c.value|0)) &&\n                !(d.type == \"punc\" && d.value == \"(\" && !c.space))\n            {\n                var tl = toCell(a, true), br = toCell(c, false);\n                if (tl && br) {\n                    skip(3);\n                    return addPos(new RangeRef(tl, br), a, c);\n                }\n            }\n        }\n\n        // A1(a) not followed by paren (b)\n        function refCell(a, b) {\n            if ((a.type == \"sym\" || a.type == \"rc\") && !(b.type == \"punc\" && b.value == \"(\" && !a.space)) {\n                var x = toCell(a);\n                if (x && isFinite(x.row) && isFinite(x.col)) {\n                    skip(1);\n                    return addPos(x, a, a);\n                }\n            }\n        }\n\n        function funcall(a, b) {\n            if (a.type == \"sym\" && b.type == \"punc\" && b.value == \"(\" && !a.space) {\n                a.type = \"func\";\n                skip(1);\n                return a;       // already has position\n            }\n        }\n    }\n\n    function isWhitespace(ch) {\n        return \" \\t\\r\\n\\xa0\\u200b\".indexOf(ch) >= 0;\n    }\n\n    var EOF = { type: \"eof\" };\n\n    function RawTokenStream(input, options) {\n        var tokens = [], index = 0;\n        var readWhile = input.readWhile;\n\n        return {\n            next  : next,\n            peek  : peek,\n            eof   : eof,\n            croak : input.croak,\n            ahead : ahead,\n            skip  : skip\n        };\n\n        function isDigit(ch) {\n            return (/[0-9]/i.test(ch));\n        }\n\n        function isIdStart(ch) {\n            return (/[a-z$_]/i.test(ch) || util.isUnicodeLetter(ch));\n        }\n\n        function isId(ch) {\n            return isIdStart(ch) || isDigit(ch) || ch == \".\";\n        }\n\n        function isOpChar(ch) {\n            return ch in OPERATORS;\n        }\n\n        function isPunc(ch) {\n            return \"\\\\!;(){}[]\".indexOf(ch) >= 0;\n        }\n\n        function readNumber() {\n            // XXX: TODO: exponential notation\n            var has_dot = false;\n            var number = readWhile(function(ch){\n                if (ch == SEPARATORS.DEC) {\n                    if (has_dot) {\n                        return false;\n                    }\n                    has_dot = true;\n                    return true;\n                }\n                return isDigit(ch);\n            });\n            if (number == SEPARATORS.DEC) {\n                return { type: \"punc\", value: SEPARATORS.DEC };\n            } else {\n                return { type: \"num\", value: parseFloat(number.replace(SEPARATORS.DEC, \".\")) };\n            }\n        }\n\n        function symbol(id, quote) {\n            return {\n                type  : \"sym\",\n                value : id,\n                upper : id.toUpperCase(),\n                space : isWhitespace(input.peek()),\n                quote : quote\n            };\n        }\n\n        function getRC(a, b, c) {\n            if (!a && !b && !c) {\n                return null;\n            }\n            if ((!a && !c) || (a && c)) {\n                var num = b ? parseInt(b, 10) : 0;\n                return a ? num : num - 1;\n            }\n        }\n\n        function readSymbol() {\n            var m = input.lookingAt(/^R(\\[)?(-?[0-9]+)?(\\])?C(\\[)?(-?[0-9]+)?(\\])?/i);\n            if (m) {\n                var row = getRC(m[1], m[2], m[3]);\n                var col = getRC(m[4], m[5], m[6]);\n                if (row != null && col != null) {\n                    input.skip(m);\n                    return {\n                        type: \"rc\",\n                        row: row,\n                        col: col,\n                        rel: ((m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0) // col\n                              |\n                              (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row\n                             )\n                    };\n                }\n            }\n            return symbol(readWhile(isId));\n        }\n\n        function readString() {\n            input.next();\n            return { type: \"str\", value: input.readEscaped('\"') };\n        }\n\n        function readSheetName() {\n            input.next();\n            return symbol(input.readEscaped(\"'\"), true);\n        }\n\n        function readOperator() {\n            return {\n                type  : \"op\",\n                value : readWhile(function(ch, op){\n                    return (op + ch) in OPERATORS;\n                })\n            };\n        }\n\n        function readPunc() {\n            return {\n                type  : \"punc\",\n                value : input.next()\n            };\n        }\n\n        function readNext() {\n            if (input.eof()) {\n                return null;\n            }\n            var ch = input.peek(), m;\n            if (ch == '\"') {\n                return readString();\n            }\n            if (ch == \"'\") {\n                return readSheetName();\n            }\n            if (isDigit(ch) || ch == SEPARATORS.DEC) {\n                return readNumber();\n            }\n            if (isIdStart(ch)) {\n                return readSymbol();\n            }\n            if (isOpChar(ch)) {\n                return readOperator();\n            }\n            if (isPunc(ch)) {\n                return readPunc();\n            }\n            if ((m = input.lookingAt(/^#([a-z\\/]+)[?!]?/i))) {\n                input.skip(m);\n                return { type: \"error\", value: m[1] };\n            }\n            if (!options.forEditor) {\n                input.croak(\"Can't handle character with code: \" + ch.charCodeAt(0));\n            }\n            return { type: \"error\", value: input.next() };\n        }\n\n        function peek() {\n            while (tokens.length <= index) {\n                readWhile(isWhitespace);\n                var begin = input.pos();\n                var tok = readNext();\n                if (options.forEditor && tok) {\n                    tok.begin = begin;\n                    tok.end = input.pos();\n                }\n                tokens.push(tok);\n            }\n            return tokens[index];\n        }\n\n        function next() {\n            var tok = peek();\n            if (tok) {\n                index++;\n            }\n            return tok;\n        }\n\n        function ahead(n, f) {\n            var pos = index, a = [];\n            while (n-- > 0) {\n                a.push(next() || EOF);\n            }\n            index = pos;\n            return f.apply(a, a);\n        }\n\n        function skip(n) {\n            index += n;\n        }\n\n        function eof() {\n            return peek() == null;\n        }\n    }\n\n    function InputStream(input) {\n        var pos = 0, line = 1, col = 0;\n        return {\n            next        : next,\n            peek        : peek,\n            eof         : eof,\n            croak       : croak,\n            readWhile   : readWhile,\n            readEscaped : readEscaped,\n            lookingAt   : lookingAt,\n            skip        : skip,\n            forward     : forward,\n            pos         : location\n        };\n        function location() {\n            return pos;\n        }\n        function next() {\n            var ch = input.charAt(pos++);\n            if (ch == \"\\n\") {\n                line++;\n                col = 0;\n            } else {\n                col++;\n            }\n            return ch;\n        }\n        function peek() {\n            return input.charAt(pos);\n        }\n        function eof() {\n            return peek() === \"\";\n        }\n        function croak(msg) {\n            throw new ParseError(msg + \" (input: \" + input + \")\", pos);\n        }\n        function skip(ch) {\n            if (typeof ch == \"string\") {\n                if (input.substr(pos, ch.length) != ch) {\n                    croak(\"Expected \" + ch);\n                }\n                forward(ch.length);\n            } else if (ch instanceof RegExp) {\n                var m = ch.exec(input.substr(pos));\n                if (m) {\n                    forward(m[0].length);\n                    return m;\n                }\n            } else {\n                // assuming RegExp match data\n                forward(ch[0].length);\n            }\n        }\n        function forward(n) {\n            while (n-- > 0) {\n                next();\n            }\n        }\n        function readEscaped(end) {\n            var escaped = false, str = \"\";\n            while (!eof()) {\n                var ch = next();\n                if (escaped) {\n                    str += ch;\n                    escaped = false;\n                } else if (ch == \"\\\\\") {\n                    escaped = true;\n                } else if (ch == end) {\n                    break;\n                } else {\n                    str += ch;\n                }\n            }\n            return str;\n        }\n        function readWhile(predicate) {\n            var str = \"\";\n            while (!eof() && predicate(peek(), str)) {\n                str += next();\n            }\n            return str;\n        }\n        function lookingAt(rx) {\n            return rx.exec(input.substr(pos));\n        }\n    }\n\n    //// exports\n\n    var FORMAT_PARSERS = [];\n\n    var registerFormatParser = exports.registerFormatParser = function(p) {\n        FORMAT_PARSERS.push(p);\n    };\n\n    exports.parse = function(sheet, row, col, input, format) {\n        if (input instanceof Date) {\n            return { type: \"date\", value: runtime.dateToSerial(input) };\n        }\n        if (typeof input == \"number\") {\n            return { type: \"number\", value: input };\n        }\n        if (typeof input == \"boolean\") {\n            return { type: \"boolean\", value: input };\n        }\n        input += \"\";\n        if (/^'/.test(input)) {\n            return {\n                type: \"string\",\n                value: input.substr(1)\n            };\n        }\n        // trivial (integer) percent values; more complex formats are handled below via\n        // registerFormatParser; this case could be dropped completely.\n        if (/^-?[0-9]+%$/.test(input)) {\n            var str = input.substr(0, input.length - 1);\n            var num = parseFloat(str);\n            if (!isNaN(num) && num == str) {\n                return {\n                    type: \"percent\",\n                    value: num / 100\n                };\n            }\n        }\n        if (/^=/.test(input)) {\n            input = input.substr(1);\n            if (/\\S/.test(input)) {\n                return parseFormula(sheet, row, col, input);\n            } else {\n                return {\n                    type: \"string\",\n                    value: \"=\" + input\n                };\n            }\n        }\n        for (var i = 0; i < FORMAT_PARSERS.length; ++i) {\n            var result = FORMAT_PARSERS[i](input);\n            if (result) {\n                return result;\n            }\n        }\n        if (input.toLowerCase() == \"true\") {\n            return { type: \"boolean\", value: true };\n        }\n        if (input.toLowerCase() == \"false\") {\n            return { type: \"boolean\", value: false };\n        }\n        var date = runtime.parseDate(input, format);\n        if (date) {\n            return { type: \"date\", value: runtime.dateToSerial(date) };\n        }\n        var num = parseFloat(input);\n        if (!isNaN(num) && input.length > 0 && num == input) {\n            format = null;\n            if (num != Math.floor(num)) {\n                format = \"0.\" + String(num).split(\".\")[1].replace(/\\d/g, \"0\");\n            }\n            return {\n                type: \"number\",\n                value: num,\n                format: format\n            };\n        }\n        return {\n            type: \"string\",\n            value: input\n        };\n    };\n\n    function tokenize(input, row, col) {\n        var tokens = [];\n        input = TokenStream(input, { forEditor: true, row: row, col: col });\n        while (!input.eof()) {\n            tokens.push(next());\n        }\n        var tok = tokens[0];\n        if (tok.type == \"op\" && tok.value == \"=\") {\n            tok.type = \"startexp\";\n        }\n        return tokens;\n\n        function next() {\n            var tok = input.next();\n            if (tok.type == \"sym\") {\n                if (tok.upper == \"TRUE\") {\n                    tok.type = \"bool\";\n                    tok.value = true;\n                } else if (tok.upper == \"FALSE\") {\n                    tok.type = \"bool\";\n                    tok.value = false;\n                }\n            } else if (tok.type == \"ref\") {\n                tok = {\n                    type  : \"ref\",\n                    ref   : (row != null && col != null ? tok.absolute(row, col) : tok),\n                    begin : tok.begin,\n                    end   : tok.end\n                };\n            }\n            return tok;\n        }\n    }\n\n    // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of\n    // references.  This helper is called from excel-reader.js to parse them.\n    function parseSqref(input, row, col) {\n        row = row || 0;\n        col = col || 0;\n        input = TokenStream(input, { row: row, col: col });\n        var refs = [];\n        while (!input.eof()) {\n            var ref = input.next();\n            if (ref.type != \"ref\") {\n                throw new ParseError(\"Expecting a reference but got: \" + JSON.stringify(ref));\n            }\n            refs.push(ref.absolute(row, col));\n        }\n        return refs;\n    }\n\n    exports.parseNameDefinition = parseNameDefinition;\n    exports.parseFormula = parseFormula;\n    exports.parseReference = parseReference;\n    exports.compile = makeFormula;\n    exports.parseSqref = parseSqref;\n\n    exports.InputStream = InputStream;\n    exports.ParseError = ParseError;\n    exports.tokenize = tokenize;\n\n    /* -----[ a few special formats ]----- */\n\n    // various time formats\n    registerFormatParser(function(input){\n        var m, date = 0, format = \"\";\n        // have date part?\n        if ((m = /^(\\d+)([-/.])(\\d+)\\2(\\d{2}(?:\\d{2})?)(\\s*)/.exec(input))) {\n            var mo = parseInt(m[1], 10);\n            var sep = m[2];\n            var da = parseInt(m[3], 10);\n            var yr = parseInt(m[4], 10);\n            if (yr < 30) {\n                yr += 2000;\n            } else if (yr < 100) {\n                yr += 1900;\n            }\n            var monthFirst = true;\n            if (mo > 12) {\n                var tmp = mo;\n                mo = da;\n                da = tmp;\n                monthFirst = false;\n            }\n            if (!runtime.validDate(yr, mo, da)) {\n                return null;\n            }\n            date = runtime.packDate(yr, mo - 1, da);\n            if (date < 0) { date--; }\n            if (monthFirst) {\n                format = [\"mm\", \"dd\", \"yyyy\"].join(sep);\n            } else {\n                format = [\"dd\", \"mm\", \"yyyy\"].join(sep);\n            }\n            format += m[5];\n            input = input.substr(m[0].length); // skip the date\n        }\n        // hh:mm\n        if ((m = /^(\\d+):(\\d+)$/.exec(input))) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            return {\n                type   : \"date\",\n                format : format + \"hh:mm\",\n                value  : date + runtime.packTime(hh, mm, 0, 0)\n            };\n        }\n        // mm:ss.ms\n        if ((m = /^(\\d+):(\\d+)(\\.\\d+)$/.exec(input))) {\n            var mm = parseInt(m[1], 10);\n            var ss = parseInt(m[2], 10);\n            var ms = parseFloat(m[3]) * 1000;\n            return {\n                type   : \"date\",\n                format : format + \"mm:ss.00\",\n                value  : date + runtime.packTime(0, mm, ss, ms)\n            };\n        }\n        // hh:mm:ss\n        if ((m = /^(\\d+):(\\d+):(\\d+)$/.exec(input))) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            var ss = parseInt(m[3], 10);\n            return {\n                type   : \"date\",\n                format : format + \"hh:mm:ss\",\n                value  : date + runtime.packTime(hh, mm, ss, 0)\n            };\n        }\n        // hh:mm:ss.ms\n        if ((m = /^(\\d+):(\\d+):(\\d+)(\\.\\d+)$/.exec(input))) {\n            var hh = parseInt(m[1], 10);\n            var mm = parseInt(m[2], 10);\n            var ss = parseInt(m[3], 10);\n            var ms = parseFloat(m[4]) * 1000;\n            return {\n                type   : \"date\",\n                format : format + \"hh:mm:ss.00\",\n                value  : date + runtime.packTime(hh, mm, ss, ms)\n            };\n        }\n    });\n\n    // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,\n    // `$1234`, `123,456.78 $` etc.  I apologize for this code.\n    registerFormatParser(function(input){\n        var m, n;\n        var culture = kendo.culture();\n        var comma = culture.numberFormat[\",\"];\n        var dot = culture.numberFormat[\".\"];\n        var currency = culture.numberFormat.currency.symbol;\n        var rxnum = getNumberRegexp(comma, dot);\n        var rxcur = new RegExp(\"^\\\\s*\\\\\" + currency + \"\\\\s*\");\n        var sign = 1;\n        var format = \"\";\n        var suffix = \"\";\n        var has_currency = false;\n        var has_percent = false;\n\n        input = InputStream(input.replace(/^\\s+|\\s+$/g, \"\"));\n\n        // has minus before currency?\n        if (input.skip(/^-\\s*/)) {\n            sign = -1;\n        }\n\n        // has currency before number?\n        if ((m = input.skip(rxcur))) {\n            has_currency = true;\n            format += '\"' + m[0] + '\"';\n        }\n\n        // has minus after currency?\n        if (input.skip(/^-\\s*/)) {\n            if (sign < 0) {\n                return null;    // not a number\n            }\n            sign = -1;\n        }\n\n        // read the number itself\n        if (!(n = input.skip(rxnum))) {\n            return null;        // not a number\n        }\n        format += \"0\";\n\n        // has currency after number?\n        if ((m = input.skip(rxcur))) {\n            if (has_currency) {\n                return null;    // either before or after, not both.\n            }\n            has_currency = true;\n            suffix = '\"' + m[0] + '\"';\n        }\n\n        // has percent after number?\n        if (!has_currency && (m = input.skip(/^\\s*%\\s*/))) {\n            has_percent = true;\n            suffix = m[0];      // no quotes this time, % is special in format\n        }\n\n        if (!input.eof()) {\n            return null;        // should anything else follow, not a number\n        }\n\n        if (n[2] || has_currency) {\n            format = format.replace(\"0\", \"#\");\n            format += \",0\";\n        }\n        if (n[3]) {\n            format += \".\" + repeat(\"0\", n[3].length - 1);\n        }\n        var value = n[0]\n            .replace(new RegExp(\"\\\\\" + comma, \"g\"), \"\")\n            .replace(new RegExp(\"\\\\\" + dot, \"g\"), \".\");\n\n        value = parseFloat(value);\n        if (has_percent) {\n            value /= 100;\n        }\n\n        format += suffix;\n        if (has_currency) {\n            format += ';-' + format;\n        }\n\n        return {\n            type: \"number\",\n            currency: has_currency,\n            format: format,\n            value: sign * value\n        };\n    });\n\n    registerFormatParser(function(input){\n        var m;\n        if ((m = /^([0-9]*)\\.([0-9]+)(\\s*%)$/.exec(input))) {\n            return {\n                type: \"number\",\n                value: parseFloat(input) / 100,\n                format: \"0.\" + repeat(\"0\", m[2].length) + m[3]\n            };\n        }\n    });\n\n    var NUMBER_FORMAT_RX = {};\n    function getNumberRegexp(comma, dot) {\n        var id = comma + dot;\n        var rx = NUMBER_FORMAT_RX[id];\n        if (!rx) {\n            rx = \"^(\\\\d+(COM\\\\d{3})*(DOT\\\\d+)?)\";\n            rx = rx.replace(/DOT/g, \"\\\\\" + dot).replace(/COM/g, \"\\\\\" + comma);\n            rx = new RegExp(rx);\n            NUMBER_FORMAT_RX[id] = rx;\n        }\n        return rx;\n    }\n\n    function repeat(str, len) {\n        var out = \"\";\n        while (len-- > 0) {\n            out += str;\n        }\n        return out;\n    }\n\n}, __webpack_require__.amdD);\n\n\n/***/ }),\n\n/***/ 22360:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"./runtime\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/amd define */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.amdD = function () {\n/******/ \t\t\tthrow new Error('define cannot be used indirect');\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module used 'module' so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(30616);\n/******/ \tmodule.exports = __webpack_exports__;\n/******/ \t\n/******/ })()\n;"],"mappings":"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"},"metadata":{},"sourceType":"script"}