{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\n    87613:\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n      /***********************************************************************\n      * WARNING: this file is auto-generated.  If you change it directly,\n      * your modifications will eventually be lost.  The source code is in\n      * `kendo-charts` repository, you should make your changes there and\n      * run `src-modules/sync.sh` in this repository.\n      */\n\n\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(33877), __webpack_require__(13298), __webpack_require__(79174), __webpack_require__(32549)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        (function ($) {\n          /* eslint-disable space-before-blocks, space-before-function-paren */\n          window.kendo.dataviz = window.kendo.dataviz || {};\n          var dataviz = kendo.dataviz;\n          var getSpacing = dataviz.getSpacing;\n          var defined = dataviz.defined;\n          var constants = dataviz.constants;\n          var BLACK = constants.BLACK;\n          var COORD_PRECISION = constants.COORD_PRECISION;\n          var services = dataviz.services;\n          var deepExtend = dataviz.deepExtend;\n          var isArray = dataviz.isArray;\n          var setDefaultOptions = dataviz.setDefaultOptions;\n          var NumericAxis = dataviz.NumericAxis;\n          var limitValue = dataviz.limitValue;\n          var Box = dataviz.Box;\n          var interpolateValue = dataviz.interpolateValue;\n          var round = dataviz.round;\n          var drawing = kendo.drawing;\n          var DrawingGroup = drawing.Group;\n          var DrawingPath = drawing.Path;\n          var Animation = drawing.Animation;\n          var AnimationFactory = drawing.AnimationFactory;\n          var geometry = kendo.geometry;\n          var Rect = geometry.Rect;\n          var GeometryPoint = geometry.Point;\n          var transform = geometry.transform;\n          var ANGULAR_SPEED = 150;\n          var LINEAR_SPEED = 250;\n          var ARROW = \"arrow\";\n          var ARROW_POINTER = \"arrowPointer\";\n          var BAR_POINTER = \"barPointer\";\n          var DEFAULT_HEIGHT = 200;\n          var DEFAULT_LINE_WIDTH = 0.5;\n          var DEFAULT_WIDTH = 200;\n          var DEGREE = Math.PI / 180;\n          var INSIDE = \"inside\";\n          var LINEAR = \"linear\";\n          var OUTSIDE = \"outside\";\n          var RADIAL_POINTER = \"radialPointer\";\n          var RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\n          function pad(bbox, value) {\n            var origin = bbox.getOrigin();\n            var size = bbox.getSize();\n            var spacing = getSpacing(value);\n            bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);\n            bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);\n            return bbox;\n          }\n\n          var Group = DrawingGroup;\n          var Path$1 = DrawingPath;\n          var Text = drawing.Text;\n\n          function buildLabelElement(label, options) {\n            var labelBox = label.box;\n            var textBox = label.children[0].box;\n            var border = options.border || {};\n            var background = options.background || \"\";\n            var wrapper = Path$1.fromRect(new Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {\n              stroke: {}\n            });\n            var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n              font: options.font,\n              fill: {\n                color: options.color\n              }\n            });\n            var styleGeometry = pad(text.bbox().clone(), options.padding);\n            var styleBox = Path$1.fromRect(styleGeometry, {\n              stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                opacity: border.opacity,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n              },\n              fill: {\n                color: background\n              }\n            });\n            var elements = new Group();\n            elements.append(wrapper);\n            elements.append(styleBox);\n            elements.append(text);\n            return elements;\n          }\n\n          function getRange(range, min, max) {\n            var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n            var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n            range.from = Math.max(Math.min(to, from), min);\n            range.to = Math.min(Math.max(to, from), max);\n            return range;\n          }\n\n          function unpad(bbox, value) {\n            var spacing = getSpacing(value);\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n            return pad(bbox, spacing);\n          }\n\n          var DEFAULT_MARGIN = 5;\n          var Path = DrawingPath;\n          var Surface = drawing.Surface;\n          var Gauge = dataviz.Class.extend({\n            init: function (element, userOptions, theme, context) {\n              if (context === void 0) {\n                context = {};\n              }\n\n              this.element = element;\n              this.theme = theme;\n              this.contextService = new services.ChartService(this, context);\n              this._originalOptions = deepExtend({}, this.options, userOptions);\n              this.options = deepExtend({}, this._originalOptions);\n\n              this._initTheme(theme);\n\n              this.redraw();\n            },\n            destroy: function () {\n              if (this.surface) {\n                this.surface.destroy();\n                this.surface = null;\n              }\n\n              delete this.element;\n              delete this.surfaceElement;\n            },\n            value: function (pointerValue) {\n              var pointer = this.pointers[0];\n\n              if (arguments.length === 0) {\n                return pointer.value();\n              }\n\n              pointer.value(pointerValue);\n\n              this._setValueOptions(pointerValue);\n            },\n            _draw: function () {\n              var surface = this.surface;\n              surface.clear();\n              surface.draw(this._visuals);\n            },\n            exportVisual: function () {\n              return this._visuals;\n            },\n            allValues: function (values) {\n              var pointers = this.pointers;\n              var allValues = [];\n\n              if (arguments.length === 0) {\n                for (var i = 0; i < pointers.length; i++) {\n                  allValues.push(pointers[i].value());\n                }\n\n                return allValues;\n              }\n\n              if (isArray(values)) {\n                for (var i$1 = 0; i$1 < values.length; i$1++) {\n                  if (dataviz.isNumber(values[i$1])) {\n                    pointers[i$1].value(values[i$1]);\n                  }\n                }\n              }\n\n              this._setValueOptions(values);\n            },\n            _setValueOptions: function (values) {\n              var pointers = [].concat(this.options.pointer);\n              var arrayValues = [].concat(values);\n\n              for (var i = 0; i < arrayValues.length; i++) {\n                pointers[i].value = arrayValues[i];\n              }\n            },\n            resize: function () {\n              this.noTransitionsRedraw();\n            },\n            noTransitionsRedraw: function () {\n              var transitions = this.options.transitions;\n\n              this._toggleTransitions(false);\n\n              this.redraw();\n\n              this._toggleTransitions(transitions);\n            },\n            redraw: function () {\n              var size = this._surfaceSize();\n\n              var wrapper = new Rect([0, 0], [size.width, size.height]);\n\n              this._initSurface();\n\n              this.gaugeArea = this._createGaugeArea();\n\n              this._createModel();\n\n              var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n              this.reflow(bbox);\n            },\n            setOptions: function (options, theme) {\n              this._originalOptions = deepExtend(this._originalOptions, options);\n              this.options = deepExtend({}, this._originalOptions);\n\n              this._initTheme(theme);\n\n              this.redraw();\n            },\n            setDirection: function (rtl) {\n              this.contextService.rtl = Boolean(rtl);\n\n              if (this.surface && this.surface.type === 'svg') {\n                this.surface.destroy();\n                this.surface = null;\n              }\n            },\n            setIntlService: function (intl) {\n              this.contextService.intl = intl;\n            },\n            _initTheme: function (theme) {\n              var currentTheme = theme || this.theme || {};\n              this.theme = currentTheme;\n              this.options = deepExtend({}, currentTheme, this.options);\n              var options = this.options;\n              var pointer = options.pointer;\n\n              if (isArray(pointer)) {\n                var pointers = [];\n\n                for (var i = 0; i < pointer.length; i++) {\n                  pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n                }\n\n                options.pointer = pointers;\n              }\n            },\n            _createGaugeArea: function () {\n              var options = this.options.gaugeArea;\n              var size = this.surface.size();\n              var border = options.border || {};\n              var areaGeometry = new Rect([0, 0], [size.width, size.height]);\n              this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n              if (border.width > 0) {\n                areaGeometry = unpad(areaGeometry, border.width);\n              }\n\n              var gaugeArea = Path.fromRect(areaGeometry, {\n                stroke: {\n                  color: border.width ? border.color : \"\",\n                  width: border.width,\n                  dashType: border.dashType,\n                  lineJoin: \"round\",\n                  lineCap: \"round\"\n                },\n                fill: {\n                  color: options.background\n                }\n              });\n              return gaugeArea;\n            },\n            _initSurface: function () {\n              var ref = this;\n              var options = ref.options;\n              var surface = ref.surface;\n\n              var element = this._surfaceElement();\n\n              var size = this._surfaceSize();\n\n              dataviz.elementSize(element, size);\n\n              if (!surface || surface.options.type !== options.renderAs) {\n                if (surface) {\n                  surface.destroy();\n                }\n\n                this.surface = Surface.create(element, {\n                  type: options.renderAs\n                });\n              } else {\n                this.surface.clear();\n                this.surface.resize();\n              }\n            },\n            _surfaceSize: function () {\n              var options = this.options;\n\n              var size = this._getSize();\n\n              if (options.gaugeArea) {\n                deepExtend(size, options.gaugeArea);\n              }\n\n              return size;\n            },\n            _surfaceElement: function () {\n              if (!this.surfaceElement) {\n                this.surfaceElement = document.createElement('div');\n                this.element.appendChild(this.surfaceElement);\n              }\n\n              return this.surfaceElement;\n            },\n            getSize: function () {\n              return this._getSize();\n            },\n            _getSize: function () {\n              var element = this.element;\n\n              var defaultSize = this._defaultSize();\n\n              var width = element.offsetWidth;\n              var height = element.offsetHeight;\n\n              if (!width) {\n                width = defaultSize.width;\n              }\n\n              if (!height) {\n                height = defaultSize.height;\n              }\n\n              return {\n                width: width,\n                height: height\n              };\n            },\n            _defaultSize: function () {\n              return {\n                width: DEFAULT_WIDTH,\n                height: DEFAULT_HEIGHT\n              };\n            },\n            _toggleTransitions: function (value) {\n              var this$1 = this;\n              this.options.transitions = value;\n\n              for (var i = 0; i < this.pointers.length; i++) {\n                this$1.pointers[i].options.animation.transitions = value;\n              }\n            }\n          });\n          setDefaultOptions(Gauge, {\n            plotArea: {},\n            theme: \"default\",\n            renderAs: \"\",\n            pointer: {},\n            scale: {},\n            gaugeArea: {}\n          });\n          var Path$2 = DrawingPath;\n          var Group$2 = DrawingGroup;\n          var Point = GeometryPoint;\n\n          function renderAxisTick(tickRenderOptions, tickOptions) {\n            var position = tickRenderOptions.position;\n            var tickX = tickRenderOptions.tickX;\n            var tickY = tickRenderOptions.tickY;\n            var start, end;\n\n            if (tickRenderOptions.vertical) {\n              start = new Point(tickX, position);\n              end = new Point(tickX + tickOptions.size, position);\n            } else {\n              start = new Point(position, tickY);\n              end = new Point(position, tickY + tickOptions.size);\n            }\n\n            var tickPath = new Path$2({\n              stroke: {\n                color: tickOptions.color,\n                width: tickOptions.width\n              }\n            }).moveTo(start).lineTo(end);\n            return tickPath;\n          }\n\n          function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n            var count = tickPositions.length;\n\n            if (tickOptions.visible) {\n              var mirror = tickRenderOptions.mirror;\n              var lineBox = tickRenderOptions.lineBox;\n\n              for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n                if (i % tickOptions.skipUnit === 0) {\n                  continue;\n                }\n\n                tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                tickRenderOptions.position = tickPositions[i];\n                tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n              }\n            }\n          }\n\n          var LinearScale = NumericAxis.extend({\n            init: function (options, service) {\n              var scaleOptions = options || {};\n\n              if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n                scaleOptions = $.extend({}, scaleOptions, {\n                  reverse: true\n                });\n              }\n\n              NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n              this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n            },\n            initUserOptions: function (options) {\n              var scaleOptions = deepExtend({}, this.options, options);\n              scaleOptions = deepExtend({}, scaleOptions, {\n                labels: {\n                  mirror: scaleOptions.mirror\n                }\n              });\n              scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n              return scaleOptions;\n            },\n            initFields: function () {},\n            render: function () {\n              var elements = this.elements = new Group$2();\n              var labels = this.renderLabels();\n              var scaleLine = this.renderLine();\n              var scaleTicks = this.renderTicks();\n              var ranges = this.renderRanges();\n              elements.append(scaleLine, labels, scaleTicks, ranges);\n              return elements;\n            },\n            renderRanges: function () {\n              var this$1 = this;\n              var options = this.options;\n              var min = options.min;\n              var max = options.max;\n              var vertical = options.vertical;\n              var mirror = options.labels.mirror;\n              var ranges = options.ranges || [];\n              var elements = new Group$2();\n              var count = ranges.length;\n              var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n              for (var i = 0; i < count; i++) {\n                var range = getRange(ranges[i], min, max);\n                var slot = this$1.getSlot(range.from, range.to);\n                var slotX = vertical ? this$1.lineBox() : slot;\n                var slotY = vertical ? slot : this$1.lineBox();\n\n                if (vertical) {\n                  slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n                } else {\n                  slotY.y2 += rangeSize * (mirror ? -1 : 1);\n                }\n\n                elements.append(Path$2.fromRect(new Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {\n                  fill: {\n                    color: range.color,\n                    opacity: range.opacity\n                  },\n                  stroke: {}\n                }));\n              }\n\n              return elements;\n            },\n            renderLabels: function () {\n              var ref = this;\n              var labels = ref.labels;\n              var options = ref.options;\n              var elements = new Group$2();\n\n              for (var i = 0; i < labels.length; i++) {\n                elements.append(buildLabelElement(labels[i], options.labels));\n              }\n\n              return elements;\n            },\n            renderLine: function () {\n              var line = this.options.line;\n              var lineBox = this.lineBox();\n              var elements = new Group$2();\n\n              if (line.width > 0 && line.visible) {\n                var linePath = new Path$2({\n                  stroke: {\n                    color: line.color,\n                    dashType: line.dashType,\n                    width: line.width\n                  }\n                });\n                linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n                elements.append(linePath);\n              }\n\n              return elements;\n            },\n            renderTicks: function () {\n              var ticks = new Group$2();\n              var options = this.options;\n              var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n              var tickRenderOptions = {\n                vertical: options.vertical,\n                mirror: options.labels.mirror,\n                lineBox: this.lineBox()\n              };\n              renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n              renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n                skipUnit: majorUnit / options.minorUnit\n              }, options.minorTicks));\n              return ticks;\n            }\n          });\n          setDefaultOptions(LinearScale, {\n            min: 0,\n            max: 50,\n            majorTicks: {\n              size: 15,\n              align: INSIDE,\n              color: BLACK,\n              width: DEFAULT_LINE_WIDTH,\n              visible: true\n            },\n            minorTicks: {\n              size: 10,\n              align: INSIDE,\n              color: BLACK,\n              width: DEFAULT_LINE_WIDTH,\n              visible: true\n            },\n            line: {\n              width: DEFAULT_LINE_WIDTH\n            },\n            labels: {\n              position: INSIDE,\n              padding: 2\n            },\n            mirror: false,\n            _alignLines: false\n          });\n          var Pointer = dataviz.Class.extend({\n            init: function (scale, userOptions) {\n              var ref = scale.options;\n              var min = ref.min;\n              var max = ref.max;\n              var options = this.options = deepExtend({}, this.options, userOptions);\n              options.fill = options.color;\n              this.scale = scale;\n\n              if (defined(options.value)) {\n                options.value = limitValue(options.value, min, max);\n              } else {\n                options.value = min;\n              }\n            },\n            value: function (newValue) {\n              var options = this.options;\n              var value = options.value;\n\n              if (arguments.length === 0) {\n                return value;\n              }\n\n              var ref = this.scale.options;\n              var min = ref.min;\n              var max = ref.max;\n              options._oldValue = defined(options._oldValue) ? options.value : min;\n              options.value = limitValue(newValue, min, max);\n\n              if (this.elements) {\n                this.repaint();\n              }\n            }\n          });\n          setDefaultOptions(Pointer, {\n            color: BLACK\n          });\n          var LinearPointer = Pointer.extend({\n            init: function (scale, options) {\n              Pointer.fn.init.call(this, scale, options);\n              this.options = deepExtend({\n                track: {\n                  visible: defined(options.track)\n                }\n              }, this.options);\n            },\n            reflow: function () {\n              var ref = this;\n              var options = ref.options;\n              var scale = ref.scale;\n              var ref$1 = scale.options;\n              var mirror = ref$1.mirror;\n              var vertical = ref$1.vertical;\n              var scaleLine = scale.lineBox();\n              var trackSize = options.track.size || options.size;\n              var pointerHalfSize = options.size / 2;\n              var margin = getSpacing(options.margin);\n              var space = vertical ? margin[mirror ? \"left\" : \"right\"] : margin[mirror ? \"bottom\" : \"top\"];\n              var pointerBox, pointerRangeBox, trackBox;\n              space = mirror ? -space : space;\n\n              if (vertical) {\n                trackBox = new Box(scaleLine.x1 + space, scaleLine.y1, scaleLine.x1 + space, scaleLine.y2);\n\n                if (mirror) {\n                  trackBox.x1 -= trackSize;\n                } else {\n                  trackBox.x2 += trackSize;\n                }\n\n                if (options.shape !== BAR_POINTER) {\n                  pointerRangeBox = new Box(scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize, scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize);\n                  pointerBox = pointerRangeBox;\n                }\n              } else {\n                trackBox = new Box(scaleLine.x1, scaleLine.y1 - space, scaleLine.x2, scaleLine.y1 - space);\n\n                if (mirror) {\n                  trackBox.y2 += trackSize;\n                } else {\n                  trackBox.y1 -= trackSize;\n                }\n\n                if (options.shape !== BAR_POINTER) {\n                  pointerRangeBox = new Box(scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space, scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space);\n                  pointerBox = pointerRangeBox;\n                }\n              }\n\n              this.trackBox = trackBox;\n              this.pointerRangeBox = pointerRangeBox;\n              this.box = pointerBox || trackBox.clone().pad(options.border.width);\n            },\n            getElementOptions: function () {\n              var options = this.options;\n              return {\n                fill: {\n                  color: options.color,\n                  opacity: options.opacity\n                },\n                stroke: defined(options.border) ? {\n                  color: options.border.width ? options.border.color || options.color : \"\",\n                  width: options.border.width,\n                  dashType: options.border.dashType,\n                  opacity: options.opacity\n                } : null\n              };\n            },\n            _margin: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var ref$1 = scale.options;\n              var mirror = ref$1.mirror;\n              var vertical = ref$1.vertical;\n              var margin = getSpacing(options.margin);\n              var space = vertical ? margin[mirror ? \"left\" : \"right\"] : margin[mirror ? \"bottom\" : \"top\"];\n              return space;\n            }\n          });\n          setDefaultOptions(LinearPointer, {\n            shape: BAR_POINTER,\n            track: {\n              border: {\n                width: 1\n              }\n            },\n            color: BLACK,\n            border: {\n              width: 1\n            },\n            opacity: 1,\n            margin: getSpacing(3),\n            animation: {\n              type: BAR_POINTER\n            },\n            visible: true\n          });\n          var ArrowLinearPointerAnimation = Animation.extend({\n            setup: function () {\n              var options = this.options;\n              var margin = options.margin;\n              var from = options.from;\n              var to = options.to;\n              var vertical = options.vertical;\n              var axis = vertical ? \"x1\" : \"y1\";\n\n              if (options.mirror === vertical) {\n                from[axis] -= margin;\n                to[axis] -= margin;\n              } else {\n                from[axis] += margin;\n                to[axis] += margin;\n              }\n\n              var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n              var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n              if (options.duration !== 0) {\n                options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1000, 1);\n              }\n            },\n            step: function (pos) {\n              var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n              var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n              this.element.transform(transform().translate(translateX, translateY));\n            }\n          });\n          setDefaultOptions(ArrowLinearPointerAnimation, {\n            easing: LINEAR,\n            duration: LINEAR_SPEED\n          });\n          AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n          var Point$1 = GeometryPoint;\n          var Path$3 = DrawingPath;\n          var ArrowLinearPointer = LinearPointer.extend({\n            init: function (scale, options) {\n              LinearPointer.fn.init.call(this, scale, options);\n\n              if (!defined(this.options.size)) {\n                this.options.size = this.scale.options.majorTicks.size * 0.6;\n              }\n            },\n            pointerShape: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var size = ref.options.size;\n              var halfSize = size / 2;\n              var sign = scale.options.mirror ? -1 : 1;\n              var shape;\n\n              if (scale.options.vertical) {\n                shape = [new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)];\n              } else {\n                shape = [new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)];\n              }\n\n              return shape;\n            },\n            repaint: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n                vertical: scale.options.vertical,\n                mirror: scale.options.mirror,\n                margin: this._margin(options.margin),\n                from: scale.getSlot(options._oldValue),\n                to: scale.getSlot(options.value)\n              }));\n\n              if (options.animation.transitions === false) {\n                animation.options.duration = 0;\n              }\n\n              animation.setup();\n              animation.play();\n            },\n            render: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var elementOptions = this.getElementOptions();\n              var shape = this.pointerShape(options.value);\n              options.animation.type = ARROW_POINTER;\n              var elements = new Path$3({\n                stroke: elementOptions.stroke,\n                fill: elementOptions.fill\n              }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n              var slot = scale.getSlot(options.value);\n              elements.transform(transform().translate(slot.x1, slot.y1));\n              this.elements = elements;\n              return elements;\n            }\n          });\n          var BarLinearPointerAnimation = Animation.extend({\n            setup: function () {\n              var options = this.options;\n              var axis = this.axis = options.vertical ? constants.Y : constants.X;\n              var to = this.to = options.newPoints[0][axis];\n              var from = this.from = options.oldPoints[0][axis];\n\n              if (options.duration !== 0) {\n                options.duration = Math.max(Math.abs(to - from) / options.speed * 1000, 1);\n              }\n\n              this._set(from);\n            },\n            step: function (pos) {\n              var value = interpolateValue(this.from, this.to, pos);\n\n              this._set(value);\n            },\n            _set: function (value) {\n              var setter = \"set\" + this.axis.toUpperCase();\n              var points = this.options.newPoints;\n              points[0][setter](value);\n              points[1][setter](value);\n            }\n          });\n          setDefaultOptions(BarLinearPointerAnimation, {\n            easing: LINEAR,\n            speed: LINEAR_SPEED\n          });\n          AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n          var Group$3 = DrawingGroup;\n          var Path$4 = DrawingPath;\n          var BarLinearPointer = LinearPointer.extend({\n            init: function (scale, options) {\n              LinearPointer.fn.init.call(this, scale, options);\n\n              if (!defined(this.options.size)) {\n                this.options.size = this.scale.options.majorTicks.size * 0.3;\n              }\n            },\n            pointerShape: function (value) {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var ref$1 = scale.options;\n              var mirror = ref$1.mirror;\n              var vertical = ref$1.vertical;\n              var dir = mirror === vertical ? -1 : 1;\n              var size = options.size * dir;\n              var minSlot = scale.getSlot(scale.options.min);\n              var slot = scale.getSlot(value);\n              var axis = vertical ? constants.Y : constants.X;\n              var sizeAxis = vertical ? constants.X : constants.Y;\n              var margin = this._margin() * dir;\n              var p1 = new GeometryPoint();\n              p1[axis] = minSlot[axis + \"1\"];\n              p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n              var p2 = new GeometryPoint();\n              p2[axis] = slot[axis + \"1\"];\n              p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n              if (vertical) {\n                p1.translate(margin, 0);\n                p2.translate(margin, 0);\n              } else {\n                p1.translate(0, margin);\n                p2.translate(0, margin);\n              }\n\n              var p3 = p2.clone();\n              var p4 = p1.clone();\n\n              if (vertical) {\n                p3.translate(size, 0);\n                p4.translate(size, 0);\n              } else {\n                p3.translate(0, size);\n                p4.translate(0, size);\n              }\n\n              return [p1, p2, p3, p4];\n            },\n            repaint: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var shape = this.pointerShape(options.value);\n              var pointerPath = this.pointerPath;\n              var oldShape = this.pointerShape(options._oldValue);\n              pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n              var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n                reverse: scale.options.reverse,\n                vertical: scale.options.vertical,\n                oldPoints: [oldShape[1], oldShape[2]],\n                newPoints: [shape[1], shape[2]]\n              }));\n\n              if (options.animation.transitions === false) {\n                animation.options.duration = 0;\n              }\n\n              animation.setup();\n              animation.play();\n            },\n            render: function () {\n              var group = new Group$3();\n              var elementOptions = this.getElementOptions();\n\n              if (this.options.track.visible) {\n                group.append(this.renderTrack());\n              }\n\n              var pointer = this.pointerPath = new Path$4({\n                stroke: elementOptions.stroke,\n                fill: elementOptions.fill\n              });\n              group.append(pointer);\n              this.elements = group;\n              return group;\n            },\n            renderTrack: function () {\n              var trackOptions = this.options.track;\n              var border = trackOptions.border || {};\n              var trackBox = this.trackBox.clone().pad(border.width || 0);\n              return new Path$4.fromRect(trackBox.toRect(), {\n                fill: {\n                  color: trackOptions.color,\n                  opacity: trackOptions.opacity\n                },\n                stroke: {\n                  color: border.width ? border.color || trackOptions.color : \"\",\n                  width: border.width,\n                  dashType: border.dashType\n                }\n              });\n            }\n          });\n          var DEFAULT_MIN_WIDTH = 60;\n          var DEFAULT_MIN_HEIGHT = 60;\n          var Group$1 = DrawingGroup;\n          var LinearGauge = Gauge.extend({\n            reflow: function (bbox) {\n              var pointers = this.pointers;\n              var bboxX = bbox.origin.x;\n              var bboxY = bbox.origin.y;\n              var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n              this.scale.reflow(box);\n\n              this._shrinkScaleWidth(box);\n\n              for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow();\n              }\n\n              this.bbox = this._getBox(box);\n\n              this._alignElements();\n\n              this._shrinkElements();\n\n              this._buildVisual();\n\n              this._draw();\n            },\n            _buildVisual: function () {\n              var visuals = new Group$1();\n              var scaleElements = this.scale.render();\n              var pointers = this.pointers;\n              visuals.append(this.gaugeArea);\n              visuals.append(scaleElements);\n\n              for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                visuals.append(current.render());\n                current.value(current.options.value);\n              }\n\n              this._visuals = visuals;\n            },\n            _createModel: function () {\n              var this$1 = this;\n              var options = this.options;\n              var scale = this.scale = new LinearScale(options.scale, this.contextService);\n              this.pointers = [];\n              var pointers = options.pointer;\n              pointers = isArray(pointers) ? pointers : [pointers];\n\n              for (var i = 0; i < pointers.length; i++) {\n                var currentOptions = deepExtend({}, pointers[i], {\n                  animation: {\n                    transitions: options.transitions\n                  }\n                });\n                var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n                this$1.pointers.push(new pointerType(scale, currentOptions));\n              }\n            },\n            _defaultSize: function () {\n              var vertical = this.options.scale.vertical;\n              return {\n                width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n                height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n              };\n            },\n            _getBox: function (box) {\n              var ref = this;\n              var scale = ref.scale;\n              var pointers = ref.pointers;\n              var boxCenter = box.center();\n              var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n              for (var i = 0; i < pointers.length; i++) {\n                plotAreaBox.wrap(pointers[i].box.clone());\n              }\n\n              var size;\n\n              if (scale.options.vertical) {\n                size = plotAreaBox.width() / 2;\n                plotAreaBox = new Box(boxCenter.x - size, box.y1, boxCenter.x + size, box.y2);\n              } else {\n                size = plotAreaBox.height() / 2;\n                plotAreaBox = new Box(box.x1, boxCenter.y - size, box.x2, boxCenter.y + size);\n              }\n\n              return plotAreaBox;\n            },\n            _alignElements: function () {\n              var this$1 = this;\n              var ref = this;\n              var scale = ref.scale;\n              var pointers = ref.pointers;\n              var scaleBox = scale.box;\n              var box = pointers[0].box.clone().wrap(scale.box);\n              var plotAreaBox = this.bbox;\n\n              for (var i = 0; i < pointers.length; i++) {\n                box.wrap(pointers[i].box.clone());\n              }\n\n              var diff;\n\n              if (scale.options.vertical) {\n                diff = plotAreaBox.center().x - box.center().x;\n                scale.reflow(new Box(scaleBox.x1 + diff, plotAreaBox.y1, scaleBox.x2 + diff, plotAreaBox.y2));\n              } else {\n                diff = plotAreaBox.center().y - box.center().y;\n                scale.reflow(new Box(scaleBox.x1, scaleBox.y1 + diff, scaleBox.x2, scaleBox.y2 + diff));\n              }\n\n              for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n                pointers[i$1].reflow(this$1.bbox);\n              }\n            },\n            _shrinkScaleWidth: function (bbox) {\n              var ref = this;\n              var scale = ref.scale;\n\n              if (!scale.options.vertical) {\n                var overflow = scale.contentBox().width() - bbox.width();\n\n                if (overflow > 0) {\n                  scale.box.shrink(overflow, 0);\n                  scale.box.alignTo(bbox, 'center');\n                  scale.reflow(scale.box);\n                }\n              }\n            },\n            _shrinkElements: function () {\n              var this$1 = this;\n              var ref = this;\n              var scale = ref.scale;\n              var pointers = ref.pointers;\n              var scaleBox = scale.box.clone();\n              var pos = scale.options.vertical ? \"y\" : \"x\";\n              var pointerBox = pointers[0].box;\n\n              for (var i = 0; i < pointers.length; i++) {\n                pointerBox.wrap(pointers[i].box.clone());\n              }\n\n              scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n              scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n              scale.reflow(scaleBox);\n\n              for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n                pointers[i$1].reflow(this$1.bbox);\n              }\n            }\n          });\n          setDefaultOptions(LinearGauge, {\n            transitions: true,\n            gaugeArea: {\n              background: \"\"\n            },\n            scale: {\n              vertical: true\n            }\n          });\n          var GEO_ARC_ADJUST_ANGLE = 180;\n          var Arc = drawing.Arc;\n          var Path$5 = DrawingPath;\n          var Group$5 = DrawingGroup;\n\n          function drawTicks(arc, tickAngles, unit, tickOptions) {\n            var ticks = new Group$5();\n            var center = arc.center;\n            var radius = arc.getRadiusX();\n\n            if (tickOptions.visible) {\n              for (var i = 0; i < tickAngles.length; i++) {\n                var tickStart = arc.pointAt(tickAngles[i]);\n                var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n                ticks.append(new Path$5({\n                  stroke: {\n                    color: tickOptions.color,\n                    width: tickOptions.width\n                  }\n                }).moveTo(tickStart).lineTo(tickEnd));\n              }\n            }\n\n            return ticks;\n          }\n\n          function rangeSegment(from, to, color, opacity) {\n            return {\n              from: from,\n              to: to,\n              color: color,\n              opacity: opacity\n            };\n          }\n\n          var RadialScale = NumericAxis.extend({\n            init: function (options, service) {\n              NumericAxis.fn.init.call(this, 0, 1, options, service);\n            },\n            initUserOptions: function (options) {\n              var scaleOptions = deepExtend({}, this.options, options);\n              scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n              scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n              return scaleOptions;\n            },\n            initFields: function () {},\n            render: function (center, radius) {\n              var arc = this.renderArc(center, radius);\n              this.bbox = arc.bbox();\n              this.labelElements = this.renderLabels();\n              this.ticks = this.renderTicks();\n              this.ranges = this.renderRanges();\n            },\n            reflow: function (bbox) {\n              var center = bbox.center();\n              var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n              if (defined(this.bbox)) {\n                this.bbox = this.arc.bbox();\n                this.radius(this.arc.getRadiusX());\n                this.repositionRanges();\n                this.renderLabels();\n              } else {\n                return this.render(center, radius);\n              }\n            },\n            slotAngle: function (value) {\n              var ref = this.options;\n              var min = ref.min;\n              var max = ref.max;\n              var reverse = ref.reverse;\n              var startAngle = ref.startAngle;\n              var endAngle = ref.endAngle;\n              var angle = endAngle - startAngle;\n              var result;\n\n              if (reverse) {\n                result = endAngle - (value - min) / (max - min) * angle;\n              } else {\n                result = (value - min) / (max - min) * angle + startAngle;\n              }\n\n              return result + GEO_ARC_ADJUST_ANGLE;\n            },\n            hasRanges: function () {\n              var ranges = this.options.ranges;\n              return ranges && ranges.length;\n            },\n            ticksSize: function () {\n              var ref = this.options;\n              var majorTicks = ref.majorTicks;\n              var minorTicks = ref.minorTicks;\n              var size = 0;\n\n              if (majorTicks.visible) {\n                size = majorTicks.size;\n              }\n\n              if (minorTicks.visible) {\n                size = Math.max(minorTicks.size, size);\n              }\n\n              return size;\n            },\n            labelsCount: function () {\n              var count = NumericAxis.fn.labelsCount.call(this);\n              var options = this.options;\n              var angle = options.endAngle - options.startAngle;\n\n              if (angle >= 360 && options.max % options.majorUnit === 0) {\n                count -= 1;\n              }\n\n              return count;\n            },\n            renderLabels: function () {\n              var this$1 = this;\n              var options = this.options;\n              var arc = this.arc.clone();\n              var radius = arc.getRadiusX();\n              var tickAngles = this.tickAngles(arc, options.majorUnit);\n              var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n              var labelsGroup = new Group$5();\n              var rangeDistance = radius * 0.05;\n\n              if (defined(options.rangeDistance)) {\n                rangeDistance = options.rangeDistance;\n              } else {\n                options.rangeDistance = rangeDistance;\n              }\n\n              var labelsOptions = options.labels;\n              var isInside = labelsOptions.position === INSIDE;\n              var hasLabelElements = defined(this.labelElements);\n\n              if (isInside) {\n                radius -= this.ticksSize();\n\n                if (this.hasRanges() && !hasLabelElements) {\n                  radius -= rangeSize + rangeDistance;\n                }\n\n                arc.setRadiusX(radius).setRadiusY(radius);\n              }\n\n              var labels = this.labels;\n              var count = labels.length;\n              var padding = getSpacing(labelsOptions.padding);\n              var paddingWidth = (padding.left + padding.right) / 2;\n              var paddingHeight = (padding.top + padding.bottom) / 2;\n\n              for (var i = 0; i < count; i++) {\n                var label = labels[i];\n                var halfWidth = label.box.width() / 2;\n                var halfHeight = label.box.height() / 2;\n                var angle = tickAngles[i];\n                var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n                var lp = arc.pointAt(angle);\n                var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);\n                var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);\n                label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n                var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n                var labelElement = void 0;\n\n                if (!hasLabelElements) {\n                  labelElement = buildLabelElement(label, options.labels);\n                  labelsGroup.append(labelElement);\n                } else {\n                  labelElement = this$1.labelElements.children[i];\n                  var prevLabelPos = labelElement.bbox().origin;\n                  var labelTransform = labelElement.transform() || transform();\n                  labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                  labelElement.transform(labelTransform);\n                }\n\n                this$1.bbox = Rect.union(this$1.bbox, labelElement.bbox());\n              }\n\n              return labelsGroup;\n            },\n            repositionRanges: function () {\n              var ranges = this.ranges.children;\n\n              if (ranges.length > 0) {\n                var ref = this.options;\n                var rangeDistance = ref.rangeDistance;\n                var rangeSize = ref.rangeSize;\n                var rangeRadius = this.getRangeRadius();\n\n                if (this.options.labels.position === INSIDE) {\n                  rangeRadius += rangeSize + rangeDistance;\n                }\n\n                var newRadius = rangeRadius + rangeSize / 2;\n\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n                }\n\n                this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n              }\n            },\n            renderRanges: function () {\n              var this$1 = this;\n              var segments = this.rangeSegments();\n              var segmentsCount = segments.length;\n              var result = new Group$5();\n\n              if (segmentsCount) {\n                var ref = this.options;\n                var rangeSize = ref.rangeSize;\n                var reverse = ref.reverse;\n                var rangeDistance = ref.rangeDistance;\n                var rangeRadius = this.getRangeRadius(); // move the ticks with a range distance and a range size\n\n                this.radius(this.radius() - rangeSize - rangeDistance);\n\n                for (var i = 0; i < segmentsCount; i++) {\n                  var segment = segments[i];\n                  var from = this$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                  var to = this$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                  if (to - from !== 0) {\n                    result.append(this$1.createRange(from, to, rangeRadius, segment));\n                  }\n                }\n              }\n\n              return result;\n            },\n            createRange: function (startAngle, endAngle, rangeRadius, options) {\n              var rangeSize = this.options.rangeSize;\n              var rangeGeom = new geometry.Arc(this.arc.center, {\n                radiusX: rangeRadius + rangeSize / 2,\n                radiusY: rangeRadius + rangeSize / 2,\n                startAngle: startAngle,\n                endAngle: endAngle\n              });\n              return new Arc(rangeGeom, {\n                stroke: {\n                  width: rangeSize,\n                  color: options.color,\n                  opacity: options.opacity,\n                  lineCap: options.lineCap\n                }\n              });\n            },\n            rangeSegments: function () {\n              var options = this.options;\n              var ranges = options.ranges || [];\n              var count = ranges.length;\n              var segments = [];\n\n              if (count) {\n                var min = options.min;\n                var max = options.max;\n                var defaultColor = options.rangePlaceholderColor;\n                segments.push(rangeSegment(min, max, defaultColor));\n\n                for (var i = 0; i < count; i++) {\n                  var range = getRange(ranges[i], min, max);\n                  var segmentsCount = segments.length;\n\n                  for (var j = 0; j < segmentsCount; j++) {\n                    var segment = segments[j];\n\n                    if (segment.from <= range.from && range.from <= segment.to) {\n                      segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                      if (segment.from <= range.to && range.to <= segment.to) {\n                        segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                      }\n\n                      segment.to = range.from;\n                      break;\n                    }\n                  }\n                }\n              }\n\n              return segments;\n            },\n            getRangeRadius: function () {\n              var ref = this;\n              var arc = ref.arc;\n              var options = ref.options;\n              var rangeSize = options.rangeSize;\n              var rangeDistance = options.rangeDistance;\n              var majorTickSize = options.majorTicks.size;\n              var radius;\n\n              if (options.labels.position === OUTSIDE) {\n                radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n              } else {\n                radius = arc.getRadiusX() - rangeSize;\n              }\n\n              return radius;\n            },\n            renderArc: function (center, radius) {\n              var options = this.options;\n              var arc = this.arc = new geometry.Arc(center, {\n                radiusX: radius,\n                radiusY: radius,\n                startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n                endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n              });\n              return arc;\n            },\n            renderTicks: function () {\n              var ref = this;\n              var arc = ref.arc;\n              var options = ref.options;\n              var tickArc = arc.clone();\n              this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n              this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n              var allTicks = new Group$5();\n              allTicks.append(this.majorTicks);\n              var majorTickSize = options.majorTicks.size;\n              var minorTickSize = options.minorTicks.size;\n              this._tickDifference = majorTickSize - minorTickSize;\n\n              if (options.labels.position === OUTSIDE) {\n                var radius = tickArc.getRadiusX();\n                tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);\n              }\n\n              this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n              this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n              allTicks.append(this.minorTicks);\n              return allTicks;\n            },\n            normalizeTickAngles: function (angles) {\n              var options = this.options;\n              var skip = options.majorUnit / options.minorUnit;\n\n              for (var i = angles.length - 1; i >= 0; i--) {\n                if (i % skip === 0) {\n                  angles.splice(i, 1);\n                }\n              }\n\n              return angles;\n            },\n            tickAngles: function (ring, stepValue) {\n              var options = this.options;\n              var reverse = options.reverse;\n              var range = options.max - options.min;\n              var angle = ring.endAngle - ring.startAngle;\n              var tickCount = range / stepValue;\n              var pos = ring.startAngle;\n              var step = angle / tickCount;\n\n              if (reverse) {\n                pos += angle;\n                step = -step;\n              }\n\n              if (angle >= 360 && options.max % stepValue === 0) {\n                tickCount -= 1;\n              }\n\n              var positions = [];\n\n              for (var i = 0; i < tickCount; i++) {\n                positions.push(round(pos, COORD_PRECISION));\n                pos += step;\n              }\n\n              if (round(pos) <= ring.endAngle) {\n                positions.push(pos);\n              }\n\n              return positions;\n            },\n            radius: function (value) {\n              if (value) {\n                this.arc.setRadiusX(value).setRadiusY(value);\n                this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n                this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n              } else {\n                return this.arc.getRadiusX();\n              }\n            },\n            repositionTicks: function (ticks, tickAngles, minor) {\n              var diff = minor ? this._tickDifference || 0 : 0;\n              var tickArc = this.arc;\n              var radius = tickArc.getRadiusX();\n\n              if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n                tickArc = this.arc.clone();\n                tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n              }\n\n              for (var i = 0; i < ticks.length; i++) {\n                var newPoint = tickArc.pointAt(tickAngles[i]);\n                var segments = ticks[i].segments;\n                var xDiff = newPoint.x - segments[0].anchor().x;\n                var yDiff = newPoint.y - segments[0].anchor().y;\n                ticks[i].transform(new transform().translate(xDiff, yDiff));\n              }\n            }\n          });\n          setDefaultOptions(RadialScale, {\n            min: 0,\n            max: 100,\n            majorTicks: {\n              size: 15,\n              align: INSIDE,\n              color: BLACK,\n              width: DEFAULT_LINE_WIDTH,\n              visible: true\n            },\n            minorTicks: {\n              size: 10,\n              align: INSIDE,\n              color: BLACK,\n              width: DEFAULT_LINE_WIDTH,\n              visible: true\n            },\n            startAngle: -30,\n            endAngle: 210,\n            labels: {\n              position: INSIDE,\n              padding: 2\n            }\n          });\n          var RadialPointerAnimation = Animation.extend({\n            init: function (element, options) {\n              Animation.fn.init.call(this, element, options);\n              var animationOptions = this.options;\n              animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1000, 1);\n            },\n            step: function (pos) {\n              var options = this.options;\n              var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n              this.element.transform(transform().rotate(angle, options.center));\n            }\n          });\n          setDefaultOptions(RadialPointerAnimation, {\n            easing: LINEAR,\n            duration: ANGULAR_SPEED\n          });\n          AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n          var CAP_SIZE = 0.05;\n          var Circle = drawing.Circle;\n          var Group$6 = DrawingGroup;\n          var Path$6 = DrawingPath;\n          var RadialPointer = Pointer.extend({\n            setAngle: function (angle) {\n              this.elements.transform(transform().rotate(angle, this.center));\n            },\n            repaint: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var oldAngle = scale.slotAngle(options._oldValue);\n              var newAngle = scale.slotAngle(options.value);\n\n              if (options.animation.transitions === false) {\n                this.setAngle(newAngle);\n              } else {\n                new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n                  oldAngle: oldAngle,\n                  newAngle: newAngle\n                })).play();\n              }\n            },\n            render: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var elements = new Group$6();\n\n              if (options.animation !== false) {\n                deepExtend(options.animation, {\n                  startAngle: 0,\n                  center: scale.arc.center,\n                  reverse: scale.options.reverse\n                });\n              }\n\n              elements.append(this._renderNeedle(), this._renderCap());\n              this.elements = elements;\n              this.setAngle(DEGREE);\n              return elements;\n            },\n            reflow: function (arc) {\n              var center = this.center = arc.center;\n              var length = limitValue(this.options.length || 1, 0.1, 1.5);\n              var radius = this.radius = arc.getRadiusX() * length;\n              var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n              this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize), new GeometryPoint(center.x + capSize, center.y + capSize));\n            },\n            _renderNeedle: function () {\n              var minorTickSize = this.scale.options.minorTicks.size;\n              var center = this.center;\n              var needleColor = this.options.color;\n              var needlePath = new Path$6({\n                fill: {\n                  color: needleColor\n                },\n                stroke: {\n                  color: needleColor,\n                  width: DEFAULT_LINE_WIDTH\n                }\n              });\n              needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();\n              return needlePath;\n            },\n            _renderCap: function () {\n              var options = this.options;\n              var capColor = options.cap.color || options.color;\n              var circle = new geometry.Circle(this.center, this.capSize);\n              var cap = new Circle(circle, {\n                fill: {\n                  color: capColor\n                },\n                stroke: {\n                  color: capColor\n                }\n              });\n              return cap;\n            }\n          });\n          setDefaultOptions(RadialPointer, {\n            cap: {\n              size: CAP_SIZE\n            },\n            arrow: {\n              width: 16,\n              height: 14\n            },\n            animation: {\n              type: RADIAL_POINTER,\n              duration: ANGULAR_SPEED\n            }\n          });\n          var Group$4 = DrawingGroup;\n          var RadialGauge = Gauge.extend({\n            reflow: function (bbox) {\n              var this$1 = this;\n              var pointers = this.pointers;\n              this.scale.reflow(bbox);\n              this._initialPlotArea = this.scale.bbox;\n\n              for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(this$1.scale.arc);\n                this$1._initialPlotArea = Rect.union(this$1._initialPlotArea, pointers[i].bbox);\n              }\n\n              this.fitScale(bbox);\n              this.alignScale(bbox);\n\n              this._buildVisual(this.gaugeArea, pointers, this.scale);\n\n              this._draw();\n            },\n            _buildVisual: function (gaugeArea, pointers, scale) {\n              var visuals = this._visuals = new Group$4();\n              visuals.append(gaugeArea);\n              visuals.append(scale.ticks);\n              visuals.append(scale.ranges);\n\n              this._buildPointers(pointers);\n\n              visuals.append(scale.labelElements);\n            },\n            _buildPointers: function (pointers) {\n              var this$1 = this;\n\n              for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                current.render();\n\n                this$1._visuals.append(current.elements);\n\n                current.value(current.options.value);\n              }\n            },\n            fitScale: function (bbox) {\n              var this$1 = this;\n              var arc = this.scale.arc;\n              var plotAreaBox = this._initialPlotArea;\n              var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n              var min = round(step, COORD_PRECISION);\n              var max = round(-step, COORD_PRECISION);\n              var minDiff, midDiff, maxDiff, mid, oldDiff;\n              var staleFlag = 0;\n              var i = 0;\n\n              while (i++ < 100) {\n                staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;\n\n                if (staleFlag > 5) {\n                  break;\n                }\n\n                if (min !== mid) {\n                  minDiff = this$1.getPlotBox(min, bbox, arc);\n\n                  if (0 <= minDiff && minDiff <= 2) {\n                    break;\n                  }\n                }\n\n                if (max !== mid) {\n                  maxDiff = this$1.getPlotBox(max, bbox, arc);\n\n                  if (0 <= maxDiff && maxDiff <= 2) {\n                    break;\n                  }\n                }\n\n                if (minDiff > 0 && maxDiff > 0) {\n                  mid = min * 2;\n                } else if (minDiff < 0 && maxDiff < 0) {\n                  mid = max * 2;\n                } else {\n                  mid = round((min + max) / 2 || 1, COORD_PRECISION);\n                }\n\n                midDiff = this$1.getPlotBox(mid, bbox, arc);\n\n                if (0 <= midDiff && midDiff <= 2) {\n                  break;\n                }\n\n                oldDiff = maxDiff;\n\n                if (midDiff > 0) {\n                  max = mid;\n                  maxDiff = midDiff;\n                } else {\n                  min = mid;\n                  minDiff = midDiff;\n                }\n              }\n            },\n            getPlotBox: function (step, bbox, arc) {\n              var this$1 = this;\n              var scale = this.scale;\n              var pointers = this.pointers;\n              var radius = arc.getRadiusX();\n              var scaleArc = arc.clone();\n              scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n              scale.arc = scaleArc;\n              scale.reflow(bbox);\n              this.plotBbox = scale.bbox;\n\n              for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(scaleArc);\n                this$1.plotBbox = Rect.union(this$1.plotBbox, pointers[i].bbox);\n              }\n\n              return this.getDiff(this.plotBbox, bbox);\n            },\n            getDiff: function (plotBox, box) {\n              return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n            },\n            alignScale: function (bbox) {\n              var this$1 = this;\n              var plotBoxCenter = this.plotBbox.center();\n              var boxCenter = bbox.center();\n              var paddingX = plotBoxCenter.x - boxCenter.x;\n              var paddingY = plotBoxCenter.y - boxCenter.y;\n              var ref = this;\n              var scale = ref.scale;\n              var pointers = ref.pointers;\n              scale.arc.center.x -= paddingX;\n              scale.arc.center.y -= paddingY;\n              scale.reflow(bbox);\n\n              for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(scale.arc);\n                this$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n              }\n            },\n            _createModel: function () {\n              var this$1 = this;\n              var options = this.options;\n              var pointers = options.pointer;\n              var scale = this.scale = new RadialScale(options.scale, this.contextService);\n              this.pointers = [];\n              var pointersArr = isArray(pointers) ? pointers : [pointers];\n\n              for (var i = 0; i < pointersArr.length; i++) {\n                var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n                  animation: {\n                    transitions: options.transitions\n                  }\n                }));\n                this$1.pointers.push(current);\n              }\n            }\n          });\n          setDefaultOptions(RadialGauge, {\n            transitions: true,\n            gaugeArea: {\n              background: \"\"\n            }\n          });\n          var ArcScale = RadialScale.extend({\n            rangeSegments: function () {\n              var ref = this.options;\n              var min = ref.min;\n              var max = ref.max;\n              var rangePlaceholderColor = ref.rangePlaceholderColor;\n              var rangeLineCap = ref.rangeLineCap;\n              return [{\n                from: min,\n                to: max,\n                color: rangePlaceholderColor,\n                lineCap: rangeLineCap\n              }];\n            },\n            hasRanges: function () {\n              return true;\n            },\n            placeholderRangeAngle: function (angle) {\n              var geometry$$1 = this.ranges.children[0].geometry();\n\n              if (this.options.reverse) {\n                geometry$$1.setEndAngle(angle);\n              } else {\n                geometry$$1.setStartAngle(angle);\n              }\n            },\n            addRange: function (from, to, options) {\n              var reverse = this.options.reverse;\n              var startAngle = this.slotAngle(reverse ? to : from);\n              var endAngle = this.slotAngle(reverse ? from : to);\n              var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n              this.ranges.append(range);\n              return range;\n            }\n          });\n          setDefaultOptions(ArcScale, {\n            min: 0,\n            max: 100,\n            majorTicks: {\n              visible: false\n            },\n            minorTicks: {\n              visible: false\n            },\n            labels: {\n              visible: false\n            },\n            startAngle: 0,\n            endAngle: 180,\n            rangeLineCap: 'round'\n          });\n          var MAX_DURATION = 800;\n          var RangePointerAnimation = Animation.extend({\n            init: function (element, options) {\n              Animation.fn.init.call(this, element, options);\n              var animationOptions = this.options;\n              var duration = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1000;\n              animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n              var startColor = element.elements.options.get(\"stroke.color\");\n              var color = element.currentColor();\n\n              if (startColor !== color) {\n                this.startColor = new kendo.Color(startColor);\n                this.color = new kendo.Color(color);\n              }\n            },\n            step: function (pos) {\n              var ref = this;\n              var options = ref.options;\n              var startColor = ref.startColor;\n              var color = ref.color;\n              var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n              this.element.angle(angle);\n\n              if (color) {\n                var r = round(interpolateValue(startColor.r, color.r, pos));\n                var g = round(interpolateValue(startColor.g, color.g, pos));\n                var b = round(interpolateValue(startColor.b, color.b, pos));\n                this.element.stroke(new kendo.Color(r, g, b).toHex());\n              }\n            }\n          });\n          setDefaultOptions(RangePointerAnimation, {\n            easing: LINEAR,\n            duration: ANGULAR_SPEED\n          });\n          AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n          var RangePointer = Pointer.extend({\n            repaint: function () {\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n              var oldAngle = scale.slotAngle(options._oldValue);\n              var newAngle = scale.slotAngle(options.value);\n\n              if (this.animation) {\n                this.animation.abort();\n              }\n\n              if (options.animation.transitions === false) {\n                this.angle(newAngle);\n                this.stroke(this.currentColor());\n              } else {\n                this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n                  oldAngle: oldAngle,\n                  newAngle: newAngle\n                }));\n                this.animation.play();\n              }\n            },\n            angle: function (value) {\n              var geometry$$1 = this.elements.geometry();\n\n              if (this.scale.options.reverse) {\n                geometry$$1.setStartAngle(value);\n              } else {\n                geometry$$1.setEndAngle(value);\n              }\n\n              this.scale.placeholderRangeAngle(value);\n            },\n            stroke: function (value) {\n              this.elements.stroke(value);\n            },\n            render: function () {\n              if (this.elements) {\n                return;\n              }\n\n              var ref = this;\n              var scale = ref.scale;\n              var options = ref.options;\n\n              if (options.animation !== false) {\n                deepExtend(options.animation, {\n                  startAngle: 0,\n                  center: scale.arc.center,\n                  reverse: scale.options.reverse\n                });\n              }\n\n              this.elements = scale.addRange(scale.options.min, this.options.value, {\n                color: this.currentColor(),\n                opacity: options.opacity,\n                lineCap: scale.options.rangeLineCap\n              });\n            },\n            currentColor: function () {\n              var ref = this.scale.options;\n              var min = ref.min;\n              var max = ref.max;\n              var ref$1 = this.options;\n              var colors = ref$1.colors;\n              var color = ref$1.color;\n              var value = ref$1.value;\n              var currentValue = dataviz.isNumber(value) ? value : min;\n\n              if (colors) {\n                for (var idx = 0; idx < colors.length; idx++) {\n                  var ref$2 = colors[idx];\n                  var rangeColor = ref$2.color;\n                  var from = ref$2.from;\n\n                  if (from === void 0) {\n                    from = min;\n                  }\n\n                  var to = ref$2.to;\n\n                  if (to === void 0) {\n                    to = max;\n                  }\n\n                  if (from <= currentValue && currentValue <= to) {\n                    return rangeColor;\n                  }\n                }\n              }\n\n              return color;\n            },\n            reflow: function () {\n              this.render();\n              this.bbox = this.elements.bbox();\n            }\n          });\n          setDefaultOptions(RangePointer, {\n            animation: {\n              type: RADIAL_RANGE_POINTER,\n              duration: ANGULAR_SPEED\n            }\n          });\n          var ArcGauge = RadialGauge.extend({\n            _initTheme: function (theme) {\n              RadialGauge.fn._initTheme.call(this, theme);\n\n              this.options.color = this.options.color || (this.theme.pointer || {}).color;\n            },\n            _createModel: function () {\n              var options = this.options;\n              var scale = this.scale = new ArcScale(options.scale, this.contextService);\n              var pointer = new RangePointer(scale, deepExtend({}, {\n                colors: options.colors,\n                color: options.color,\n                value: options.value,\n                opacity: options.opacity,\n                animation: {\n                  transitions: options.transitions\n                }\n              }));\n              this.pointers = [pointer];\n            },\n            _buildPointers: function (pointers) {\n              for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                current.render();\n                current.value(current.options.value);\n              }\n            },\n            _setValueOptions: function (value) {\n              this.options.value = value;\n            },\n            currentColor: function () {\n              var pointer = this.pointers[0];\n\n              if (pointer) {\n                return pointer.currentColor();\n              }\n            },\n            centerLabelPosition: function (width, height) {\n              var size = this.getSize();\n              var center = this.scale.arc.center;\n              var left = center.x - width / 2;\n              var top = center.y - height / 2;\n\n              if (width < size.width) {\n                var right = left + width;\n                left = Math.max(left, 0);\n\n                if (right > size.width) {\n                  left -= right - size.width;\n                }\n              }\n\n              if (height < size.height) {\n                var bbox = this.scale.bbox;\n                var yLimit = bbox.bottomRight().y;\n                var bottom = top + height;\n                top = Math.max(top, bbox.origin.y);\n\n                if (bottom > yLimit) {\n                  top -= bottom - yLimit;\n                }\n              }\n\n              return {\n                left: left,\n                top: top\n              };\n            }\n          });\n          var defaultStartAngle = 90;\n          var CircularGauge = ArcGauge.extend({\n            _createModel: function () {\n              var scaleOptions = this.options.scale;\n\n              if (typeof scaleOptions.startAngle !== 'number') {\n                scaleOptions.startAngle = defaultStartAngle;\n              }\n\n              scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n              ArcGauge.fn._createModel.call(this);\n            }\n          });\n          kendo.deepExtend(kendo.dataviz, {\n            Gauge: Gauge,\n            LinearGauge: LinearGauge,\n            LinearPointer: LinearPointer,\n            ArrowLinearPointer: ArrowLinearPointer,\n            BarLinearPointer: BarLinearPointer,\n            LinearScale: LinearScale,\n            RadialGauge: RadialGauge,\n            RadialPointer: RadialPointer,\n            RadialScale: RadialScale,\n            ArcGauge: ArcGauge,\n            RangePointer: RangePointer,\n            ArcScale: ArcScale,\n            CircularGauge: CircularGauge\n          });\n        })(window.kendo.jQuery);\n      }, __webpack_require__.amdD);\n      /***/\n\n    },\n\n    /***/\n    13298:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"../../kendo.color\");\n      /***/\n    },\n\n    /***/\n    33877:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"../../kendo.core\");\n      /***/\n    },\n\n    /***/\n    32549:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"../../kendo.dataviz.core\");\n      /***/\n    },\n\n    /***/\n    79174:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"../../kendo.drawing\");\n      /***/\n    }\n    /******/\n\n  };\n  /************************************************************************/\n\n  /******/\n  // The module cache\n\n  /******/\n\n  var __webpack_module_cache__ = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n\n    if (cachedModule !== undefined) {\n      /******/\n      return cachedModule.exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/\n      // no module.id needed\n\n      /******/\n      // no module.loaded needed\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /* webpack/runtime/amd define */\n\n  /******/\n\n\n  !function () {\n    /******/\n    __webpack_require__.amdD = function () {\n      /******/\n      throw new Error('define cannot be used indirect');\n      /******/\n    };\n    /******/\n\n  }();\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /******/\n  // startup\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n  // This entry module used 'module' so it can't be inlined\n\n  /******/\n\n  var __webpack_exports__ = __webpack_require__(87613);\n  /******/\n\n\n  module.exports = __webpack_exports__;\n  /******/\n\n  /******/\n})();","map":{"version":3,"names":["__webpack_modules__","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","f","define","apply","undefined","$","window","kendo","dataviz","getSpacing","defined","constants","BLACK","COORD_PRECISION","services","deepExtend","isArray","setDefaultOptions","NumericAxis","limitValue","Box","interpolateValue","round","drawing","DrawingGroup","Group","DrawingPath","Path","Animation","AnimationFactory","geometry","Rect","GeometryPoint","Point","transform","ANGULAR_SPEED","LINEAR_SPEED","ARROW","ARROW_POINTER","BAR_POINTER","DEFAULT_HEIGHT","DEFAULT_LINE_WIDTH","DEFAULT_WIDTH","DEGREE","Math","PI","INSIDE","LINEAR","OUTSIDE","RADIAL_POINTER","RADIAL_RANGE_POINTER","pad","bbox","value","origin","getOrigin","size","getSize","spacing","setOrigin","x","left","y","top","setSize","width","right","height","bottom","Path$1","Text","buildLabelElement","label","options","labelBox","box","textBox","children","border","background","wrapper","fromRect","x1","y1","stroke","text","font","fill","color","styleGeometry","clone","padding","styleBox","opacity","dashType","lineJoin","lineCap","elements","append","getRange","range","min","max","from","MIN_VALUE","to","MAX_VALUE","unpad","DEFAULT_MARGIN","Surface","Gauge","Class","extend","init","element","userOptions","theme","context","contextService","ChartService","_originalOptions","_initTheme","redraw","destroy","surface","surfaceElement","pointerValue","pointer","pointers","arguments","length","_setValueOptions","_draw","clear","draw","_visuals","exportVisual","allValues","values","i","push","i$1","isNumber","concat","arrayValues","resize","noTransitionsRedraw","transitions","_toggleTransitions","_surfaceSize","_initSurface","gaugeArea","_createGaugeArea","_createModel","_gaugeAreaMargin","reflow","setOptions","setDirection","rtl","Boolean","type","setIntlService","intl","currentTheme","areaGeometry","margin","ref","_surfaceElement","elementSize","renderAs","create","_getSize","document","createElement","appendChild","defaultSize","_defaultSize","offsetWidth","offsetHeight","this$1","animation","plotArea","scale","Path$2","Group$2","renderAxisTick","tickRenderOptions","tickOptions","position","tickX","tickY","start","end","vertical","tickPath","moveTo","lineTo","renderTicks","tickGroup","tickPositions","count","visible","mirror","lineBox","skip","step","skipUnit","x2","LinearScale","service","scaleOptions","reverse","fn","call","minorUnit","majorUnit","initUserOptions","labels","autoMajorUnit","initFields","render","renderLabels","scaleLine","renderLine","scaleTicks","ranges","renderRanges","rangeSize","minorTicks","slot","getSlot","slotX","slotY","y2","line","linePath","ticks","majorTicks","getMajorTickPositions","getMinorTickPositions","align","_alignLines","Pointer","newValue","_oldValue","repaint","LinearPointer","track","ref$1","trackSize","pointerHalfSize","space","pointerBox","pointerRangeBox","trackBox","shape","getElementOptions","_margin","ArrowLinearPointerAnimation","setup","axis","fromScale","toScale","duration","distanceTo","pos","translateX","translateY","translate","easing","current","register","Point$1","Path$3","ArrowLinearPointer","pointerShape","halfSize","sign","play","elementOptions","close","BarLinearPointerAnimation","Y","X","newPoints","oldPoints","abs","speed","_set","setter","toUpperCase","points","Group$3","Path$4","BarLinearPointer","dir","minSlot","sizeAxis","p1","p2","p3","p4","pointerPath","oldShape","group","renderTrack","trackOptions","toRect","DEFAULT_MIN_WIDTH","DEFAULT_MIN_HEIGHT","Group$1","LinearGauge","bboxX","bboxY","_shrinkScaleWidth","_getBox","_alignElements","_shrinkElements","_buildVisual","visuals","scaleElements","currentOptions","pointerType","boxCenter","center","plotAreaBox","wrap","scaleBox","diff","overflow","contentBox","shrink","alignTo","GEO_ARC_ADJUST_ANGLE","Arc","Path$5","Group$5","drawTicks","arc","tickAngles","unit","radius","getRadiusX","tickStart","pointAt","tickEnd","rotate","rangeSegment","RadialScale","renderArc","labelElements","repositionRanges","slotAngle","startAngle","endAngle","angle","result","hasRanges","ticksSize","labelsCount","labelsGroup","rangeDistance","labelsOptions","isInside","hasLabelElements","setRadiusX","setRadiusY","paddingWidth","paddingHeight","halfWidth","halfHeight","labelAngle","lp","cx","cos","cy","sin","labelPos","labelElement","prevLabelPos","labelTransform","union","rangeRadius","getRangeRadius","newRadius","_geometry","segments","rangeSegments","segmentsCount","segment","createRange","rangeGeom","radiusX","radiusY","defaultColor","rangePlaceholderColor","j","majorTickSize","tickArc","majorTickAngles","allTicks","minorTickSize","_tickDifference","minorTickAngles","normalizeTickAngles","angles","splice","ring","stepValue","tickCount","positions","repositionTicks","minor","newPoint","xDiff","anchor","yDiff","RadialPointerAnimation","animationOptions","newAngle","oldAngle","CAP_SIZE","Circle","Group$6","Path$6","RadialPointer","setAngle","_renderNeedle","_renderCap","capSize","cap","fromPoints","needleColor","needlePath","capColor","circle","arrow","Group$4","RadialGauge","_initialPlotArea","fitScale","alignScale","_buildPointers","getDiff","minDiff","midDiff","maxDiff","mid","oldDiff","staleFlag","getPlotBox","scaleArc","plotBbox","plotBox","plotBoxCenter","paddingX","paddingY","pointersArr","ArcScale","rangeLineCap","placeholderRangeAngle","geometry$$1","setEndAngle","setStartAngle","addRange","MAX_DURATION","RangePointerAnimation","startColor","get","currentColor","Color","r","g","b","toHex","RangePointer","abort","colors","currentValue","idx","ref$2","rangeColor","ArcGauge","centerLabelPosition","yLimit","bottomRight","defaultStartAngle","CircularGauge","jQuery","amdD","require","__webpack_module_cache__","moduleId","cachedModule","Error","__webpack_exports__"],"sources":["C:/Users/abodean/restapi-nodejs/client/app-router/node_modules/@progress/kendo-ui/js/dataviz/gauge/kendo-gauges.js"],"sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 87613:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/***********************************************************************\n * WARNING: this file is auto-generated.  If you change it directly,\n * your modifications will eventually be lost.  The source code is in\n * `kendo-charts` repository, you should make your changes there and\n * run `src-modules/sync.sh` in this repository.\n */\n(function(f, define) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(33877),\n        __webpack_require__(13298),\n        __webpack_require__(79174),\n        __webpack_require__(32549)\n    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(function() {\n\n(function($) {\n/* eslint-disable space-before-blocks, space-before-function-paren */\n\nwindow.kendo.dataviz = window.kendo.dataviz || {};\nvar dataviz = kendo.dataviz;\nvar getSpacing = dataviz.getSpacing;\nvar defined = dataviz.defined;\nvar constants = dataviz.constants;\nvar BLACK = constants.BLACK;\nvar COORD_PRECISION = constants.COORD_PRECISION;\nvar services = dataviz.services;\nvar deepExtend = dataviz.deepExtend;\nvar isArray = dataviz.isArray;\nvar setDefaultOptions = dataviz.setDefaultOptions;\nvar NumericAxis = dataviz.NumericAxis;\nvar limitValue = dataviz.limitValue;\nvar Box = dataviz.Box;\nvar interpolateValue = dataviz.interpolateValue;\nvar round = dataviz.round;\nvar drawing = kendo.drawing;\nvar DrawingGroup = drawing.Group;\nvar DrawingPath = drawing.Path;\nvar Animation = drawing.Animation;\nvar AnimationFactory = drawing.AnimationFactory;\nvar geometry = kendo.geometry;\nvar Rect = geometry.Rect;\nvar GeometryPoint = geometry.Point;\nvar transform = geometry.transform;\n\nvar ANGULAR_SPEED = 150;\nvar LINEAR_SPEED = 250;\nvar ARROW = \"arrow\";\nvar ARROW_POINTER = \"arrowPointer\";\nvar BAR_POINTER = \"barPointer\";\nvar DEFAULT_HEIGHT = 200;\nvar DEFAULT_LINE_WIDTH = 0.5;\nvar DEFAULT_WIDTH = 200;\nvar DEGREE = Math.PI / 180;\nvar INSIDE = \"inside\";\nvar LINEAR = \"linear\";\nvar OUTSIDE = \"outside\";\nvar RADIAL_POINTER = \"radialPointer\";\nvar RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\nfunction pad(bbox, value) {\n    var origin = bbox.getOrigin();\n    var size = bbox.getSize();\n    var spacing = getSpacing(value);\n\n    bbox.setOrigin([ origin.x - spacing.left, origin.y - spacing.top ]);\n    bbox.setSize([ size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom) ]);\n\n    return bbox;\n}\n\nvar Group = DrawingGroup;\nvar Path$1 = DrawingPath;\nvar Text = drawing.Text;\n\nfunction buildLabelElement(label, options) {\n    var labelBox = label.box;\n    var textBox = label.children[0].box;\n    var border = options.border || {};\n    var background = options.background || \"\";\n\n    var wrapper = Path$1.fromRect(new Rect([ labelBox.x1, labelBox.y1 ], [ labelBox.width(), labelBox.height() ]), {\n        stroke: {}\n    });\n\n    var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n        font: options.font,\n        fill: { color: options.color }\n    });\n\n    var styleGeometry = pad(text.bbox().clone(), options.padding);\n\n    var styleBox = Path$1.fromRect(styleGeometry, {\n        stroke: {\n            color: border.width ? border.color : \"\",\n            width: border.width,\n            opacity: border.opacity,\n            dashType: border.dashType,\n            lineJoin: \"round\",\n            lineCap: \"round\"\n        },\n        fill: {\n            color: background\n        }\n    });\n\n    var elements = new Group();\n    elements.append(wrapper);\n    elements.append(styleBox);\n    elements.append(text);\n\n    return elements;\n}\n\nfunction getRange(range, min, max) {\n    var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n    var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n\n    range.from = Math.max(Math.min(to, from), min);\n    range.to = Math.min(Math.max(to, from), max);\n\n    return range;\n}\n\nfunction unpad(bbox, value) {\n    var spacing = getSpacing(value);\n\n    spacing.left = -spacing.left; spacing.top = -spacing.top;\n    spacing.right = -spacing.right; spacing.bottom = -spacing.bottom;\n\n    return pad(bbox, spacing);\n}\n\nvar DEFAULT_MARGIN = 5;\nvar Path = DrawingPath;\nvar Surface = drawing.Surface;\n\nvar Gauge = dataviz.Class.extend({\n    init: function(element, userOptions, theme, context) {\n        if (context === void 0) { context = {}; }\n\n        this.element = element;\n        this.theme = theme;\n        this.contextService = new services.ChartService(this, context);\n        this._originalOptions = deepExtend({}, this.options, userOptions);\n        this.options = deepExtend({}, this._originalOptions);\n        this._initTheme(theme);\n\n        this.redraw();\n    },\n\n    destroy: function() {\n        if (this.surface) {\n            this.surface.destroy();\n            this.surface = null;\n        }\n\n        delete this.element;\n        delete this.surfaceElement;\n    },\n\n    value: function(pointerValue) {\n        var pointer = this.pointers[0];\n\n        if (arguments.length === 0) {\n            return pointer.value();\n        }\n\n        pointer.value(pointerValue);\n        this._setValueOptions(pointerValue);\n    },\n\n    _draw: function() {\n        var surface = this.surface;\n\n        surface.clear();\n        surface.draw(this._visuals);\n    },\n\n    exportVisual: function() {\n        return this._visuals;\n    },\n\n    allValues: function(values) {\n        var pointers = this.pointers;\n        var allValues = [];\n\n        if (arguments.length === 0) {\n            for (var i = 0; i < pointers.length; i++) {\n                allValues.push(pointers[i].value());\n            }\n\n            return allValues;\n        }\n\n        if (isArray(values)) {\n            for (var i$1 = 0; i$1 < values.length; i$1++) {\n                if (dataviz.isNumber(values[i$1])) {\n                    pointers[i$1].value(values[i$1]);\n                }\n            }\n        }\n\n        this._setValueOptions(values);\n    },\n\n    _setValueOptions: function(values) {\n        var pointers = [].concat(this.options.pointer);\n        var arrayValues = [].concat(values);\n\n        for (var i = 0; i < arrayValues.length; i++) {\n            pointers[i].value = arrayValues[i];\n        }\n    },\n\n    resize: function() {\n        this.noTransitionsRedraw();\n    },\n\n    noTransitionsRedraw: function() {\n        var transitions = this.options.transitions;\n\n        this._toggleTransitions(false);\n\n        this.redraw();\n\n        this._toggleTransitions(transitions);\n    },\n\n    redraw: function() {\n        var size = this._surfaceSize();\n        var wrapper = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._initSurface();\n\n        this.gaugeArea = this._createGaugeArea();\n\n        this._createModel();\n\n        var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n        this.reflow(bbox);\n    },\n\n    setOptions: function(options, theme) {\n        this._originalOptions = deepExtend(this._originalOptions, options);\n        this.options = deepExtend({}, this._originalOptions);\n\n        this._initTheme(theme);\n\n        this.redraw();\n    },\n\n    setDirection: function(rtl) {\n        this.contextService.rtl = Boolean(rtl);\n        if (this.surface && this.surface.type === 'svg') {\n            this.surface.destroy();\n            this.surface = null;\n        }\n    },\n\n    setIntlService: function(intl) {\n        this.contextService.intl = intl;\n    },\n\n    _initTheme: function(theme) {\n        var currentTheme = theme || this.theme || {};\n        this.theme = currentTheme;\n\n        this.options = deepExtend({}, currentTheme, this.options);\n        var options = this.options;\n        var pointer = options.pointer;\n\n        if (isArray(pointer)) {\n            var pointers = [];\n            for (var i = 0; i < pointer.length; i++) {\n                pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n            }\n            options.pointer = pointers;\n        }\n    },\n\n    _createGaugeArea: function() {\n        var options = this.options.gaugeArea;\n        var size = this.surface.size();\n        var border = options.border || {};\n        var areaGeometry = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n        if (border.width > 0) {\n            areaGeometry = unpad(areaGeometry, border.width);\n        }\n\n        var gaugeArea = Path.fromRect(areaGeometry, {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n            },\n            fill: {\n                color: options.background\n            }\n        });\n\n        return gaugeArea;\n    },\n\n    _initSurface: function() {\n        var ref = this;\n        var options = ref.options;\n        var surface = ref.surface;\n        var element = this._surfaceElement();\n        var size = this._surfaceSize();\n\n        dataviz.elementSize(element, size);\n\n        if (!surface || surface.options.type !== options.renderAs) {\n            if (surface) {\n                surface.destroy();\n            }\n\n            this.surface = Surface.create(element, {\n                type: options.renderAs\n            });\n        } else {\n            this.surface.clear();\n            this.surface.resize();\n        }\n    },\n\n    _surfaceSize: function() {\n        var options = this.options;\n        var size = this._getSize();\n\n        if (options.gaugeArea) {\n            deepExtend(size, options.gaugeArea);\n        }\n\n        return size;\n    },\n\n    _surfaceElement: function() {\n        if (!this.surfaceElement) {\n            this.surfaceElement = document.createElement('div');\n            this.element.appendChild(this.surfaceElement);\n        }\n\n        return this.surfaceElement;\n    },\n\n    getSize: function() {\n        return this._getSize();\n    },\n\n    _getSize: function() {\n        var element = this.element;\n        var defaultSize = this._defaultSize();\n        var width = element.offsetWidth;\n        var height = element.offsetHeight;\n\n        if (!width) {\n            width = defaultSize.width;\n        }\n\n        if (!height) {\n            height = defaultSize.height;\n        }\n\n        return { width: width, height: height };\n    },\n\n    _defaultSize: function() {\n        return {\n            width: DEFAULT_WIDTH,\n            height: DEFAULT_HEIGHT\n        };\n    },\n\n    _toggleTransitions: function(value) {\n        var this$1 = this;\n\n        this.options.transitions = value;\n        for (var i = 0; i < this.pointers.length; i++) {\n            this$1.pointers[i].options.animation.transitions = value;\n        }\n    }\n});\n\nsetDefaultOptions(Gauge, {\n    plotArea: {},\n    theme: \"default\",\n    renderAs: \"\",\n    pointer: {},\n    scale: {},\n    gaugeArea: {}\n});\n\nvar Path$2 = DrawingPath;\nvar Group$2 = DrawingGroup;\nvar Point = GeometryPoint;\n\nfunction renderAxisTick(tickRenderOptions, tickOptions) {\n    var position = tickRenderOptions.position;\n    var tickX = tickRenderOptions.tickX;\n    var tickY = tickRenderOptions.tickY;\n    var start, end;\n\n    if (tickRenderOptions.vertical) {\n        start = new Point(tickX, position);\n        end = new Point(tickX + tickOptions.size, position);\n    } else {\n        start = new Point(position, tickY);\n        end = new Point(position, tickY + tickOptions.size);\n    }\n\n    var tickPath = new Path$2({\n        stroke: {\n            color: tickOptions.color,\n            width: tickOptions.width\n        }\n    }).moveTo(start).lineTo(end);\n\n    return tickPath;\n}\n\nfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n    var count = tickPositions.length;\n\n    if (tickOptions.visible) {\n        var mirror = tickRenderOptions.mirror;\n        var lineBox = tickRenderOptions.lineBox;\n        for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n            if (i % tickOptions.skipUnit === 0) {\n                continue;\n            }\n\n            tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickRenderOptions.position = tickPositions[i];\n\n            tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n        }\n    }\n}\n\nvar LinearScale = NumericAxis.extend({\n    init: function(options, service) {\n        var scaleOptions = options || {};\n        if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n            scaleOptions = $.extend({}, scaleOptions, {\n                reverse: true\n            });\n        }\n\n        NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n\n        this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n    },\n\n    initUserOptions: function(options) {\n        var scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions = deepExtend({}, scaleOptions , { labels: { mirror: scaleOptions.mirror } });\n        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\n        return scaleOptions;\n    },\n\n    initFields: function() {\n    },\n\n    render: function() {\n        var elements = this.elements = new Group$2();\n        var labels = this.renderLabels();\n        var scaleLine = this.renderLine();\n        var scaleTicks = this.renderTicks();\n        var ranges = this.renderRanges();\n\n        elements.append(scaleLine, labels, scaleTicks, ranges);\n\n        return elements;\n    },\n\n    renderRanges: function() {\n        var this$1 = this;\n\n        var options = this.options;\n        var min = options.min;\n        var max = options.max;\n        var vertical = options.vertical;\n        var mirror = options.labels.mirror;\n        var ranges = options.ranges || [];\n        var elements = new Group$2();\n        var count = ranges.length;\n        var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n        for (var i = 0; i < count; i++) {\n            var range = getRange(ranges[i], min, max);\n            var slot = this$1.getSlot(range.from, range.to);\n            var slotX = vertical ? this$1.lineBox() : slot;\n            var slotY = vertical ? slot : this$1.lineBox();\n            if (vertical) {\n                slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n            } else {\n                slotY.y2 += rangeSize * (mirror ? -1 : 1);\n            }\n\n            elements.append(Path$2.fromRect(new Rect([ slotX.x1, slotY.y1 ], [ slotX.x2 - slotX.x1, slotY.y2 - slotY.y1 ]), {\n                fill: { color: range.color, opacity: range.opacity },\n                stroke: { }\n            }));\n        }\n\n        return elements;\n    },\n\n    renderLabels: function() {\n        var ref = this;\n        var labels = ref.labels;\n        var options = ref.options;\n        var elements = new Group$2();\n\n        for (var i = 0; i < labels.length; i++) {\n            elements.append(buildLabelElement(labels[i], options.labels));\n        }\n\n        return elements;\n    },\n\n    renderLine: function() {\n        var line = this.options.line;\n        var lineBox = this.lineBox();\n        var elements = new Group$2();\n\n        if (line.width > 0 && line.visible) {\n            var linePath = new Path$2({\n                stroke: {\n                    color: line.color,\n                    dashType: line.dashType,\n                    width: line.width\n                }\n            });\n\n            linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n            elements.append(linePath);\n        }\n\n        return elements;\n    },\n\n    renderTicks: function() {\n        var ticks = new Group$2();\n        var options = this.options;\n        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        var tickRenderOptions = {\n            vertical: options.vertical,\n            mirror: options.labels.mirror,\n            lineBox: this.lineBox()\n        };\n\n        renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n        renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n            skipUnit: majorUnit / options.minorUnit\n        }, options.minorTicks));\n\n        return ticks;\n    }\n});\n\nsetDefaultOptions(LinearScale, {\n    min: 0,\n    max: 50,\n\n    majorTicks: {\n        size: 15,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    line: {\n        width: DEFAULT_LINE_WIDTH\n    },\n\n    labels: {\n        position: INSIDE,\n        padding: 2\n    },\n    mirror: false,\n    _alignLines: false\n});\n\nvar Pointer = dataviz.Class.extend({\n    init: function(scale, userOptions) {\n\n        var ref = scale.options;\n        var min = ref.min;\n        var max = ref.max;\n        var options = this.options = deepExtend({}, this.options, userOptions);\n\n        options.fill = options.color;\n\n        this.scale = scale;\n\n        if (defined(options.value)) {\n            options.value = limitValue(options.value, min, max);\n        } else {\n            options.value = min;\n        }\n    },\n\n    value: function(newValue) {\n        var options = this.options;\n        var value = options.value;\n\n        if (arguments.length === 0) {\n            return value;\n        }\n\n        var ref = this.scale.options;\n        var min = ref.min;\n        var max = ref.max;\n\n        options._oldValue = defined(options._oldValue) ? options.value : min;\n        options.value = limitValue(newValue, min, max);\n\n        if (this.elements) {\n            this.repaint();\n        }\n    }\n});\n\nsetDefaultOptions(Pointer, {\n    color: BLACK\n});\n\nvar LinearPointer = Pointer.extend({\n    init: function(scale, options) {\n        Pointer.fn.init.call(this, scale, options);\n\n        this.options = deepExtend({\n            track: {\n                visible: defined(options.track)\n            }\n        }, this.options);\n    },\n\n    reflow: function() {\n        var ref = this;\n        var options = ref.options;\n        var scale = ref.scale;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var scaleLine = scale.lineBox();\n        var trackSize = options.track.size || options.size;\n        var pointerHalfSize = options.size / 2;\n        var margin = getSpacing(options.margin);\n        var space = vertical ?\n                 margin[mirror ? \"left\" : \"right\"] :\n                 margin[mirror ? \"bottom\" : \"top\"];\n        var pointerBox, pointerRangeBox, trackBox;\n\n        space = mirror ? -space : space;\n\n        if (vertical) {\n            trackBox = new Box(\n                scaleLine.x1 + space, scaleLine.y1,\n                scaleLine.x1 + space, scaleLine.y2);\n\n            if (mirror) {\n                trackBox.x1 -= trackSize;\n            } else {\n                trackBox.x2 += trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(\n                    scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize,\n                    scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize\n                );\n                pointerBox = pointerRangeBox;\n            }\n        } else {\n            trackBox = new Box(\n                scaleLine.x1, scaleLine.y1 - space,\n                scaleLine.x2, scaleLine.y1 - space);\n\n            if (mirror) {\n                trackBox.y2 += trackSize;\n            } else {\n                trackBox.y1 -= trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new Box(\n                    scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space,\n                    scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space\n                );\n                pointerBox = pointerRangeBox;\n            }\n        }\n\n        this.trackBox = trackBox;\n        this.pointerRangeBox = pointerRangeBox;\n        this.box = pointerBox || trackBox.clone().pad(options.border.width);\n    },\n\n    getElementOptions: function() {\n        var options = this.options;\n\n        return {\n            fill: {\n                color: options.color,\n                opacity: options.opacity\n            },\n            stroke: defined(options.border) ? {\n                color: options.border.width ? options.border.color || options.color : \"\",\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: options.opacity\n            } : null\n        };\n    },\n\n    _margin: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var margin = getSpacing(options.margin);\n\n        var space = vertical ?\n            margin[mirror ? \"left\" : \"right\"] :\n            margin[mirror ? \"bottom\" : \"top\"];\n\n        return space;\n    }\n});\n\nsetDefaultOptions(LinearPointer, {\n    shape: BAR_POINTER,\n\n    track: {\n        border: {\n            width: 1\n        }\n    },\n\n    color: BLACK,\n    border: {\n        width: 1\n    },\n    opacity: 1,\n\n    margin: getSpacing(3),\n    animation: {\n        type: BAR_POINTER\n    },\n    visible: true\n});\n\nvar ArrowLinearPointerAnimation = Animation.extend({\n    setup: function() {\n        var options = this.options;\n        var margin = options.margin;\n        var from = options.from;\n        var to = options.to;\n        var vertical = options.vertical;\n        var axis = vertical ? \"x1\" : \"y1\";\n\n        if (options.mirror === vertical) {\n            from[axis] -= margin; to[axis] -= margin;\n        } else {\n            from[axis] += margin; to[axis] += margin;\n        }\n\n        var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n        var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((fromScale.distanceTo(toScale) / options.duration) * 1000, 1);\n        }\n    },\n\n    step: function(pos) {\n        var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n        var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n\n        this.element.transform(transform().translate(translateX, translateY));\n    }\n});\n\nsetDefaultOptions(ArrowLinearPointerAnimation, {\n    easing: LINEAR,\n    duration: LINEAR_SPEED\n});\n\nAnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n\nvar Point$1 = GeometryPoint;\nvar Path$3 = DrawingPath;\n\nvar ArrowLinearPointer = LinearPointer.extend({\n    init: function(scale, options) {\n        LinearPointer.fn.init.call(this, scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.6;\n        }\n    },\n\n    pointerShape: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var size = ref.options.size;\n        var halfSize = size / 2;\n        var sign = (scale.options.mirror ? -1 : 1);\n        var shape;\n\n        if (scale.options.vertical) {\n            shape = [\n                new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)\n            ];\n        } else {\n            shape = [\n                new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)\n            ];\n        }\n\n        return shape;\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n            vertical: scale.options.vertical,\n            mirror: scale.options.mirror,\n            margin: this._margin(options.margin),\n            from: scale.getSlot(options._oldValue),\n            to: scale.getSlot(options.value)\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    },\n\n    render: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var elementOptions = this.getElementOptions();\n        var shape = this.pointerShape(options.value);\n\n        options.animation.type = ARROW_POINTER;\n\n        var elements = new Path$3({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n\n        var slot = scale.getSlot(options.value);\n        elements.transform(transform().translate(slot.x1, slot.y1));\n\n        this.elements = elements;\n\n        return elements;\n    }\n});\n\nvar BarLinearPointerAnimation = Animation.extend({\n    setup: function() {\n        var options = this.options;\n        var axis = this.axis = options.vertical ? constants.Y : constants.X;\n        var to = this.to = options.newPoints[0][axis];\n        var from = this.from = options.oldPoints[0][axis];\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((Math.abs(to - from) / options.speed) * 1000, 1);\n        }\n\n        this._set(from);\n    },\n\n    step: function(pos) {\n        var value = interpolateValue(this.from, this.to, pos);\n        this._set(value);\n    },\n\n    _set: function(value) {\n        var setter = \"set\" + this.axis.toUpperCase();\n        var points = this.options.newPoints;\n\n        points[0][setter](value);\n        points[1][setter](value);\n    }\n});\n\nsetDefaultOptions(BarLinearPointerAnimation, {\n    easing: LINEAR,\n    speed: LINEAR_SPEED\n});\n\nAnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n\nvar Group$3 = DrawingGroup;\nvar Path$4 = DrawingPath;\n\nvar BarLinearPointer = LinearPointer.extend({\n    init: function(scale, options) {\n        LinearPointer.fn.init.call(this, scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.3;\n        }\n    },\n\n    pointerShape: function(value) {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var ref$1 = scale.options;\n        var mirror = ref$1.mirror;\n        var vertical = ref$1.vertical;\n        var dir = mirror === vertical ? -1 : 1;\n        var size = options.size * dir;\n        var minSlot = scale.getSlot(scale.options.min);\n        var slot = scale.getSlot(value);\n        var axis = vertical ? constants.Y : constants.X;\n        var sizeAxis = vertical ? constants.X : constants.Y;\n        var margin = this._margin() * dir;\n\n        var p1 = new GeometryPoint();\n        p1[axis] = minSlot[axis + \"1\"];\n        p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n\n        var p2 = new GeometryPoint();\n        p2[axis] = slot[axis + \"1\"];\n        p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n        if (vertical) {\n            p1.translate(margin, 0);\n            p2.translate(margin, 0);\n        } else {\n            p1.translate(0, margin);\n            p2.translate(0, margin);\n        }\n\n        var p3 = p2.clone();\n        var p4 = p1.clone();\n\n        if (vertical) {\n            p3.translate(size, 0);\n            p4.translate(size, 0);\n        } else {\n            p3.translate(0, size);\n            p4.translate(0, size);\n        }\n\n        return [ p1, p2, p3, p4 ];\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var shape = this.pointerShape(options.value);\n        var pointerPath = this.pointerPath;\n        var oldShape = this.pointerShape(options._oldValue);\n\n        pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n        var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n            reverse: scale.options.reverse,\n            vertical: scale.options.vertical,\n            oldPoints: [ oldShape[1], oldShape[2] ],\n            newPoints: [ shape[1], shape[2] ]\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    },\n\n    render: function() {\n        var group = new Group$3();\n        var elementOptions = this.getElementOptions();\n\n        if (this.options.track.visible) {\n            group.append(this.renderTrack());\n        }\n\n        var pointer = this.pointerPath = new Path$4({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        });\n\n        group.append(pointer);\n\n        this.elements = group;\n\n        return group;\n    },\n\n    renderTrack: function() {\n        var trackOptions = this.options.track;\n        var border = trackOptions.border || {};\n        var trackBox = this.trackBox.clone().pad(border.width || 0);\n\n        return new Path$4.fromRect(trackBox.toRect(), {\n            fill: {\n                color: trackOptions.color,\n                opacity: trackOptions.opacity\n            },\n            stroke: {\n                color: border.width ? border.color || trackOptions.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            }\n        });\n    }\n});\n\nvar DEFAULT_MIN_WIDTH = 60;\nvar DEFAULT_MIN_HEIGHT = 60;\n\nvar Group$1 = DrawingGroup;\n\nvar LinearGauge = Gauge.extend({\n    reflow: function(bbox) {\n        var pointers = this.pointers;\n        var bboxX = bbox.origin.x;\n        var bboxY = bbox.origin.y;\n\n        var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n\n        this.scale.reflow(box);\n        this._shrinkScaleWidth(box);\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow();\n        }\n\n        this.bbox = this._getBox(box);\n        this._alignElements();\n        this._shrinkElements();\n        this._buildVisual();\n        this._draw();\n    },\n\n    _buildVisual: function() {\n        var visuals = new Group$1();\n        var scaleElements = this.scale.render();\n        var pointers = this.pointers;\n\n        visuals.append(this.gaugeArea);\n        visuals.append(scaleElements);\n\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            visuals.append(current.render());\n            current.value(current.options.value);\n        }\n\n        this._visuals = visuals;\n    },\n\n    _createModel: function() {\n        var this$1 = this;\n\n        var options = this.options;\n        var scale = this.scale = new LinearScale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        var pointers = options.pointer;\n        pointers = isArray(pointers) ? pointers : [ pointers ];\n\n        for (var i = 0; i < pointers.length; i++) {\n            var currentOptions = deepExtend({}, pointers[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            });\n            var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n\n            this$1.pointers.push(new pointerType(scale, currentOptions));\n        }\n    },\n\n    _defaultSize: function() {\n        var vertical = this.options.scale.vertical;\n\n        return {\n            width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n            height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n        };\n    },\n\n    _getBox: function(box) {\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var boxCenter = box.center();\n        var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n        for (var i = 0; i < pointers.length; i++) {\n            plotAreaBox.wrap(pointers[i].box.clone());\n        }\n\n        var size;\n        if (scale.options.vertical) {\n            size = plotAreaBox.width() / 2;\n            plotAreaBox = new Box(\n                boxCenter.x - size, box.y1,\n                boxCenter.x + size, box.y2\n            );\n        } else {\n            size = plotAreaBox.height() / 2;\n            plotAreaBox = new Box(\n                box.x1, boxCenter.y - size,\n                box.x2, boxCenter.y + size\n            );\n        }\n\n        return plotAreaBox;\n    },\n\n    _alignElements: function() {\n        var this$1 = this;\n\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var scaleBox = scale.box;\n        var box = pointers[0].box.clone().wrap(scale.box);\n        var plotAreaBox = this.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            box.wrap(pointers[i].box.clone());\n        }\n\n        var diff;\n        if (scale.options.vertical) {\n            diff = plotAreaBox.center().x - box.center().x;\n            scale.reflow(new Box(\n                scaleBox.x1 + diff, plotAreaBox.y1,\n                scaleBox.x2 + diff, plotAreaBox.y2\n            ));\n        } else {\n            diff = plotAreaBox.center().y - box.center().y;\n            scale.reflow(new Box(\n                scaleBox.x1, scaleBox.y1 + diff,\n                scaleBox.x2, scaleBox.y2 + diff\n            ));\n        }\n\n        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n            pointers[i$1].reflow(this$1.bbox);\n        }\n    },\n\n    _shrinkScaleWidth: function(bbox) {\n        var ref = this;\n        var scale = ref.scale;\n        if (!scale.options.vertical) {\n            var overflow = scale.contentBox().width() - bbox.width();\n            if (overflow > 0) {\n                scale.box.shrink(overflow, 0);\n                scale.box.alignTo(bbox, 'center');\n                scale.reflow(scale.box);\n            }\n        }\n    },\n\n    _shrinkElements: function() {\n        var this$1 = this;\n\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n        var scaleBox = scale.box.clone();\n        var pos = scale.options.vertical ? \"y\" : \"x\";\n        var pointerBox = pointers[0].box;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointerBox.wrap(pointers[i].box.clone());\n        }\n\n        scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n        scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n\n        scale.reflow(scaleBox);\n\n        for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n            pointers[i$1].reflow(this$1.bbox);\n        }\n    }\n});\n\nsetDefaultOptions(LinearGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    },\n    scale: {\n        vertical: true\n    }\n});\n\nvar GEO_ARC_ADJUST_ANGLE = 180;\n\nvar Arc = drawing.Arc;\nvar Path$5 = DrawingPath;\nvar Group$5 = DrawingGroup;\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n    var ticks = new Group$5();\n    var center = arc.center;\n    var radius = arc.getRadiusX();\n\n    if (tickOptions.visible) {\n        for (var i = 0; i < tickAngles.length; i++) {\n            var tickStart = arc.pointAt(tickAngles[i]);\n            var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n            ticks.append(new Path$5({\n                stroke: {\n                    color: tickOptions.color,\n                    width: tickOptions.width\n                }\n            }).moveTo(tickStart).lineTo(tickEnd));\n        }\n    }\n\n    return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n    return { from: from, to: to, color: color, opacity: opacity };\n}\n\nvar RadialScale = NumericAxis.extend({\n    init: function(options, service) {\n        NumericAxis.fn.init.call(this, 0, 1, options, service);\n    },\n\n    initUserOptions: function(options) {\n        var scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n        scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n        return scaleOptions;\n    },\n\n    initFields: function() {\n    },\n\n    render: function(center, radius) {\n        var arc = this.renderArc(center, radius);\n\n        this.bbox = arc.bbox();\n        this.labelElements = this.renderLabels();\n        this.ticks = this.renderTicks();\n        this.ranges = this.renderRanges();\n    },\n\n    reflow: function(bbox) {\n        var center = bbox.center();\n        var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n        if (defined(this.bbox)) {\n            this.bbox = this.arc.bbox();\n            this.radius(this.arc.getRadiusX());\n            this.repositionRanges();\n            this.renderLabels();\n        } else {\n            return this.render(center, radius);\n        }\n    },\n\n    slotAngle: function(value) {\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var reverse = ref.reverse;\n        var startAngle = ref.startAngle;\n        var endAngle = ref.endAngle;\n        var angle = endAngle - startAngle;\n        var result;\n\n        if (reverse) {\n            result = endAngle - (value - min) / (max - min) * angle;\n        } else {\n            result = ((value - min) / (max - min) * angle) + startAngle;\n        }\n\n        return result + GEO_ARC_ADJUST_ANGLE;\n    },\n\n    hasRanges: function() {\n        var ranges = this.options.ranges;\n\n        return ranges && ranges.length;\n    },\n\n    ticksSize: function() {\n        var ref = this.options;\n        var majorTicks = ref.majorTicks;\n        var minorTicks = ref.minorTicks;\n        var size = 0;\n        if (majorTicks.visible) {\n            size = majorTicks.size;\n        }\n\n        if (minorTicks.visible) {\n            size = Math.max(minorTicks.size, size);\n        }\n\n        return size;\n    },\n\n    labelsCount: function() {\n        var count = NumericAxis.fn.labelsCount.call(this);\n        var options = this.options;\n        var angle = options.endAngle - options.startAngle;\n\n        if (angle >= 360 && (options.max % options.majorUnit === 0)) {\n            count -= 1;\n        }\n\n        return count;\n    },\n\n    renderLabels: function() {\n        var this$1 = this;\n\n        var options = this.options;\n        var arc = this.arc.clone();\n        var radius = arc.getRadiusX();\n        var tickAngles = this.tickAngles(arc, options.majorUnit);\n        var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n        var labelsGroup = new Group$5();\n\n        var rangeDistance = radius * 0.05;\n        if (defined(options.rangeDistance)) {\n            rangeDistance = options.rangeDistance;\n        } else {\n            options.rangeDistance = rangeDistance;\n        }\n\n        var labelsOptions = options.labels;\n        var isInside = labelsOptions.position === INSIDE;\n        var hasLabelElements = defined(this.labelElements);\n\n        if (isInside) {\n            radius -= this.ticksSize();\n\n            if (this.hasRanges() && !hasLabelElements) {\n                radius -= rangeSize + rangeDistance;\n            }\n            arc.setRadiusX(radius).setRadiusY(radius);\n        }\n\n        var labels = this.labels;\n        var count = labels.length;\n        var padding = getSpacing(labelsOptions.padding);\n        var paddingWidth = (padding.left + padding.right) / 2;\n        var paddingHeight = (padding.top + padding.bottom) / 2;\n\n        for (var i = 0; i < count; i++) {\n            var label = labels[i];\n            var halfWidth = label.box.width() / 2;\n            var halfHeight = label.box.height() / 2;\n            var angle = tickAngles[i];\n            var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n            var lp = arc.pointAt(angle);\n            var cx = lp.x + (Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1));\n            var cy = lp.y + (Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1));\n\n            label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n            var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n\n            var labelElement = (void 0);\n            if (!hasLabelElements) {\n                labelElement = buildLabelElement(label, options.labels);\n                labelsGroup.append(labelElement);\n            } else {\n                labelElement = this$1.labelElements.children[i];\n                var prevLabelPos = labelElement.bbox().origin;\n\n                var labelTransform = labelElement.transform() || transform();\n                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                labelElement.transform(labelTransform);\n            }\n\n            this$1.bbox = Rect.union(this$1.bbox, labelElement.bbox());\n        }\n\n        return labelsGroup;\n    },\n\n    repositionRanges: function() {\n        var ranges = this.ranges.children;\n\n        if (ranges.length > 0) {\n            var ref = this.options;\n            var rangeDistance = ref.rangeDistance;\n            var rangeSize = ref.rangeSize;\n            var rangeRadius = this.getRangeRadius();\n\n            if (this.options.labels.position === INSIDE) {\n                rangeRadius += rangeSize + rangeDistance;\n            }\n\n            var newRadius = rangeRadius + (rangeSize / 2);\n\n            for (var i = 0; i < ranges.length; i++) {\n                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n            }\n\n            this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n        }\n    },\n\n    renderRanges: function() {\n        var this$1 = this;\n\n        var segments = this.rangeSegments();\n        var segmentsCount = segments.length;\n        var result = new Group$5();\n\n        if (segmentsCount) {\n            var ref = this.options;\n            var rangeSize = ref.rangeSize;\n            var reverse = ref.reverse;\n            var rangeDistance = ref.rangeDistance;\n            var rangeRadius = this.getRangeRadius();\n\n            // move the ticks with a range distance and a range size\n            this.radius(this.radius() - rangeSize - rangeDistance);\n\n            for (var i = 0; i < segmentsCount; i++) {\n                var segment = segments[i];\n                var from = this$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                var to = this$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                if (to - from !== 0) {\n                    result.append(this$1.createRange(from, to, rangeRadius, segment));\n                }\n            }\n        }\n\n        return result;\n    },\n\n    createRange: function(startAngle, endAngle, rangeRadius, options) {\n        var rangeSize = this.options.rangeSize;\n        var rangeGeom = new geometry.Arc(this.arc.center, {\n            radiusX: rangeRadius + (rangeSize / 2),\n            radiusY: rangeRadius + (rangeSize / 2),\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n\n        return new Arc(rangeGeom, {\n            stroke: {\n                width: rangeSize,\n                color: options.color,\n                opacity: options.opacity,\n                lineCap: options.lineCap\n            }\n        });\n    },\n\n    rangeSegments: function() {\n        var options = this.options;\n        var ranges = options.ranges || [];\n        var count = ranges.length;\n        var segments = [];\n\n        if (count) {\n            var min = options.min;\n            var max = options.max;\n            var defaultColor = options.rangePlaceholderColor;\n            segments.push(rangeSegment(min, max, defaultColor));\n\n            for (var i = 0; i < count; i++) {\n                var range = getRange(ranges[i], min, max);\n                var segmentsCount = segments.length;\n\n                for (var j = 0; j < segmentsCount; j++) {\n                    var segment = segments[j];\n\n                    if (segment.from <= range.from && range.from <= segment.to) {\n                        segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                        if (segment.from <= range.to && range.to <= segment.to) {\n                            segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                        }\n\n                        segment.to = range.from;\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        return segments;\n    },\n\n    getRangeRadius: function() {\n        var ref = this;\n        var arc = ref.arc;\n        var options = ref.options;\n        var rangeSize = options.rangeSize;\n        var rangeDistance = options.rangeDistance;\n        var majorTickSize = options.majorTicks.size;\n        var radius;\n\n        if (options.labels.position === OUTSIDE) {\n            radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n        } else {\n            radius = arc.getRadiusX() - rangeSize;\n        }\n\n        return radius;\n    },\n\n    renderArc: function(center, radius) {\n        var options = this.options;\n\n        var arc = this.arc = new geometry.Arc(center, {\n            radiusX: radius,\n            radiusY: radius,\n            startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n            endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n        });\n\n        return arc;\n    },\n\n    renderTicks: function() {\n        var ref = this;\n        var arc = ref.arc;\n        var options = ref.options;\n        var tickArc = arc.clone();\n\n        this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n        this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n        var allTicks = new Group$5();\n        allTicks.append(this.majorTicks);\n\n        var majorTickSize = options.majorTicks.size;\n        var minorTickSize = options.minorTicks.size;\n\n        this._tickDifference = majorTickSize - minorTickSize;\n\n        if (options.labels.position === OUTSIDE) {\n            var radius = tickArc.getRadiusX();\n            tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n                   .setRadiusY(radius - majorTickSize + minorTickSize);\n        }\n\n        this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n        this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n        allTicks.append(this.minorTicks);\n\n        return allTicks;\n    },\n\n    normalizeTickAngles: function(angles) {\n        var options = this.options;\n        var skip = options.majorUnit / options.minorUnit;\n\n        for (var i = angles.length - 1; i >= 0; i--) {\n            if (i % skip === 0) {\n                angles.splice(i, 1);\n            }\n        }\n\n        return angles;\n    },\n\n    tickAngles: function(ring, stepValue) {\n        var options = this.options;\n        var reverse = options.reverse;\n        var range = options.max - options.min;\n        var angle = ring.endAngle - ring.startAngle;\n        var tickCount = range / stepValue;\n        var pos = ring.startAngle;\n        var step = angle / tickCount;\n\n        if (reverse) {\n            pos += angle;\n            step = -step;\n        }\n\n        if (angle >= 360 && (options.max % stepValue === 0)) {\n            tickCount -= 1;\n        }\n\n        var positions = [];\n        for (var i = 0; i < tickCount; i++) {\n            positions.push(round(pos, COORD_PRECISION));\n            pos += step;\n        }\n\n        if (round(pos) <= ring.endAngle) {\n            positions.push(pos);\n        }\n\n        return positions;\n    },\n\n    radius: function(value) {\n        if (value) {\n            this.arc.setRadiusX(value).setRadiusY(value);\n            this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n            this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n        } else {\n            return this.arc.getRadiusX();\n        }\n    },\n\n    repositionTicks: function(ticks, tickAngles, minor) {\n        var diff = minor ? (this._tickDifference || 0) : 0;\n        var tickArc = this.arc;\n        var radius = tickArc.getRadiusX();\n\n        if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n            tickArc = this.arc.clone();\n            tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n        }\n\n        for (var i = 0; i < ticks.length; i++) {\n            var newPoint = tickArc.pointAt(tickAngles[i]);\n            var segments = ticks[i].segments;\n            var xDiff = newPoint.x - segments[0].anchor().x;\n            var yDiff = newPoint.y - segments[0].anchor().y;\n\n            ticks[i].transform(new transform().translate(xDiff, yDiff));\n        }\n    }\n});\n\nsetDefaultOptions(RadialScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        size: 15,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    startAngle: -30,\n    endAngle: 210,\n\n    labels: {\n        position: INSIDE,\n        padding: 2\n    }\n});\n\nvar RadialPointerAnimation = Animation.extend({\n    init: function(element, options) {\n        Animation.fn.init.call(this, element, options);\n\n        var animationOptions = this.options;\n\n        animationOptions.duration = Math.max((Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000, 1);\n    },\n\n    step: function(pos) {\n        var options = this.options;\n        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\n        this.element.transform(transform().rotate(angle, options.center));\n    }\n});\n\nsetDefaultOptions(RadialPointerAnimation, {\n    easing: LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nAnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n\nvar CAP_SIZE = 0.05;\nvar Circle = drawing.Circle;\nvar Group$6 = DrawingGroup;\nvar Path$6 = DrawingPath;\n\nvar RadialPointer = Pointer.extend({\n    setAngle: function(angle) {\n        this.elements.transform(transform().rotate(angle, this.center));\n    },\n\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var oldAngle = scale.slotAngle(options._oldValue);\n        var newAngle = scale.slotAngle(options.value);\n\n        if (options.animation.transitions === false) {\n            this.setAngle(newAngle);\n        } else {\n            new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            })).play();\n        }\n    },\n\n    render: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var elements = new Group$6();\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        elements.append(this._renderNeedle(), this._renderCap());\n\n        this.elements = elements;\n        this.setAngle(DEGREE);\n\n        return elements;\n    },\n\n    reflow: function(arc) {\n        var center = this.center = arc.center;\n        var length = limitValue(this.options.length || 1, 0.1, 1.5);\n        var radius = this.radius = arc.getRadiusX() * length;\n        var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n\n        this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize),\n                                    new GeometryPoint(center.x + capSize, center.y + capSize));\n    },\n\n    _renderNeedle: function() {\n        var minorTickSize = this.scale.options.minorTicks.size;\n        var center = this.center;\n        var needleColor = this.options.color;\n\n        var needlePath = new Path$6({\n            fill: { color: needleColor },\n            stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }\n        });\n\n        needlePath.moveTo(center.x + this.radius - minorTickSize, center.y)\n                  .lineTo(center.x, center.y - (this.capSize / 2))\n                  .lineTo(center.x, center.y + (this.capSize / 2))\n                  .close();\n\n        return needlePath;\n    },\n\n    _renderCap: function() {\n        var options = this.options;\n        var capColor = options.cap.color || options.color;\n        var circle = new geometry.Circle(this.center, this.capSize);\n\n        var cap = new Circle(circle, {\n            fill: { color: capColor },\n            stroke: { color: capColor }\n        });\n\n        return cap;\n    }\n});\n\nsetDefaultOptions(RadialPointer, {\n    cap: {\n        size: CAP_SIZE\n    },\n    arrow: {\n        width: 16,\n        height: 14\n    },\n    animation: {\n        type: RADIAL_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\nvar Group$4 = DrawingGroup;\n\nvar RadialGauge = Gauge.extend({\n    reflow: function(bbox) {\n        var this$1 = this;\n\n        var pointers = this.pointers;\n        this.scale.reflow(bbox);\n        this._initialPlotArea = this.scale.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(this$1.scale.arc);\n            this$1._initialPlotArea = Rect.union(this$1._initialPlotArea, pointers[i].bbox);\n        }\n\n        this.fitScale(bbox);\n        this.alignScale(bbox);\n        this._buildVisual(this.gaugeArea, pointers, this.scale);\n        this._draw();\n    },\n\n    _buildVisual: function(gaugeArea, pointers, scale) {\n        var visuals = this._visuals = new Group$4();\n\n        visuals.append(gaugeArea);\n        visuals.append(scale.ticks);\n        visuals.append(scale.ranges);\n        this._buildPointers(pointers);\n        visuals.append(scale.labelElements);\n    },\n\n    _buildPointers: function(pointers) {\n        var this$1 = this;\n\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            current.render();\n            this$1._visuals.append(current.elements);\n\n            current.value(current.options.value);\n        }\n    },\n\n    fitScale: function(bbox) {\n        var this$1 = this;\n\n        var arc = this.scale.arc;\n        var plotAreaBox = this._initialPlotArea;\n        var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n        var min = round(step, COORD_PRECISION);\n        var max = round(-step, COORD_PRECISION);\n        var minDiff, midDiff, maxDiff, mid, oldDiff;\n        var staleFlag = 0;\n        var i = 0;\n\n        while (i++ < 100) {\n            staleFlag = (oldDiff === maxDiff) ? (staleFlag + 1) : 0;\n\n            if (staleFlag > 5) {\n                break;\n            }\n\n            if (min !== mid) {\n                minDiff = this$1.getPlotBox(min, bbox, arc);\n                if (0 <= minDiff && minDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (max !== mid) {\n                maxDiff = this$1.getPlotBox(max, bbox, arc);\n                if (0 <= maxDiff && maxDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (minDiff > 0 && maxDiff > 0) {\n                mid = min * 2;\n            } else if (minDiff < 0 && maxDiff < 0) {\n                mid = max * 2;\n            } else {\n                mid = round(((min + max) / 2) || 1, COORD_PRECISION);\n            }\n\n            midDiff = this$1.getPlotBox(mid, bbox, arc);\n            if (0 <= midDiff && midDiff <= 2) {\n                break;\n            }\n\n            oldDiff = maxDiff;\n\n            if (midDiff > 0) {\n                max = mid;\n                maxDiff = midDiff;\n            } else {\n                min = mid;\n                minDiff = midDiff;\n            }\n        }\n    },\n\n    getPlotBox: function(step, bbox, arc) {\n        var this$1 = this;\n\n        var scale = this.scale;\n        var pointers = this.pointers;\n        var radius = arc.getRadiusX();\n        var scaleArc = arc.clone();\n\n        scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n\n        scale.arc = scaleArc;\n        scale.reflow(bbox);\n        this.plotBbox = scale.bbox;\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scaleArc);\n            this$1.plotBbox = Rect.union(this$1.plotBbox, pointers[i].bbox);\n        }\n\n        return this.getDiff(this.plotBbox, bbox);\n    },\n\n    getDiff: function(plotBox, box) {\n        return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n    },\n\n    alignScale: function(bbox) {\n        var this$1 = this;\n\n        var plotBoxCenter = this.plotBbox.center();\n        var boxCenter = bbox.center();\n        var paddingX = plotBoxCenter.x - boxCenter.x;\n        var paddingY = plotBoxCenter.y - boxCenter.y;\n        var ref = this;\n        var scale = ref.scale;\n        var pointers = ref.pointers;\n\n        scale.arc.center.x -= paddingX;\n        scale.arc.center.y -= paddingY;\n\n        scale.reflow(bbox);\n\n        for (var i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scale.arc);\n            this$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n        }\n    },\n\n    _createModel: function() {\n        var this$1 = this;\n\n        var options = this.options;\n        var pointers = options.pointer;\n        var scale = this.scale = new RadialScale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        var pointersArr = isArray(pointers) ? pointers : [ pointers ];\n        for (var i = 0; i < pointersArr.length; i++) {\n            var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            }));\n\n            this$1.pointers.push(current);\n        }\n    }\n});\n\nsetDefaultOptions(RadialGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    }\n});\n\nvar ArcScale = RadialScale.extend({\n    rangeSegments: function() {\n        var ref = this.options;\n        var min = ref.min;\n        var max = ref.max;\n        var rangePlaceholderColor = ref.rangePlaceholderColor;\n        var rangeLineCap = ref.rangeLineCap;\n\n        return [ { from: min, to: max, color: rangePlaceholderColor, lineCap: rangeLineCap } ];\n    },\n\n    hasRanges: function() {\n        return true;\n    },\n\n    placeholderRangeAngle: function(angle) {\n        var geometry$$1 = this.ranges.children[0].geometry();\n\n        if (this.options.reverse) {\n            geometry$$1.setEndAngle(angle);\n        } else {\n            geometry$$1.setStartAngle(angle);\n        }\n    },\n\n    addRange: function(from, to, options) {\n        var reverse = this.options.reverse;\n\n        var startAngle = this.slotAngle(reverse ? to : from);\n        var endAngle = this.slotAngle(reverse ? from : to);\n\n        var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n\n        this.ranges.append(range);\n\n        return range;\n    }\n});\n\nsetDefaultOptions(ArcScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        visible: false\n    },\n\n    minorTicks: {\n        visible: false\n    },\n\n    labels: {\n        visible: false\n    },\n\n    startAngle: 0,\n    endAngle: 180,\n    rangeLineCap: 'round'\n});\n\nvar MAX_DURATION = 800;\n\nvar RangePointerAnimation = Animation.extend({\n    init: function(element, options) {\n        Animation.fn.init.call(this, element, options);\n\n        var animationOptions = this.options;\n        var duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n        animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n        var startColor = element.elements.options.get(\"stroke.color\");\n        var color = element.currentColor();\n        if (startColor !== color) {\n            this.startColor = new kendo.Color(startColor);\n            this.color = new kendo.Color(color);\n        }\n    },\n\n    step: function(pos) {\n        var ref = this;\n        var options = ref.options;\n        var startColor = ref.startColor;\n        var color = ref.color;\n        var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n        this.element.angle(angle);\n\n        if (color) {\n            var r = round(interpolateValue(startColor.r, color.r, pos));\n            var g = round(interpolateValue(startColor.g, color.g, pos));\n            var b = round(interpolateValue(startColor.b, color.b, pos));\n\n            this.element.stroke(new kendo.Color(r, g, b).toHex());\n        }\n    }\n});\n\nsetDefaultOptions(RangePointerAnimation, {\n    easing: LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nAnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n\nvar RangePointer = Pointer.extend({\n    repaint: function() {\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n        var oldAngle = scale.slotAngle(options._oldValue);\n        var newAngle = scale.slotAngle(options.value);\n\n        if (this.animation) {\n            this.animation.abort();\n        }\n\n        if (options.animation.transitions === false) {\n            this.angle(newAngle);\n            this.stroke(this.currentColor());\n        } else {\n            this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            }));\n\n            this.animation.play();\n        }\n    },\n\n    angle: function(value) {\n        var geometry$$1 = this.elements.geometry();\n        if (this.scale.options.reverse) {\n            geometry$$1.setStartAngle(value);\n        } else {\n            geometry$$1.setEndAngle(value);\n        }\n        this.scale.placeholderRangeAngle(value);\n    },\n\n    stroke: function(value) {\n        this.elements.stroke(value);\n    },\n\n    render: function() {\n        if (this.elements) {\n            return;\n        }\n\n        var ref = this;\n        var scale = ref.scale;\n        var options = ref.options;\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        this.elements = scale.addRange(scale.options.min, this.options.value, {\n            color: this.currentColor(),\n            opacity: options.opacity,\n            lineCap: scale.options.rangeLineCap\n        });\n    },\n\n    currentColor: function() {\n        var ref = this.scale.options;\n        var min = ref.min;\n        var max = ref.max;\n        var ref$1 = this.options;\n        var colors = ref$1.colors;\n        var color = ref$1.color;\n        var value = ref$1.value;\n        var currentValue = dataviz.isNumber(value) ? value : min;\n\n        if (colors) {\n            for (var idx = 0; idx < colors.length; idx++) {\n                var ref$2 = colors[idx];\n                var rangeColor = ref$2.color;\n                var from = ref$2.from; if (from === void 0) { from = min; }\n                var to = ref$2.to; if (to === void 0) { to = max; }\n\n                if (from <= currentValue && currentValue <= to) {\n                    return rangeColor;\n                }\n            }\n        }\n\n        return color;\n    },\n\n    reflow: function() {\n        this.render();\n\n        this.bbox = this.elements.bbox();\n    }\n});\n\nsetDefaultOptions(RangePointer, {\n    animation: {\n        type: RADIAL_RANGE_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\nvar ArcGauge = RadialGauge.extend({\n    _initTheme: function(theme) {\n        RadialGauge.fn._initTheme.call(this, theme);\n\n        this.options.color = this.options.color || (this.theme.pointer || {}).color;\n    },\n\n    _createModel: function() {\n        var options = this.options;\n        var scale = this.scale = new ArcScale(options.scale, this.contextService);\n\n        var pointer = new RangePointer(scale, deepExtend({}, {\n            colors: options.colors,\n            color: options.color,\n            value: options.value,\n            opacity: options.opacity,\n            animation: {\n                transitions: options.transitions\n            }\n        }));\n\n        this.pointers = [ pointer ];\n    },\n\n    _buildPointers: function(pointers) {\n        for (var i = 0; i < pointers.length; i++) {\n            var current = pointers[i];\n            current.render();\n\n            current.value(current.options.value);\n        }\n    },\n\n    _setValueOptions: function(value) {\n        this.options.value = value;\n    },\n\n    currentColor: function() {\n        var pointer = this.pointers[0];\n        if (pointer) {\n            return pointer.currentColor();\n        }\n    },\n\n    centerLabelPosition: function(width, height) {\n        var size = this.getSize();\n        var center = this.scale.arc.center;\n\n        var left = center.x - width / 2;\n        var top = center.y - height / 2;\n\n        if (width < size.width) {\n            var right = left + width;\n\n            left = Math.max(left, 0);\n\n            if (right > size.width) {\n                left -= right - size.width;\n            }\n        }\n\n        if (height < size.height) {\n            var bbox = this.scale.bbox;\n            var yLimit = bbox.bottomRight().y;\n            var bottom = top + height;\n\n            top = Math.max(top, bbox.origin.y);\n\n            if (bottom > yLimit) {\n                top -= bottom - yLimit;\n            }\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    }\n});\n\nvar defaultStartAngle = 90;\n\nvar CircularGauge = ArcGauge.extend({\n    _createModel: function() {\n        var scaleOptions = this.options.scale;\n        if (typeof scaleOptions.startAngle !== 'number') {\n            scaleOptions.startAngle = defaultStartAngle;\n        }\n\n        scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n        ArcGauge.fn._createModel.call(this);\n    }\n});\n\nkendo.deepExtend(kendo.dataviz, {\n    Gauge: Gauge,\n    LinearGauge: LinearGauge,\n    LinearPointer: LinearPointer,\n    ArrowLinearPointer: ArrowLinearPointer,\n    BarLinearPointer: BarLinearPointer,\n    LinearScale: LinearScale,\n    RadialGauge: RadialGauge,\n    RadialPointer: RadialPointer,\n    RadialScale: RadialScale,\n    ArcGauge: ArcGauge,\n    RangePointer: RangePointer,\n    ArcScale: ArcScale,\n    CircularGauge: CircularGauge\n});\n\n})(window.kendo.jQuery);\n\n}, __webpack_require__.amdD);\n\n/***/ }),\n\n/***/ 13298:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"../../kendo.color\");\n\n/***/ }),\n\n/***/ 33877:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"../../kendo.core\");\n\n/***/ }),\n\n/***/ 32549:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"../../kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 79174:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"../../kendo.drawing\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/amd define */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.amdD = function () {\n/******/ \t\t\tthrow new Error('define cannot be used indirect');\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module used 'module' so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(87613);\n/******/ \tmodule.exports = __webpack_exports__;\n/******/ \t\n/******/ })()\n;"],"mappings":"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"},"metadata":{},"sourceType":"script"}