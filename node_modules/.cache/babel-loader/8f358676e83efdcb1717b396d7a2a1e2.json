{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\n/******/\n(function () {\n  // webpackBootstrap\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\n    12712:\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n      (function (f, define) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(82231)], __WEBPACK_AMD_DEFINE_FACTORY__ = f, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n      })(function () {\n        (function ($) {\n          // Imports ================================================================\n          var kendo = window.kendo,\n              Class = kendo.Class,\n              extend = $.extend,\n              Editor = kendo.ui.editor,\n              browser = kendo.support.browser,\n              dom = Editor.Dom,\n              findNodeIndex = dom.findNodeIndex,\n              isDataNode = dom.isDataNode,\n              findClosestAncestor = dom.findClosestAncestor,\n              getNodeLength = dom.getNodeLength,\n              normalize = dom.normalize;\n          var SelectionUtils = {\n            selectionFromWindow: function (window) {\n              if (!window) {\n                return;\n              }\n\n              if (!(\"getSelection\" in window)) {\n                return new W3CSelection(window.document);\n              }\n\n              return window.getSelection();\n            },\n            selectionFromRange: function (range) {\n              var rangeDocument = RangeUtils.documentFromRange(range);\n              return SelectionUtils.selectionFromDocument(rangeDocument);\n            },\n            selectionFromDocument: function (document) {\n              return SelectionUtils.selectionFromWindow(dom.windowFromDocument(document));\n            }\n          };\n          var W3CRange = Class.extend({\n            init: function (doc) {\n              $.extend(this, {\n                ownerDocument: doc,\n\n                /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */\n                startContainer: doc,\n                endContainer: doc,\n                commonAncestorContainer: doc,\n                startOffset: 0,\n                endOffset: 0,\n                collapsed: true\n              });\n            },\n            // Positioning Methods\n            setStart: function (node, offset) {\n              this.startContainer = node;\n              this.startOffset = offset;\n              updateRangeProperties(this);\n              fixIvalidRange(this, true);\n            },\n            setEnd: function (node, offset) {\n              this.endContainer = node;\n              this.endOffset = offset;\n              updateRangeProperties(this);\n              fixIvalidRange(this, false);\n            },\n            setStartBefore: function (node) {\n              this.setStart(node.parentNode, findNodeIndex(node));\n            },\n            setStartAfter: function (node) {\n              this.setStart(node.parentNode, findNodeIndex(node) + 1);\n            },\n            setEndBefore: function (node) {\n              this.setEnd(node.parentNode, findNodeIndex(node));\n            },\n            setEndAfter: function (node) {\n              this.setEnd(node.parentNode, findNodeIndex(node) + 1);\n            },\n            selectNode: function (node) {\n              this.setStartBefore(node);\n              this.setEndAfter(node);\n            },\n            selectNodeContents: function (node) {\n              this.setStart(node, 0);\n              this.setEnd(node, node[node.nodeType === 1 ? 'childNodes' : 'nodeValue'].length);\n            },\n            collapse: function (toStart) {\n              var that = this;\n\n              if (toStart) {\n                that.setEnd(that.startContainer, that.startOffset);\n              } else {\n                that.setStart(that.endContainer, that.endOffset);\n              }\n            },\n            // Editing Methods\n            deleteContents: function () {\n              var that = this,\n                  range = that.cloneRange();\n\n              if (that.startContainer != that.commonAncestorContainer) {\n                that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n              }\n\n              that.collapse(true);\n\n              (function deleteSubtree(iterator) {\n                while (iterator.next()) {\n                  if (iterator.hasPartialSubtree()) {\n                    deleteSubtree(iterator.getSubtreeIterator());\n                  } else {\n                    iterator.remove();\n                  }\n                }\n              })(new RangeIterator(range));\n            },\n            cloneContents: function () {\n              // clone subtree\n              var document = RangeUtils.documentFromRange(this);\n              return function cloneSubtree(iterator) {\n                var node,\n                    frag = document.createDocumentFragment();\n\n                while (node = iterator.next()) {\n                  node = node.cloneNode(!iterator.hasPartialSubtree());\n\n                  if (iterator.hasPartialSubtree()) {\n                    node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));\n                  }\n\n                  frag.appendChild(node);\n                }\n\n                return frag;\n              }(new RangeIterator(this));\n            },\n            extractContents: function () {\n              var that = this,\n                  range = that.cloneRange();\n\n              if (that.startContainer != that.commonAncestorContainer) {\n                that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n              }\n\n              that.collapse(true);\n              var document = RangeUtils.documentFromRange(that);\n              return function extractSubtree(iterator) {\n                var node,\n                    frag = document.createDocumentFragment();\n\n                while (node = iterator.next()) {\n                  if (iterator.hasPartialSubtree()) {\n                    node = node.cloneNode(false);\n                    node.appendChild(extractSubtree(iterator.getSubtreeIterator()));\n                  } else {\n                    iterator.remove(that.originalRange);\n                  }\n\n                  frag.appendChild(node);\n                }\n\n                return frag;\n              }(new RangeIterator(range));\n            },\n            insertNode: function (node) {\n              var that = this;\n\n              if (isDataNode(that.startContainer)) {\n                if (that.startOffset != that.startContainer.nodeValue.length) {\n                  dom.splitDataNode(that.startContainer, that.startOffset);\n                }\n\n                dom.insertAfter(node, that.startContainer);\n              } else {\n                dom.insertAt(that.startContainer, node, that.startOffset);\n              }\n\n              that.setStart(that.startContainer, that.startOffset);\n            },\n            cloneRange: function () {\n              // fast copy\n              return $.extend(new W3CRange(this.ownerDocument), {\n                startContainer: this.startContainer,\n                endContainer: this.endContainer,\n                commonAncestorContainer: this.commonAncestorContainer,\n                startOffset: this.startOffset,\n                endOffset: this.endOffset,\n                collapsed: this.collapsed,\n                originalRange: this\n                /* not part of the spec; used to update the original range when calling extractContents() on clones */\n\n              });\n            },\n            // used for debug purposes\n            toString: function () {\n              var startNodeName = this.startContainer.nodeName,\n                  endNodeName = this.endContainer.nodeName;\n              return [startNodeName == \"#text\" ? this.startContainer.nodeValue : startNodeName, '(', this.startOffset, ') : ', endNodeName == \"#text\" ? this.endContainer.nodeValue : endNodeName, '(', this.endOffset, ')'].join('');\n            }\n          });\n\n          W3CRange.fromNode = function (node) {\n            return new W3CRange(node.ownerDocument);\n          };\n          /* can be used in Range.compareBoundaryPoints if we need it one day */\n\n\n          function compareBoundaries(start, end, startOffset, endOffset) {\n            if (start == end) {\n              return endOffset - startOffset;\n            } // end is child of start\n\n\n            var container = end;\n\n            while (container && container.parentNode != start) {\n              container = container.parentNode;\n            }\n\n            if (container) {\n              return findNodeIndex(container) - startOffset;\n            } // start is child of end\n\n\n            container = start;\n\n            while (container && container.parentNode != end) {\n              container = container.parentNode;\n            }\n\n            if (container) {\n              return endOffset - findNodeIndex(container) - 1;\n            } // deep traversal\n\n\n            var root = dom.commonAncestor(start, end);\n            var startAncestor = start;\n\n            while (startAncestor && startAncestor.parentNode != root) {\n              startAncestor = startAncestor.parentNode;\n            }\n\n            if (!startAncestor) {\n              startAncestor = root;\n            }\n\n            var endAncestor = end;\n\n            while (endAncestor && endAncestor.parentNode != root) {\n              endAncestor = endAncestor.parentNode;\n            }\n\n            if (!endAncestor) {\n              endAncestor = root;\n            }\n\n            if (startAncestor == endAncestor) {\n              return 0;\n            }\n\n            return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);\n          }\n\n          function fixIvalidRange(range, toStart) {\n            function isInvalidRange(range) {\n              try {\n                return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;\n              } catch (ex) {\n                // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed\n                return true;\n              }\n            }\n\n            if (isInvalidRange(range)) {\n              if (toStart) {\n                range.commonAncestorContainer = range.endContainer = range.startContainer;\n                range.endOffset = range.startOffset;\n              } else {\n                range.commonAncestorContainer = range.startContainer = range.endContainer;\n                range.startOffset = range.endOffset;\n              }\n\n              range.collapsed = true;\n            }\n          }\n\n          function updateRangeProperties(range) {\n            range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;\n            var node = range.startContainer;\n\n            while (node && node != range.endContainer && !dom.isAncestorOf(node, range.endContainer)) {\n              node = node.parentNode;\n            }\n\n            range.commonAncestorContainer = node;\n          }\n\n          var RangeIterator = Class.extend({\n            init: function (range) {\n              $.extend(this, {\n                range: range,\n                _current: null,\n                _next: null,\n                _end: null\n              });\n\n              if (range.collapsed) {\n                return;\n              }\n\n              var root = range.commonAncestorContainer;\n              this._next = range.startContainer == root && !isDataNode(range.startContainer) ? range.startContainer.childNodes[range.startOffset] : findClosestAncestor(root, range.startContainer);\n              this._end = range.endContainer == root && !isDataNode(range.endContainer) ? range.endContainer.childNodes[range.endOffset] : findClosestAncestor(root, range.endContainer).nextSibling;\n            },\n            hasNext: function () {\n              return !!this._next;\n            },\n            next: function () {\n              var that = this,\n                  current = that._current = that._next;\n              that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n\n              if (isDataNode(that._current)) {\n                if (that.range.endContainer == that._current) {\n                  current = current.cloneNode(true);\n                  current.deleteData(that.range.endOffset, current.length - that.range.endOffset);\n                }\n\n                if (that.range.startContainer == that._current) {\n                  current = current.cloneNode(true);\n                  current.deleteData(0, that.range.startOffset);\n                }\n              }\n\n              return current;\n            },\n            traverse: function (callback) {\n              var that = this,\n                  current;\n\n              function next() {\n                that._current = that._next;\n                that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n                return that._current;\n              }\n\n              while (current = next()) {\n                if (that.hasPartialSubtree()) {\n                  that.getSubtreeIterator().traverse(callback);\n                } else {\n                  callback(current);\n                }\n              }\n\n              return current;\n            },\n            remove: function (originalRange) {\n              var that = this,\n                  inStartContainer = that.range.startContainer == that._current,\n                  inEndContainer = that.range.endContainer == that._current,\n                  start,\n                  end,\n                  delta;\n\n              if (isDataNode(that._current) && (inStartContainer || inEndContainer)) {\n                start = inStartContainer ? that.range.startOffset : 0;\n                end = inEndContainer ? that.range.endOffset : that._current.length;\n                delta = end - start;\n\n                if (originalRange && (inStartContainer || inEndContainer)) {\n                  if (that._current == originalRange.startContainer && start <= originalRange.startOffset) {\n                    originalRange.startOffset -= delta;\n                  }\n\n                  if (that._current == originalRange.endContainer && end <= originalRange.endOffset) {\n                    originalRange.endOffset -= delta;\n                  }\n                }\n\n                that._current.deleteData(start, delta);\n              } else {\n                var parent = that._current.parentNode;\n\n                if (originalRange && (that.range.startContainer == parent || that.range.endContainer == parent)) {\n                  var nodeIndex = findNodeIndex(that._current);\n\n                  if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset) {\n                    originalRange.startOffset -= 1;\n                  }\n\n                  if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset) {\n                    originalRange.endOffset -= 1;\n                  }\n                }\n\n                dom.remove(that._current);\n              }\n            },\n            hasPartialSubtree: function () {\n              return !isDataNode(this._current) && (dom.isAncestorOrSelf(this._current, this.range.startContainer) || dom.isAncestorOrSelf(this._current, this.range.endContainer));\n            },\n            getSubtreeIterator: function () {\n              return new RangeIterator(this.getSubRange());\n            },\n            getSubRange: function () {\n              var that = this,\n                  subRange = that.range.cloneRange();\n              subRange.selectNodeContents(that._current);\n\n              if (dom.isAncestorOrSelf(that._current, that.range.startContainer)) {\n                subRange.setStart(that.range.startContainer, that.range.startOffset);\n              }\n\n              if (dom.isAncestorOrSelf(that._current, that.range.endContainer)) {\n                subRange.setEnd(that.range.endContainer, that.range.endOffset);\n              }\n\n              return subRange;\n            }\n          });\n          var W3CSelection = Class.extend({\n            init: function (doc) {\n              this.ownerDocument = doc;\n              this.rangeCount = 1;\n            },\n            addRange: function (range) {\n              var textRange = this.ownerDocument.body.createTextRange(); // end container should be adopted first in order to prevent selection with negative length\n\n              adoptContainer(textRange, range, false);\n              adoptContainer(textRange, range, true);\n              textRange.select();\n            },\n            removeAllRanges: function () {\n              var selection = this.ownerDocument.selection;\n\n              if (selection.type != \"None\") {\n                selection.empty();\n              }\n            },\n            getRangeAt: function () {\n              var textRange,\n                  range = new W3CRange(this.ownerDocument),\n                  selection = this.ownerDocument.selection,\n                  element,\n                  commonAncestor;\n\n              try {\n                textRange = selection.createRange();\n                element = textRange.item ? textRange.item(0) : textRange.parentElement();\n\n                if (element.ownerDocument != this.ownerDocument) {\n                  return range;\n                }\n              } catch (ex) {\n                return range;\n              }\n\n              if (selection.type == \"Control\") {\n                range.selectNode(textRange.item(0));\n              } else {\n                commonAncestor = textRangeContainer(textRange);\n                adoptEndPoint(textRange, range, commonAncestor, true);\n                adoptEndPoint(textRange, range, commonAncestor, false);\n\n                if (range.startContainer.nodeType == 9) {\n                  range.setStart(range.endContainer, range.startOffset);\n                }\n\n                if (range.endContainer.nodeType == 9) {\n                  range.setEnd(range.startContainer, range.endOffset);\n                }\n\n                if (textRange.compareEndPoints(\"StartToEnd\", textRange) === 0) {\n                  range.collapse(false);\n                }\n\n                var startContainer = range.startContainer,\n                    endContainer = range.endContainer,\n                    body = this.ownerDocument.body;\n\n                if (!range.collapsed && range.startOffset === 0 && range.endOffset == getNodeLength(range.endContainer) && // check for full body selection\n                !(startContainer == endContainer && isDataNode(startContainer) && startContainer.parentNode == body)) {\n                  // but not when single textnode is selected\n                  var movedStart = false,\n                      movedEnd = false;\n\n                  while (findNodeIndex(startContainer) === 0 && startContainer == startContainer.parentNode.firstChild && startContainer != body) {\n                    startContainer = startContainer.parentNode;\n                    movedStart = true;\n                  }\n\n                  while (findNodeIndex(endContainer) == getNodeLength(endContainer.parentNode) - 1 && endContainer == endContainer.parentNode.lastChild && endContainer != body) {\n                    endContainer = endContainer.parentNode;\n                    movedEnd = true;\n                  }\n\n                  if (startContainer == body && endContainer == body && movedStart && movedEnd) {\n                    range.setStart(startContainer, 0);\n                    range.setEnd(endContainer, getNodeLength(body));\n                  }\n                }\n              }\n\n              return range;\n            }\n          });\n\n          function textRangeContainer(textRange) {\n            var left = textRange.duplicate(),\n                right = textRange.duplicate();\n            left.collapse(true);\n            right.collapse(false);\n            return dom.commonAncestor(textRange.parentElement(), left.parentElement(), right.parentElement());\n          }\n\n          function adoptContainer(textRange, range, start) {\n            // find anchor node and offset\n            var container = range[start ? \"startContainer\" : \"endContainer\"],\n                offset = range[start ? \"startOffset\" : \"endOffset\"],\n                textOffset = 0,\n                isData = isDataNode(container),\n                anchorNode = isData ? container : container.childNodes[offset] || null,\n                anchorParent = isData ? container.parentNode : container,\n                doc = range.ownerDocument,\n                cursor = doc.body.createTextRange(),\n                cursorNode; // visible data nodes need a text offset\n\n            if (container.nodeType == 3 || container.nodeType == 4) {\n              textOffset = offset;\n            }\n\n            if (!anchorParent) {\n              anchorParent = doc.body;\n            }\n\n            if (anchorParent.nodeName.toLowerCase() == \"img\") {\n              cursor.moveToElementText(anchorParent);\n              cursor.collapse(false);\n              textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n            } else {\n              // create a cursor element node to position range (since we can't select text nodes)\n              cursorNode = anchorParent.insertBefore(dom.create(doc, \"a\"), anchorNode);\n              cursor.moveToElementText(cursorNode);\n              dom.remove(cursorNode);\n              cursor[start ? \"moveStart\" : \"moveEnd\"](\"character\", textOffset);\n              cursor.collapse(false);\n              textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n            }\n          }\n\n          function adoptEndPoint(textRange, range, commonAncestor, start) {\n            var cursorNode = dom.create(range.ownerDocument, \"a\"),\n                cursor = textRange.duplicate(),\n                comparison = start ? \"StartToStart\" : \"StartToEnd\",\n                result,\n                parent,\n                target,\n                previous,\n                next,\n                args,\n                index,\n                appended = false;\n            cursorNode.innerHTML = \"\\ufeff\";\n            cursor.collapse(start);\n            parent = cursor.parentElement();\n\n            if (!dom.isAncestorOrSelf(commonAncestor, parent)) {\n              parent = commonAncestor;\n            } // detect range end points\n            // insert cursorNode within the textRange parent and move the cursor until it gets outside of the textRange\n\n\n            do {\n              if (appended) {\n                parent.insertBefore(cursorNode, cursorNode.previousSibling);\n              } else {\n                parent.appendChild(cursorNode);\n                appended = true;\n              }\n\n              cursor.moveToElementText(cursorNode);\n            } while ((result = cursor.compareEndPoints(comparison, textRange)) > 0 && cursorNode.previousSibling);\n\n            target = cursorNode.nextSibling;\n\n            if (result == -1 && isDataNode(target)) {\n              cursor.setEndPoint(start ? \"EndToStart\" : \"EndToEnd\", textRange);\n              dom.remove(cursorNode);\n              args = [target, cursor.text.length];\n            } else {\n              previous = !start && cursorNode.previousSibling;\n              next = start && cursorNode.nextSibling;\n\n              if (isDataNode(next)) {\n                args = [next, 0];\n              } else if (isDataNode(previous)) {\n                args = [previous, previous.length];\n              } else {\n                index = findNodeIndex(cursorNode);\n\n                if (parent.nextSibling && index == parent.childNodes.length - 1) {\n                  args = [parent.nextSibling, 0];\n                } else {\n                  args = [parent, index];\n                }\n              }\n\n              dom.remove(cursorNode);\n            }\n\n            range[start ? \"setStart\" : \"setEnd\"].apply(range, args);\n          }\n\n          var RangeEnumerator = Class.extend({\n            init: function (range) {\n              this.enumerate = function () {\n                var nodes = [];\n\n                function visit(node) {\n                  if (dom.is(node, \"img\") || node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\")) {\n                    nodes.push(node);\n                  } else {\n                    node = node.firstChild;\n\n                    while (node) {\n                      visit(node);\n                      node = node.nextSibling;\n                    }\n                  }\n                }\n\n                new RangeIterator(range).traverse(visit);\n                return nodes;\n              };\n            }\n          });\n          var ImmutablesRangeIterator = RangeIterator.extend({\n            hasPartialSubtree: function () {\n              var immutable = Editor.Immutables && Editor.Immutables.immutable;\n              return immutable && !immutable(this._current) && RangeIterator.fn.hasPartialSubtree.call(this);\n            },\n            getSubtreeIterator: function () {\n              return new ImmutablesRangeIterator(this.getSubRange());\n            }\n          });\n          var ImmutablesRangeEnumerator = Class.extend({\n            init: function (range) {\n              this.enumerate = function () {\n                var nodes = [];\n                var immutable = Editor.Immutables && Editor.Immutables.immutable;\n\n                function visit(node) {\n                  if (immutable && !immutable(node)) {\n                    if (dom.is(node, \"img\") || node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\")) {\n                      nodes.push(node);\n                    } else {\n                      node = node.firstChild;\n\n                      while (node) {\n                        visit(node);\n                        node = node.nextSibling;\n                      }\n                    }\n                  }\n                }\n\n                new ImmutablesRangeIterator(range).traverse(visit);\n                return nodes;\n              };\n            }\n          });\n          var RestorePoint = Class.extend({\n            init: function (range, body, options) {\n              var that = this;\n              that.range = range;\n              that.rootNode = RangeUtils.documentFromRange(range);\n              that.body = body || that.getEditable(range);\n\n              if (dom.name(that.body) != \"body\") {\n                that.rootNode = that.body;\n              }\n\n              that.startContainer = that.nodeToPath(range.startContainer);\n              that.endContainer = that.nodeToPath(range.endContainer);\n              that.startOffset = that.offset(range.startContainer, range.startOffset);\n              that.endOffset = that.offset(range.endContainer, range.endOffset);\n              that.immutables = options && options.immutables;\n\n              if (that.immutables) {\n                that.serializedImmutables = Editor.Immutables.removeImmutables(that.body);\n              }\n\n              that.html = that.body.innerHTML;\n\n              if (that.immutables && !that.serializedImmutables.empty) {\n                Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n              }\n            },\n            index: function (node) {\n              var result = 0,\n                  lastType = node.nodeType;\n\n              while (node = node.previousSibling) {\n                var nodeType = node.nodeType;\n\n                if (nodeType != 3 || lastType != nodeType) {\n                  result++;\n                }\n\n                lastType = nodeType;\n              }\n\n              return result;\n            },\n            getEditable: function (range) {\n              var root = range.commonAncestorContainer;\n\n              while (root && (root.nodeType == 3 || root.attributes && (!root.attributes.contentEditable || root.attributes.contentEditable.nodeValue.toLowerCase() == \"false\"))) {\n                root = root.parentNode;\n              }\n\n              return root;\n            },\n            restoreHtml: function () {\n              var that = this;\n              dom.removeChildren(that.body);\n              that.body.innerHTML = that.html;\n\n              if (that.immutables && !that.serializedImmutables.empty) {\n                Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n              }\n            },\n            offset: function (node, value) {\n              if (node.nodeType == 3) {\n                while ((node = node.previousSibling) && node.nodeType == 3) {\n                  value += node.nodeValue.length;\n                }\n              }\n\n              return value;\n            },\n            nodeToPath: function (node) {\n              var path = [];\n\n              while (node != this.rootNode) {\n                path.push(this.index(node));\n                node = node.parentNode;\n              }\n\n              return path;\n            },\n            toRangePoint: function (range, start, path, denormalizedOffset) {\n              var node = this.rootNode,\n                  length = path.length,\n                  offset = denormalizedOffset;\n\n              while (length-- && node) {\n                node = node.childNodes[path[length]];\n              }\n\n              while (node && node.nodeType == 3 && node.nodeValue.length < offset) {\n                offset -= node.nodeValue.length;\n                node = node.nextSibling;\n              }\n\n              if (node && offset >= 0) {\n                range[start ? 'setStart' : 'setEnd'](node, offset);\n              }\n            },\n            toRange: function () {\n              var that = this,\n                  result = that.range.cloneRange();\n              that.toRangePoint(result, true, that.startContainer, that.startOffset);\n              that.toRangePoint(result, false, that.endContainer, that.endOffset);\n              return result;\n            }\n          });\n          var Marker = Class.extend({\n            init: function () {\n              this.caret = null;\n            },\n            addCaret: function (range) {\n              var that = this;\n              var caret = that.caret = dom.create(RangeUtils.documentFromRange(range), 'span', {\n                className: 'k-marker'\n              });\n              range.insertNode(caret);\n              dom.stripBomNode(caret.previousSibling);\n              dom.stripBomNode(caret.nextSibling);\n              range.selectNode(caret);\n              return caret;\n            },\n            removeCaret: function (range) {\n              var that = this,\n                  previous = that.caret.previousSibling,\n                  startOffset = 0;\n\n              if (previous) {\n                startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);\n              }\n\n              var container = that.caret.parentNode;\n              var containerIndex = previous ? findNodeIndex(previous) : 0;\n              dom.remove(that.caret);\n              normalize(container);\n              var node = container.childNodes[containerIndex];\n\n              if (isDataNode(node)) {\n                range.setStart(node, startOffset);\n              } else if (node) {\n                var textNode = dom.lastTextNode(node);\n\n                if (textNode) {\n                  range.setStart(textNode, textNode.nodeValue.length);\n                } else {\n                  range[previous ? 'setStartAfter' : 'setStartBefore'](node);\n                }\n              } else {\n                if (!browser.msie && !container.innerHTML) {\n                  container.innerHTML = '<br _moz_dirty=\"\" />';\n                }\n\n                range.selectNodeContents(container);\n              }\n\n              range.collapse(true);\n            },\n            add: function (range, expand) {\n              var that = this;\n              var collapsed = range.collapsed && !RangeUtils.isExpandable(range);\n              var doc = RangeUtils.documentFromRange(range);\n\n              if (expand && range.collapsed) {\n                that.addCaret(range);\n                range = RangeUtils.expand(range);\n              }\n\n              var rangeBoundary = range.cloneRange();\n              rangeBoundary.collapse(false);\n              that.end = dom.create(doc, 'span', {\n                className: 'k-marker'\n              });\n              rangeBoundary.insertNode(that.end);\n              rangeBoundary = range.cloneRange();\n              rangeBoundary.collapse(true);\n              that.start = that.end.cloneNode(true);\n              rangeBoundary.insertNode(that.start);\n\n              that._removeDeadMarkers(that.start, that.end);\n\n              if (collapsed) {\n                var bom = doc.createTextNode(\"\\ufeff\");\n                dom.insertAfter(bom.cloneNode(), that.start);\n                dom.insertBefore(bom, that.end);\n              }\n\n              normalize(range.commonAncestorContainer);\n              range.setStartBefore(that.start);\n              range.setEndAfter(that.end);\n              return range;\n            },\n            _removeDeadMarkers: function (start, end) {\n              if (start.previousSibling && start.previousSibling.nodeValue == \"\\ufeff\") {\n                dom.remove(start.previousSibling);\n              }\n\n              if (end.nextSibling && end.nextSibling.nodeValue == \"\\ufeff\") {\n                dom.remove(end.nextSibling);\n              }\n            },\n            _normalizedIndex: function (node) {\n              var index = findNodeIndex(node);\n              var pointer = node;\n\n              while (pointer.previousSibling) {\n                if (pointer.nodeType == 3 && pointer.previousSibling.nodeType == 3) {\n                  index--;\n                }\n\n                pointer = pointer.previousSibling;\n              }\n\n              return index;\n            },\n            remove: function (range) {\n              var that = this,\n                  start = that.start,\n                  end = that.end,\n                  shouldNormalizeStart,\n                  shouldNormalizeEnd,\n                  shouldNormalize;\n              normalize(range.commonAncestorContainer);\n\n              while (!start.nextSibling && start.parentNode) {\n                start = start.parentNode;\n              }\n\n              while (!end.previousSibling && end.parentNode) {\n                end = end.parentNode;\n              } // merely accessing the siblings will solve range issues in IE\n\n\n              shouldNormalizeStart = start.previousSibling && start.previousSibling.nodeType == 3 && start.nextSibling && start.nextSibling.nodeType == 3;\n              shouldNormalizeEnd = end.previousSibling && end.previousSibling.nodeType == 3 && end.nextSibling && end.nextSibling.nodeType == 3;\n              shouldNormalize = shouldNormalizeStart && shouldNormalizeEnd;\n              start = start.nextSibling;\n              end = end.previousSibling;\n              var isBomSelected = start === end && dom.isBom(start);\n\n              if (isBomSelected && start.length > 1) {\n                start.nodeValue = start.nodeValue.charAt(0);\n              }\n\n              var collapsed = isBomSelected;\n              var collapsedToStart = false; // collapsed range\n\n              if (start == that.end) {\n                collapsedToStart = !!that.start.previousSibling;\n                start = end = that.start.previousSibling || that.end.nextSibling;\n                collapsed = true;\n              }\n\n              dom.remove(that.start);\n              dom.remove(that.end);\n\n              if (!start || !end) {\n                range.selectNodeContents(range.commonAncestorContainer);\n                range.collapse(true);\n                return;\n              }\n\n              var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;\n              var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;\n\n              if (start.nodeType == 3) {\n                while (start.previousSibling && start.previousSibling.nodeType == 3) {\n                  start = start.previousSibling;\n                  startOffset += start.nodeValue.length;\n                }\n              }\n\n              if (end.nodeType == 3) {\n                while (end.previousSibling && end.previousSibling.nodeType == 3) {\n                  end = end.previousSibling;\n                  endOffset += end.nodeValue.length;\n                }\n              }\n\n              var startParent = start.parentNode;\n              var endParent = end.parentNode;\n\n              var startIndex = this._normalizedIndex(start);\n\n              var endIndex = this._normalizedIndex(end);\n\n              normalize(startParent);\n\n              if (start.nodeType == 3) {\n                start = startParent.childNodes[startIndex];\n              }\n\n              normalize(endParent);\n\n              if (end.nodeType == 3) {\n                end = endParent.childNodes[endIndex];\n              }\n\n              if (collapsed) {\n                if (start.nodeType == 3) {\n                  range.setStart(start, startOffset);\n                } else {\n                  range[collapsedToStart ? 'setStartAfter' : 'setStartBefore'](start);\n                }\n\n                range.collapse(true);\n              } else {\n                if (start.nodeType == 3) {\n                  range.setStart(start, startOffset);\n                } else {\n                  range.setStartBefore(start);\n                }\n\n                if (end.nodeType == 3) {\n                  range.setEnd(end, endOffset);\n                } else {\n                  range.setEndAfter(end);\n                }\n              }\n\n              if (that.caret) {\n                that.removeCaret(range);\n              }\n            }\n          });\n          var boundary = /[\\u0009-\\u000d]|\\u0020|\\u00a0|\\ufeff|\\.|,|;|:|!|\\(|\\)|\\?/;\n          var RangeUtils = {\n            nodes: function (range) {\n              var nodes = RangeUtils.textNodes(range);\n\n              if (!nodes.length) {\n                range.selectNodeContents(range.commonAncestorContainer);\n                nodes = RangeUtils.textNodes(range);\n\n                if (!nodes.length) {\n                  nodes = dom.significantChildNodes(range.commonAncestorContainer);\n                }\n              }\n\n              return nodes;\n            },\n            textNodes: function (range) {\n              var allNodes = new RangeEnumerator(range).enumerate(),\n                  result = allNodes.filter(function (node) {\n                return dom.allowsTextContent(node.parentElement);\n              });\n              return result;\n            },\n            editableTextNodes: function (range) {\n              var nodes = [],\n                  immutableParent = Editor.Immutables && Editor.Immutables.immutableParent,\n                  result = [];\n\n              if (immutableParent && !immutableParent(range.commonAncestorContainer)) {\n                nodes = new ImmutablesRangeEnumerator(range).enumerate();\n                result = nodes.filter(function (node) {\n                  return dom.allowsTextContent(node.parentElement);\n                });\n              }\n\n              return result;\n            },\n            documentFromRange: function (range) {\n              var startContainer = range.startContainer;\n              return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;\n            },\n            createRange: function (document) {\n              return document.createRange();\n            },\n            selectRange: function (range) {\n              var image = RangeUtils.image(range);\n\n              if (image) {\n                range.setStartAfter(image);\n                range.setEndAfter(image);\n              }\n\n              var selection = SelectionUtils.selectionFromRange(range);\n              selection.removeAllRanges();\n              selection.addRange(range);\n            },\n            stringify: function (range) {\n              return kendo.format(\"{0}:{1} - {2}:{3}\", dom.name(range.startContainer), range.startOffset, dom.name(range.endContainer), range.endOffset);\n            },\n            split: function (range, node, trim) {\n              function partition(start) {\n                var partitionRange = range.cloneRange();\n                partitionRange.collapse(start);\n                partitionRange[start ? 'setStartBefore' : 'setEndAfter'](node);\n                var contents = partitionRange.extractContents();\n\n                if (trim) {\n                  contents = dom.trim(contents);\n                }\n\n                dom[start ? 'insertBefore' : 'insertAfter'](contents, node);\n              }\n\n              partition(true);\n              partition(false);\n            },\n            mapAll: function (range, map) {\n              var nodes = [];\n              new RangeIterator(range).traverse(function (node) {\n                var mapped = map(node);\n\n                if (mapped && $.inArray(mapped, nodes) < 0) {\n                  nodes.push(mapped);\n                }\n              });\n              return nodes;\n            },\n            getAll: function (range, predicate) {\n              var selector = predicate;\n\n              if (typeof predicate == \"string\") {\n                predicate = function (node) {\n                  return dom.is(node, selector);\n                };\n              }\n\n              return RangeUtils.mapAll(range, function (node) {\n                if (predicate(node)) {\n                  return node;\n                }\n              });\n            },\n            getMarkers: function (range) {\n              return RangeUtils.getAll(range, function (node) {\n                return node.className == 'k-marker';\n              });\n            },\n            image: function (range) {\n              var nodes = RangeUtils.getAll(range, \"img\");\n\n              if (nodes.length == 1) {\n                return nodes[0];\n              }\n            },\n            isStartOf: function (originalRange, node) {\n              if (originalRange.startOffset !== 0) {\n                return false;\n              }\n\n              var range = originalRange.cloneRange();\n\n              while (range.startOffset === 0 && range.startContainer != node) {\n                var index = dom.findNodeIndex(range.startContainer);\n                var parent = range.startContainer.parentNode;\n\n                while (index > 0 && parent[index - 1] && dom.insignificant(parent[index - 1])) {\n                  index--;\n                }\n\n                range.setStart(parent, index);\n              }\n\n              return range.startOffset === 0 && range.startContainer == node;\n            },\n            isEndOf: function (originalRange, node) {\n              var range = originalRange.cloneRange();\n              range.collapse(false);\n              var start = range.startContainer;\n\n              if (dom.isDataNode(start) && range.startOffset == dom.getNodeLength(start)) {\n                range.setStart(start.parentNode, dom.findNodeIndex(start) + 1);\n                range.collapse(true);\n              }\n\n              range.setEnd(node, dom.getNodeLength(node));\n              var nodes = [];\n\n              function visit(node) {\n                if (!dom.insignificant(node) && !(dom.isDataNode(node) && /^[\\ufeff]*$/.test(node.nodeValue))) {\n                  nodes.push(node);\n                }\n              }\n\n              new RangeIterator(range).traverse(visit);\n              return !nodes.length;\n            },\n            wrapSelectedElements: function (range) {\n              var startEditable = dom.editableParent(range.startContainer);\n              var endEditable = dom.editableParent(range.endContainer);\n\n              while (range.startOffset === 0 && range.startContainer != startEditable) {\n                range.setStart(range.startContainer.parentNode, dom.findNodeIndex(range.startContainer));\n              }\n\n              function isEnd(offset, container) {\n                var length = dom.getNodeLength(container);\n\n                if (offset == length) {\n                  return true;\n                }\n\n                for (var i = offset; i < length; i++) {\n                  if (!dom.insignificant(container.childNodes[i])) {\n                    return false;\n                  }\n                }\n\n                return true;\n              }\n\n              while (isEnd(range.endOffset, range.endContainer) && range.endContainer != endEditable) {\n                range.setEnd(range.endContainer.parentNode, dom.findNodeIndex(range.endContainer) + 1);\n              }\n\n              return range;\n            },\n            expand: function (range) {\n              var result = range.cloneRange();\n              var startContainer = result.startContainer.childNodes[result.startOffset === 0 ? 0 : result.startOffset - 1];\n              var endContainer = result.endContainer.childNodes[result.endOffset];\n\n              if (!isDataNode(startContainer) || !isDataNode(endContainer)) {\n                return result;\n              }\n\n              var beforeCaret = startContainer.nodeValue;\n              var afterCaret = endContainer.nodeValue;\n\n              if (!beforeCaret || !afterCaret) {\n                return result;\n              }\n\n              var startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n              var endOffset = afterCaret.search(boundary);\n\n              if (!startOffset || !endOffset) {\n                return result;\n              }\n\n              endOffset = endOffset == -1 ? afterCaret.length : endOffset;\n              startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;\n              result.setStart(startContainer, startOffset);\n              result.setEnd(endContainer, endOffset);\n              return result;\n            },\n            isExpandable: function (range) {\n              var node = range.startContainer;\n              var rangeDocument = RangeUtils.documentFromRange(range);\n\n              if (node == rangeDocument || node == rangeDocument.body) {\n                return false;\n              }\n\n              var result = range.cloneRange();\n              var value = node.nodeValue;\n\n              if (!value) {\n                return false;\n              }\n\n              var beforeCaret = value.substring(0, result.startOffset);\n              var afterCaret = value.substring(result.startOffset);\n              var startOffset = 0,\n                  endOffset = 0;\n\n              if (beforeCaret) {\n                startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n              }\n\n              if (afterCaret) {\n                endOffset = afterCaret.search(boundary);\n              }\n\n              return startOffset && endOffset;\n            }\n          };\n          extend(Editor, {\n            SelectionUtils: SelectionUtils,\n            W3CRange: W3CRange,\n            RangeIterator: RangeIterator,\n            W3CSelection: W3CSelection,\n            RangeEnumerator: RangeEnumerator,\n            RestorePoint: RestorePoint,\n            Marker: Marker,\n            RangeUtils: RangeUtils\n          });\n        })(window.kendo.jQuery);\n      }, __webpack_require__.amdD);\n      /***/\n\n    },\n\n    /***/\n    82231:\n    /***/\n    function (module) {\n      \"use strict\";\n\n      module.exports = require(\"./components\");\n      /***/\n    }\n    /******/\n\n  };\n  /************************************************************************/\n\n  /******/\n  // The module cache\n\n  /******/\n\n  var __webpack_module_cache__ = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n    // Check if module is in cache\n\n    /******/\n    var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n\n    if (cachedModule !== undefined) {\n      /******/\n      return cachedModule.exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/\n      // no module.id needed\n\n      /******/\n      // no module.loaded needed\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /* webpack/runtime/amd define */\n\n  /******/\n\n\n  !function () {\n    /******/\n    __webpack_require__.amdD = function () {\n      /******/\n      throw new Error('define cannot be used indirect');\n      /******/\n    };\n    /******/\n\n  }();\n  /******/\n\n  /************************************************************************/\n\n  /******/\n\n  /******/\n  // startup\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n  // This entry module used 'module' so it can't be inlined\n\n  /******/\n\n  var __webpack_exports__ = __webpack_require__(12712);\n  /******/\n\n\n  module.exports = __webpack_exports__;\n  /******/\n\n  /******/\n})();","map":{"version":3,"names":["__webpack_modules__","module","exports","__webpack_require__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","f","define","apply","undefined","$","kendo","window","Class","extend","Editor","ui","editor","browser","support","dom","Dom","findNodeIndex","isDataNode","findClosestAncestor","getNodeLength","normalize","SelectionUtils","selectionFromWindow","W3CSelection","document","getSelection","selectionFromRange","range","rangeDocument","RangeUtils","documentFromRange","selectionFromDocument","windowFromDocument","W3CRange","init","doc","ownerDocument","startContainer","endContainer","commonAncestorContainer","startOffset","endOffset","collapsed","setStart","node","offset","updateRangeProperties","fixIvalidRange","setEnd","setStartBefore","parentNode","setStartAfter","setEndBefore","setEndAfter","selectNode","selectNodeContents","nodeType","length","collapse","toStart","that","deleteContents","cloneRange","deleteSubtree","iterator","next","hasPartialSubtree","getSubtreeIterator","remove","RangeIterator","cloneContents","cloneSubtree","frag","createDocumentFragment","cloneNode","appendChild","extractContents","extractSubtree","originalRange","insertNode","nodeValue","splitDataNode","insertAfter","insertAt","toString","startNodeName","nodeName","endNodeName","join","fromNode","compareBoundaries","start","end","container","root","commonAncestor","startAncestor","endAncestor","isInvalidRange","ex","isAncestorOf","_current","_next","_end","childNodes","nextSibling","hasNext","current","deleteData","traverse","callback","inStartContainer","inEndContainer","delta","parent","nodeIndex","isAncestorOrSelf","getSubRange","subRange","rangeCount","addRange","textRange","body","createTextRange","adoptContainer","select","removeAllRanges","selection","type","empty","getRangeAt","element","createRange","item","parentElement","textRangeContainer","adoptEndPoint","compareEndPoints","movedStart","movedEnd","firstChild","lastChild","left","duplicate","right","textOffset","isData","anchorNode","anchorParent","cursor","cursorNode","toLowerCase","moveToElementText","setEndPoint","insertBefore","create","comparison","result","target","previous","args","index","appended","innerHTML","previousSibling","text","RangeEnumerator","enumerate","nodes","visit","is","isEmptyspace","push","ImmutablesRangeIterator","immutable","Immutables","fn","call","ImmutablesRangeEnumerator","RestorePoint","options","rootNode","getEditable","name","nodeToPath","immutables","serializedImmutables","removeImmutables","html","restoreImmutables","lastType","attributes","contentEditable","restoreHtml","removeChildren","value","path","toRangePoint","denormalizedOffset","toRange","Marker","caret","addCaret","className","stripBomNode","removeCaret","containerIndex","textNode","lastTextNode","msie","add","expand","isExpandable","rangeBoundary","_removeDeadMarkers","bom","createTextNode","_normalizedIndex","pointer","shouldNormalizeStart","shouldNormalizeEnd","shouldNormalize","isBomSelected","isBom","charAt","collapsedToStart","startParent","endParent","startIndex","endIndex","boundary","textNodes","significantChildNodes","allNodes","filter","allowsTextContent","editableTextNodes","immutableParent","selectRange","image","stringify","format","split","trim","partition","partitionRange","contents","mapAll","map","mapped","inArray","getAll","predicate","selector","getMarkers","isStartOf","insignificant","isEndOf","test","wrapSelectedElements","startEditable","editableParent","endEditable","isEnd","i","beforeCaret","afterCaret","reverse","search","substring","jQuery","amdD","require","__webpack_module_cache__","moduleId","cachedModule","Error","__webpack_exports__"],"sources":["C:/Users/abodean/restapi-nodejs/client/app-router/node_modules/@progress/kendo-ui/js/editor/range.js"],"sourcesContent":["/******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 12712:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(82231) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n})(function() {\n\n(function($) {\n\n    // Imports ================================================================\n    var kendo = window.kendo,\n        Class = kendo.Class,\n        extend = $.extend,\n        Editor = kendo.ui.editor,\n        browser = kendo.support.browser,\n        dom = Editor.Dom,\n        findNodeIndex = dom.findNodeIndex,\n        isDataNode = dom.isDataNode,\n        findClosestAncestor = dom.findClosestAncestor,\n        getNodeLength = dom.getNodeLength,\n        normalize = dom.normalize;\n\nvar SelectionUtils = {\n    selectionFromWindow: function(window) {\n        if (!window) {\n            return;\n        }\n\n        if (!(\"getSelection\" in window)) {\n            return new W3CSelection(window.document);\n        }\n\n        return window.getSelection();\n    },\n\n    selectionFromRange: function(range) {\n        var rangeDocument = RangeUtils.documentFromRange(range);\n        return SelectionUtils.selectionFromDocument(rangeDocument);\n    },\n\n    selectionFromDocument: function(document) {\n        return SelectionUtils.selectionFromWindow(dom.windowFromDocument(document));\n    }\n};\n\nvar W3CRange = Class.extend({\n    init: function(doc) {\n        $.extend(this, {\n            ownerDocument: doc, /* not part of the spec; used when cloning ranges, traversing the dom and creating fragments */\n            startContainer: doc,\n            endContainer: doc,\n            commonAncestorContainer: doc,\n            startOffset: 0,\n            endOffset: 0,\n            collapsed: true\n        });\n    },\n\n    // Positioning Methods\n    setStart: function(node, offset) {\n        this.startContainer = node;\n        this.startOffset = offset;\n        updateRangeProperties(this);\n        fixIvalidRange(this, true);\n    },\n\n    setEnd: function(node, offset) {\n        this.endContainer = node;\n        this.endOffset = offset;\n        updateRangeProperties(this);\n        fixIvalidRange(this, false);\n    },\n\n    setStartBefore: function(node) {\n        this.setStart(node.parentNode, findNodeIndex(node));\n    },\n\n    setStartAfter: function(node) {\n        this.setStart(node.parentNode, findNodeIndex(node) + 1);\n    },\n\n    setEndBefore: function(node) {\n        this.setEnd(node.parentNode, findNodeIndex(node));\n    },\n\n    setEndAfter: function(node) {\n        this.setEnd(node.parentNode, findNodeIndex(node) + 1);\n    },\n\n    selectNode: function(node) {\n        this.setStartBefore(node);\n        this.setEndAfter(node);\n    },\n\n    selectNodeContents: function(node) {\n        this.setStart(node, 0);\n        this.setEnd(node, node[node.nodeType === 1 ? 'childNodes' : 'nodeValue'].length);\n    },\n\n    collapse: function(toStart) {\n        var that = this;\n\n        if (toStart) {\n            that.setEnd(that.startContainer, that.startOffset);\n        } else {\n            that.setStart(that.endContainer, that.endOffset);\n        }\n    },\n\n    // Editing Methods\n\n    deleteContents: function() {\n        var that = this,\n            range = that.cloneRange();\n\n        if (that.startContainer != that.commonAncestorContainer) {\n            that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n        }\n\n        that.collapse(true);\n\n        (function deleteSubtree(iterator) {\n            while (iterator.next()) {\n                if (iterator.hasPartialSubtree()) {\n                    deleteSubtree(iterator.getSubtreeIterator());\n                } else {\n                    iterator.remove();\n                }\n            }\n        })(new RangeIterator(range));\n    },\n\n    cloneContents: function() {\n        // clone subtree\n        var document = RangeUtils.documentFromRange(this);\n        return (function cloneSubtree(iterator) {\n                var node, frag = document.createDocumentFragment();\n\n                while (node = iterator.next()) {\n                    node = node.cloneNode(!iterator.hasPartialSubtree());\n\n                    if (iterator.hasPartialSubtree()) {\n                        node.appendChild(cloneSubtree(iterator.getSubtreeIterator()));\n                    }\n\n                    frag.appendChild(node);\n                }\n\n                return frag;\n        })(new RangeIterator(this));\n    },\n\n    extractContents: function() {\n        var that = this,\n            range = that.cloneRange();\n\n        if (that.startContainer != that.commonAncestorContainer) {\n            that.setStartAfter(findClosestAncestor(that.commonAncestorContainer, that.startContainer));\n        }\n\n        that.collapse(true);\n\n        var document = RangeUtils.documentFromRange(that);\n\n        return (function extractSubtree(iterator) {\n            var node, frag = document.createDocumentFragment();\n\n            while (node = iterator.next()) {\n                if (iterator.hasPartialSubtree()) {\n                    node = node.cloneNode(false);\n                    node.appendChild(extractSubtree(iterator.getSubtreeIterator()));\n                } else {\n                    iterator.remove(that.originalRange);\n                }\n\n                frag.appendChild(node);\n            }\n\n            return frag;\n        })(new RangeIterator(range));\n    },\n\n    insertNode: function(node) {\n        var that = this;\n\n        if (isDataNode(that.startContainer)) {\n            if (that.startOffset != that.startContainer.nodeValue.length) {\n                dom.splitDataNode(that.startContainer, that.startOffset);\n            }\n\n            dom.insertAfter(node, that.startContainer);\n        } else {\n            dom.insertAt(that.startContainer, node, that.startOffset);\n        }\n\n        that.setStart(that.startContainer, that.startOffset);\n    },\n\n    cloneRange: function() {\n        // fast copy\n        return $.extend(new W3CRange(this.ownerDocument), {\n            startContainer: this.startContainer,\n            endContainer: this.endContainer,\n            commonAncestorContainer: this.commonAncestorContainer,\n            startOffset: this.startOffset,\n            endOffset: this.endOffset,\n            collapsed: this.collapsed,\n\n            originalRange: this /* not part of the spec; used to update the original range when calling extractContents() on clones */\n        });\n    },\n\n    // used for debug purposes\n    toString: function() {\n        var startNodeName = this.startContainer.nodeName,\n            endNodeName = this.endContainer.nodeName;\n\n        return [startNodeName == \"#text\" ? this.startContainer.nodeValue : startNodeName, '(', this.startOffset, ') : ',\n                endNodeName == \"#text\" ? this.endContainer.nodeValue : endNodeName, '(', this.endOffset, ')'].join('');\n    }\n});\n\nW3CRange.fromNode = function(node) {\n    return new W3CRange(node.ownerDocument);\n};\n\n/* can be used in Range.compareBoundaryPoints if we need it one day */\nfunction compareBoundaries(start, end, startOffset, endOffset) {\n    if (start == end) {\n        return endOffset - startOffset;\n    }\n\n    // end is child of start\n    var container = end;\n    while (container && container.parentNode != start) {\n        container = container.parentNode;\n    }\n\n    if (container) {\n        return findNodeIndex(container) - startOffset;\n    }\n\n    // start is child of end\n    container = start;\n    while (container && container.parentNode != end) {\n        container = container.parentNode;\n    }\n\n    if (container) {\n        return endOffset - findNodeIndex(container) - 1;\n    }\n\n    // deep traversal\n    var root = dom.commonAncestor(start, end);\n    var startAncestor = start;\n\n    while (startAncestor && startAncestor.parentNode != root) {\n        startAncestor = startAncestor.parentNode;\n    }\n\n    if (!startAncestor) {\n        startAncestor = root;\n    }\n\n    var endAncestor = end;\n    while (endAncestor && endAncestor.parentNode != root) {\n        endAncestor = endAncestor.parentNode;\n    }\n\n    if (!endAncestor) {\n        endAncestor = root;\n    }\n\n    if (startAncestor == endAncestor) {\n        return 0;\n    }\n\n    return findNodeIndex(endAncestor) - findNodeIndex(startAncestor);\n}\n\nfunction fixIvalidRange(range, toStart) {\n    function isInvalidRange(range) {\n        try {\n            return compareBoundaries(range.startContainer, range.endContainer, range.startOffset, range.endOffset) < 0;\n        } catch (ex) {\n            // range was initially invalid (e.g. when cloned from invalid range) - it must be fixed\n            return true;\n        }\n    }\n\n    if (isInvalidRange(range)) {\n        if (toStart) {\n            range.commonAncestorContainer = range.endContainer = range.startContainer;\n            range.endOffset = range.startOffset;\n        } else {\n            range.commonAncestorContainer = range.startContainer = range.endContainer;\n            range.startOffset = range.endOffset;\n        }\n\n        range.collapsed = true;\n    }\n}\n\nfunction updateRangeProperties(range) {\n    range.collapsed = range.startContainer == range.endContainer && range.startOffset == range.endOffset;\n\n    var node = range.startContainer;\n    while (node && node != range.endContainer && !dom.isAncestorOf(node, range.endContainer)) {\n        node = node.parentNode;\n    }\n\n    range.commonAncestorContainer = node;\n}\n\nvar RangeIterator = Class.extend({\n    init: function(range) {\n        $.extend(this, {\n            range: range,\n            _current: null,\n            _next: null,\n            _end: null\n        });\n\n        if (range.collapsed) {\n            return;\n        }\n\n        var root = range.commonAncestorContainer;\n\n        this._next = range.startContainer == root && !isDataNode(range.startContainer) ?\n        range.startContainer.childNodes[range.startOffset] :\n        findClosestAncestor(root, range.startContainer);\n\n        this._end = range.endContainer == root && !isDataNode(range.endContainer) ?\n        range.endContainer.childNodes[range.endOffset] :\n        findClosestAncestor(root, range.endContainer).nextSibling;\n    },\n\n    hasNext: function() {\n        return !!this._next;\n    },\n\n    next: function() {\n        var that = this,\n            current = that._current = that._next;\n        that._next = that._current && that._current.nextSibling != that._end ?\n        that._current.nextSibling : null;\n\n        if (isDataNode(that._current)) {\n            if (that.range.endContainer == that._current) {\n                current = current.cloneNode(true);\n                current.deleteData(that.range.endOffset, current.length - that.range.endOffset);\n            }\n\n            if (that.range.startContainer == that._current) {\n                current = current.cloneNode(true);\n                current.deleteData(0, that.range.startOffset);\n            }\n        }\n\n        return current;\n    },\n\n    traverse: function(callback) {\n        var that = this,\n            current;\n\n        function next() {\n            that._current = that._next;\n            that._next = that._current && that._current.nextSibling != that._end ? that._current.nextSibling : null;\n            return that._current;\n        }\n\n        while (current = next()) {\n            if (that.hasPartialSubtree()) {\n                that.getSubtreeIterator().traverse(callback);\n            } else {\n                callback(current);\n            }\n        }\n\n        return current;\n    },\n\n    remove: function(originalRange) {\n        var that = this,\n            inStartContainer = that.range.startContainer == that._current,\n            inEndContainer = that.range.endContainer == that._current,\n            start, end, delta;\n\n        if (isDataNode(that._current) && (inStartContainer || inEndContainer)) {\n            start = inStartContainer ? that.range.startOffset : 0;\n            end = inEndContainer ? that.range.endOffset : that._current.length;\n            delta = end - start;\n\n            if (originalRange && (inStartContainer || inEndContainer)) {\n                if (that._current == originalRange.startContainer && start <= originalRange.startOffset) {\n                    originalRange.startOffset -= delta;\n                }\n\n                if (that._current == originalRange.endContainer && end <= originalRange.endOffset) {\n                    originalRange.endOffset -= delta;\n                }\n            }\n\n            that._current.deleteData(start, delta);\n        } else {\n            var parent = that._current.parentNode;\n\n            if (originalRange && (that.range.startContainer == parent || that.range.endContainer == parent)) {\n                var nodeIndex = findNodeIndex(that._current);\n\n                if (parent == originalRange.startContainer && nodeIndex <= originalRange.startOffset) {\n                    originalRange.startOffset -= 1;\n                }\n\n                if (parent == originalRange.endContainer && nodeIndex < originalRange.endOffset) {\n                    originalRange.endOffset -= 1;\n                }\n            }\n\n            dom.remove(that._current);\n        }\n    },\n\n    hasPartialSubtree: function() {\n        return !isDataNode(this._current) &&\n        (dom.isAncestorOrSelf(this._current, this.range.startContainer) ||\n            dom.isAncestorOrSelf(this._current, this.range.endContainer));\n    },\n\n    getSubtreeIterator: function() {\n        return new RangeIterator(this.getSubRange());\n    },\n\n    getSubRange: function() {\n        var that = this,\n            subRange = that.range.cloneRange();\n        subRange.selectNodeContents(that._current);\n        if (dom.isAncestorOrSelf(that._current, that.range.startContainer)) {\n            subRange.setStart(that.range.startContainer, that.range.startOffset);\n        }\n        if (dom.isAncestorOrSelf(that._current, that.range.endContainer)) {\n            subRange.setEnd(that.range.endContainer, that.range.endOffset);\n        }\n\n        return subRange;\n    }\n});\n\nvar W3CSelection = Class.extend({\n    init: function(doc) {\n        this.ownerDocument = doc;\n        this.rangeCount = 1;\n    },\n\n    addRange: function(range) {\n        var textRange = this.ownerDocument.body.createTextRange();\n\n        // end container should be adopted first in order to prevent selection with negative length\n        adoptContainer(textRange, range, false);\n        adoptContainer(textRange, range, true);\n\n        textRange.select();\n    },\n\n    removeAllRanges: function() {\n        var selection = this.ownerDocument.selection;\n\n        if (selection.type != \"None\") {\n            selection.empty();\n        }\n    },\n\n    getRangeAt: function() {\n        var textRange,\n            range = new W3CRange(this.ownerDocument),\n            selection = this.ownerDocument.selection,\n            element, commonAncestor;\n\n        try {\n            textRange = selection.createRange();\n            element = textRange.item ? textRange.item(0) : textRange.parentElement();\n            if (element.ownerDocument != this.ownerDocument) {\n                return range;\n            }\n        } catch (ex) {\n            return range;\n        }\n\n        if (selection.type == \"Control\") {\n            range.selectNode(textRange.item(0));\n        } else {\n            commonAncestor = textRangeContainer(textRange);\n            adoptEndPoint(textRange, range, commonAncestor, true);\n            adoptEndPoint(textRange, range, commonAncestor, false);\n\n            if (range.startContainer.nodeType == 9) {\n                range.setStart(range.endContainer, range.startOffset);\n            }\n\n            if (range.endContainer.nodeType == 9) {\n                range.setEnd(range.startContainer, range.endOffset);\n            }\n\n            if (textRange.compareEndPoints(\"StartToEnd\", textRange) === 0) {\n                range.collapse(false);\n            }\n\n            var startContainer = range.startContainer,\n                endContainer = range.endContainer,\n                body = this.ownerDocument.body;\n\n            if (!range.collapsed && range.startOffset === 0 && range.endOffset == getNodeLength(range.endContainer) && // check for full body selection\n                !(startContainer == endContainer && isDataNode(startContainer) && startContainer.parentNode == body)) { // but not when single textnode is selected\n                var movedStart = false,\n                    movedEnd = false;\n\n                while (findNodeIndex(startContainer) === 0 && startContainer == startContainer.parentNode.firstChild && startContainer != body) {\n                    startContainer = startContainer.parentNode;\n                    movedStart = true;\n                }\n\n                while (findNodeIndex(endContainer) == getNodeLength(endContainer.parentNode) - 1 && endContainer == endContainer.parentNode.lastChild && endContainer != body) {\n                    endContainer = endContainer.parentNode;\n                    movedEnd = true;\n                }\n\n                if (startContainer == body && endContainer == body && movedStart && movedEnd) {\n                    range.setStart(startContainer, 0);\n                    range.setEnd(endContainer, getNodeLength(body));\n                }\n            }\n        }\n\n        return range;\n    }\n});\n\nfunction textRangeContainer(textRange) {\n    var left = textRange.duplicate(),\n        right = textRange.duplicate();\n\n    left.collapse(true);\n    right.collapse(false);\n\n    return dom.commonAncestor(textRange.parentElement(), left.parentElement(), right.parentElement());\n}\n\nfunction adoptContainer(textRange, range, start) {\n    // find anchor node and offset\n    var container = range[start ? \"startContainer\" : \"endContainer\"],\n        offset = range[start ? \"startOffset\" : \"endOffset\"],\n        textOffset = 0,\n        isData = isDataNode(container),\n        anchorNode = isData ? container : container.childNodes[offset] || null,\n        anchorParent = isData ? container.parentNode : container,\n        doc = range.ownerDocument,\n        cursor = doc.body.createTextRange(),\n        cursorNode;\n\n    // visible data nodes need a text offset\n    if (container.nodeType == 3 || container.nodeType == 4) {\n        textOffset = offset;\n    }\n\n    if (!anchorParent) {\n        anchorParent = doc.body;\n    }\n\n    if (anchorParent.nodeName.toLowerCase() == \"img\") {\n        cursor.moveToElementText(anchorParent);\n        cursor.collapse(false);\n        textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n    } else {\n        // create a cursor element node to position range (since we can't select text nodes)\n        cursorNode = anchorParent.insertBefore(dom.create(doc, \"a\"), anchorNode);\n\n        cursor.moveToElementText(cursorNode);\n        dom.remove(cursorNode);\n        cursor[start ? \"moveStart\" : \"moveEnd\"](\"character\", textOffset);\n        cursor.collapse(false);\n        textRange.setEndPoint(start ? \"StartToStart\" : \"EndToStart\", cursor);\n    }\n}\n\nfunction adoptEndPoint(textRange, range, commonAncestor, start) {\n    var cursorNode = dom.create(range.ownerDocument, \"a\"),\n        cursor = textRange.duplicate(),\n        comparison = start ? \"StartToStart\" : \"StartToEnd\",\n        result, parent, target,\n        previous, next,\n        args, index,\n        appended = false;\n\n    cursorNode.innerHTML = \"\\ufeff\";\n    cursor.collapse(start);\n\n    parent = cursor.parentElement();\n\n    if (!dom.isAncestorOrSelf(commonAncestor, parent)) {\n        parent = commonAncestor;\n    }\n\n    // detect range end points\n    // insert cursorNode within the textRange parent and move the cursor until it gets outside of the textRange\n    do {\n        if (appended) {\n            parent.insertBefore(cursorNode, cursorNode.previousSibling);\n        } else {\n            parent.appendChild(cursorNode);\n            appended = true;\n        }\n        cursor.moveToElementText(cursorNode);\n    } while ((result = cursor.compareEndPoints(comparison, textRange)) > 0 && cursorNode.previousSibling);\n\n    target = cursorNode.nextSibling;\n\n    if (result == -1 && isDataNode(target)) {\n        cursor.setEndPoint(start ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n        dom.remove(cursorNode);\n\n        args = [target, cursor.text.length];\n    } else {\n        previous = !start && cursorNode.previousSibling;\n        next = start && cursorNode.nextSibling;\n\n        if (isDataNode(next)) {\n            args = [next, 0];\n        } else if (isDataNode(previous)) {\n            args = [previous, previous.length];\n        } else {\n            index = findNodeIndex(cursorNode);\n\n            if (parent.nextSibling && index == parent.childNodes.length - 1) {\n                args = [parent.nextSibling, 0];\n            } else {\n                args = [parent, index];\n            }\n        }\n\n        dom.remove(cursorNode);\n    }\n\n    range[start ? \"setStart\" : \"setEnd\"].apply(range, args);\n}\n\nvar RangeEnumerator = Class.extend({\n    init: function(range) {\n        this.enumerate = function() {\n            var nodes = [];\n\n            function visit(node) {\n                if (dom.is(node, \"img\") || (node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\"))) {\n                    nodes.push(node);\n                } else {\n                    node = node.firstChild;\n                    while (node) {\n                        visit(node);\n                        node = node.nextSibling;\n                    }\n                }\n            }\n\n            new RangeIterator(range).traverse(visit);\n\n            return nodes;\n        };\n    }\n});\n\nvar ImmutablesRangeIterator = RangeIterator.extend({\n    hasPartialSubtree: function() {\n        var immutable = Editor.Immutables && Editor.Immutables.immutable;\n        return immutable && !immutable(this._current) && RangeIterator.fn.hasPartialSubtree.call(this);\n    },\n\n    getSubtreeIterator: function() {\n        return new ImmutablesRangeIterator(this.getSubRange());\n    }\n});\n\nvar ImmutablesRangeEnumerator = Class.extend({\n    init: function(range) {\n        this.enumerate = function() {\n            var nodes = [];\n            var immutable = Editor.Immutables && Editor.Immutables.immutable;\n            function visit(node) {\n                if (immutable && !immutable(node)) {\n                    if (dom.is(node, \"img\") || (node.nodeType == 3 && (!dom.isEmptyspace(node) || node.nodeValue == \"\\ufeff\"))) {\n                        nodes.push(node);\n                    } else {\n                        node = node.firstChild;\n                        while (node) {\n                            visit(node);\n                            node = node.nextSibling;\n                        }\n                    }\n                }\n            }\n\n            new ImmutablesRangeIterator(range).traverse(visit);\n\n            return nodes;\n        };\n    }\n});\n\nvar RestorePoint = Class.extend({\n    init: function(range, body, options) {\n        var that = this;\n        that.range = range;\n        that.rootNode = RangeUtils.documentFromRange(range);\n        that.body = body || that.getEditable(range);\n        if (dom.name(that.body) != \"body\") {\n            that.rootNode = that.body;\n        }\n\n        that.startContainer = that.nodeToPath(range.startContainer);\n        that.endContainer = that.nodeToPath(range.endContainer);\n        that.startOffset = that.offset(range.startContainer, range.startOffset);\n        that.endOffset = that.offset(range.endContainer, range.endOffset);\n\n        that.immutables = options && options.immutables;\n\n        if (that.immutables) {\n            that.serializedImmutables = Editor.Immutables.removeImmutables(that.body);\n        }\n\n        that.html = that.body.innerHTML;\n\n        if (that.immutables && !that.serializedImmutables.empty) {\n            Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n        }\n    },\n\n    index: function(node) {\n        var result = 0,\n            lastType = node.nodeType;\n\n        while (node = node.previousSibling) {\n            var nodeType = node.nodeType;\n\n            if (nodeType != 3 || lastType != nodeType) {\n                result ++;\n            }\n\n            lastType = nodeType;\n        }\n\n        return result;\n    },\n\n    getEditable: function(range) {\n        var root = range.commonAncestorContainer;\n\n        while (root && (root.nodeType == 3 || root.attributes && (!root.attributes.contentEditable || root.attributes.contentEditable.nodeValue.toLowerCase() == \"false\"))) {\n            root = root.parentNode;\n        }\n\n        return root;\n    },\n\n    restoreHtml: function() {\n        var that = this;\n\n        dom.removeChildren(that.body);\n        that.body.innerHTML = that.html;\n        if (that.immutables && !that.serializedImmutables.empty) {\n            Editor.Immutables.restoreImmutables(that.body, that.serializedImmutables);\n        }\n    },\n\n    offset: function(node, value) {\n        if (node.nodeType == 3) {\n            while ((node = node.previousSibling) && node.nodeType == 3) {\n                value += node.nodeValue.length;\n            }\n        }\n\n        return value;\n    },\n\n    nodeToPath: function(node) {\n        var path = [];\n\n        while (node != this.rootNode) {\n            path.push(this.index(node));\n            node = node.parentNode;\n        }\n\n        return path;\n    },\n\n    toRangePoint: function(range, start, path, denormalizedOffset) {\n        var node = this.rootNode,\n            length = path.length,\n            offset = denormalizedOffset;\n\n        while (length-- && node) {\n            node = node.childNodes[path[length]];\n        }\n\n        while (node && node.nodeType == 3 && node.nodeValue.length < offset) {\n            offset -= node.nodeValue.length;\n            node = node.nextSibling;\n        }\n\n        if (node && offset >= 0) {\n            range[start ? 'setStart' : 'setEnd'](node, offset);\n        }\n    },\n\n    toRange: function() {\n        var that = this,\n            result = that.range.cloneRange();\n\n        that.toRangePoint(result, true, that.startContainer, that.startOffset);\n        that.toRangePoint(result, false, that.endContainer, that.endOffset);\n\n        return result;\n    }\n\n});\n\nvar Marker = Class.extend({\n    init: function() {\n        this.caret = null;\n    },\n\n    addCaret: function(range) {\n        var that = this;\n        var caret = that.caret = dom.create(RangeUtils.documentFromRange(range), 'span', { className: 'k-marker' });\n        range.insertNode(caret);\n\n        dom.stripBomNode(caret.previousSibling);\n        dom.stripBomNode(caret.nextSibling);\n\n        range.selectNode(caret);\n        return caret;\n    },\n\n    removeCaret: function(range) {\n        var that = this,\n            previous = that.caret.previousSibling,\n            startOffset = 0;\n\n        if (previous) {\n            startOffset = isDataNode(previous) ? previous.nodeValue.length : findNodeIndex(previous);\n        }\n\n        var container = that.caret.parentNode;\n        var containerIndex = previous ? findNodeIndex(previous) : 0;\n\n        dom.remove(that.caret);\n        normalize(container);\n\n        var node = container.childNodes[containerIndex];\n\n        if (isDataNode(node)) {\n            range.setStart(node, startOffset);\n        } else if (node) {\n            var textNode = dom.lastTextNode(node);\n            if (textNode) {\n                range.setStart(textNode, textNode.nodeValue.length);\n            } else {\n                range[previous ? 'setStartAfter' : 'setStartBefore'](node);\n            }\n        } else {\n            if (!browser.msie && !container.innerHTML) {\n                container.innerHTML = '<br _moz_dirty=\"\" />';\n            }\n\n            range.selectNodeContents(container);\n        }\n        range.collapse(true);\n    },\n\n    add: function(range, expand) {\n        var that = this;\n\n        var collapsed = range.collapsed && !RangeUtils.isExpandable(range);\n        var doc = RangeUtils.documentFromRange(range);\n\n        if (expand && range.collapsed) {\n            that.addCaret(range);\n            range = RangeUtils.expand(range);\n        }\n\n        var rangeBoundary = range.cloneRange();\n\n        rangeBoundary.collapse(false);\n        that.end = dom.create(doc, 'span', { className: 'k-marker' });\n        rangeBoundary.insertNode(that.end);\n\n        rangeBoundary = range.cloneRange();\n        rangeBoundary.collapse(true);\n        that.start = that.end.cloneNode(true);\n        rangeBoundary.insertNode(that.start);\n\n        that._removeDeadMarkers(that.start, that.end);\n\n        if (collapsed) {\n            var bom = doc.createTextNode(\"\\ufeff\");\n            dom.insertAfter(bom.cloneNode(), that.start);\n            dom.insertBefore(bom, that.end);\n        }\n\n        normalize(range.commonAncestorContainer);\n\n        range.setStartBefore(that.start);\n        range.setEndAfter(that.end);\n\n        return range;\n    },\n\n    _removeDeadMarkers: function(start, end) {\n        if (start.previousSibling && start.previousSibling.nodeValue == \"\\ufeff\") {\n            dom.remove(start.previousSibling);\n        }\n\n        if (end.nextSibling && end.nextSibling.nodeValue == \"\\ufeff\") {\n            dom.remove(end.nextSibling);\n        }\n    },\n\n    _normalizedIndex: function(node) {\n        var index = findNodeIndex(node);\n        var pointer = node;\n\n        while (pointer.previousSibling) {\n            if (pointer.nodeType == 3 && pointer.previousSibling.nodeType == 3) {\n                index--;\n            }\n\n            pointer = pointer.previousSibling;\n        }\n\n        return index;\n    },\n\n    remove: function(range) {\n        var that = this,\n            start = that.start,\n            end = that.end,\n            shouldNormalizeStart,\n            shouldNormalizeEnd,\n            shouldNormalize;\n\n        normalize(range.commonAncestorContainer);\n\n        while (!start.nextSibling && start.parentNode) {\n            start = start.parentNode;\n        }\n\n        while (!end.previousSibling && end.parentNode) {\n            end = end.parentNode;\n        }\n\n        // merely accessing the siblings will solve range issues in IE\n        shouldNormalizeStart = (start.previousSibling && start.previousSibling.nodeType == 3) &&\n                               (start.nextSibling && start.nextSibling.nodeType == 3);\n\n        shouldNormalizeEnd = (end.previousSibling && end.previousSibling.nodeType == 3) &&\n                             (end.nextSibling && end.nextSibling.nodeType == 3);\n\n        shouldNormalize = shouldNormalizeStart && shouldNormalizeEnd;\n\n        start = start.nextSibling;\n        end = end.previousSibling;\n\n        var isBomSelected = start === end && dom.isBom(start);\n        if (isBomSelected && start.length > 1) {\n            start.nodeValue = start.nodeValue.charAt(0);\n        }\n\n        var collapsed = isBomSelected;\n        var collapsedToStart = false;\n        // collapsed range\n        if (start == that.end) {\n            collapsedToStart = !!that.start.previousSibling;\n            start = end = that.start.previousSibling || that.end.nextSibling;\n            collapsed = true;\n        }\n\n        dom.remove(that.start);\n        dom.remove(that.end);\n\n        if (!start || !end) {\n            range.selectNodeContents(range.commonAncestorContainer);\n            range.collapse(true);\n            return;\n        }\n\n        var startOffset = collapsed ? isDataNode(start) ? start.nodeValue.length : start.childNodes.length : 0;\n        var endOffset = isDataNode(end) ? end.nodeValue.length : end.childNodes.length;\n\n        if (start.nodeType == 3) {\n            while (start.previousSibling && start.previousSibling.nodeType == 3) {\n                start = start.previousSibling;\n                startOffset += start.nodeValue.length;\n            }\n        }\n\n        if (end.nodeType == 3) {\n            while (end.previousSibling && end.previousSibling.nodeType == 3) {\n                end = end.previousSibling;\n                endOffset += end.nodeValue.length;\n            }\n        }\n\n        var startParent = start.parentNode;\n        var endParent = end.parentNode;\n        var startIndex = this._normalizedIndex(start);\n        var endIndex = this._normalizedIndex(end);\n\n        normalize(startParent);\n        if (start.nodeType == 3) {\n            start = startParent.childNodes[startIndex];\n        }\n\n        normalize(endParent);\n        if (end.nodeType == 3) {\n            end = endParent.childNodes[endIndex];\n        }\n\n        if (collapsed) {\n            if (start.nodeType == 3) {\n                range.setStart(start, startOffset);\n            } else {\n                range[collapsedToStart ? 'setStartAfter' : 'setStartBefore'](start);\n            }\n\n            range.collapse(true);\n\n        } else {\n            if (start.nodeType == 3) {\n                range.setStart(start, startOffset);\n            } else {\n                range.setStartBefore(start);\n            }\n\n            if (end.nodeType == 3) {\n                range.setEnd(end, endOffset);\n            } else {\n                range.setEndAfter(end);\n            }\n        }\n\n        if (that.caret) {\n            that.removeCaret(range);\n        }\n    }\n});\n\nvar boundary = /[\\u0009-\\u000d]|\\u0020|\\u00a0|\\ufeff|\\.|,|;|:|!|\\(|\\)|\\?/;\n\nvar RangeUtils = {\n    nodes: function(range) {\n        var nodes = RangeUtils.textNodes(range);\n        if (!nodes.length) {\n            range.selectNodeContents(range.commonAncestorContainer);\n            nodes = RangeUtils.textNodes(range);\n            if (!nodes.length) {\n                nodes = dom.significantChildNodes(range.commonAncestorContainer);\n            }\n        }\n        return nodes;\n    },\n\n    textNodes: function(range) {\n        var allNodes = new RangeEnumerator(range).enumerate(),\n            result = allNodes.filter(function(node) {\n                return dom.allowsTextContent(node.parentElement);\n            });\n\n        return result;\n    },\n\n    editableTextNodes: function(range) {\n        var nodes = [],\n            immutableParent = Editor.Immutables && Editor.Immutables.immutableParent,\n            result = [];\n\n        if (immutableParent && !immutableParent(range.commonAncestorContainer)) {\n            nodes = new ImmutablesRangeEnumerator(range).enumerate();\n            result = nodes.filter(function(node) {\n                return dom.allowsTextContent(node.parentElement);\n            });\n        }\n\n        return result;\n    },\n\n    documentFromRange: function(range) {\n        var startContainer = range.startContainer;\n        return startContainer.nodeType == 9 ? startContainer : startContainer.ownerDocument;\n    },\n\n    createRange: function(document) {\n        return document.createRange();\n    },\n\n    selectRange: function(range) {\n        var image = RangeUtils.image(range);\n        if (image) {\n            range.setStartAfter(image);\n            range.setEndAfter(image);\n        }\n        var selection = SelectionUtils.selectionFromRange(range);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    },\n\n    stringify: function(range) {\n        return kendo.format(\n            \"{0}:{1} - {2}:{3}\",\n            dom.name(range.startContainer), range.startOffset,\n            dom.name(range.endContainer), range.endOffset\n        );\n    },\n\n    split: function(range, node, trim) {\n        function partition(start) {\n            var partitionRange = range.cloneRange();\n            partitionRange.collapse(start);\n            partitionRange[start ? 'setStartBefore' : 'setEndAfter'](node);\n            var contents = partitionRange.extractContents();\n            if (trim) {\n                contents = dom.trim(contents);\n            }\n            dom[start ? 'insertBefore' : 'insertAfter'](contents, node);\n        }\n        partition(true);\n        partition(false);\n    },\n\n    mapAll: function(range, map) {\n        var nodes = [];\n\n        new RangeIterator(range).traverse(function(node) {\n            var mapped = map(node);\n\n            if (mapped && $.inArray(mapped, nodes) < 0) {\n                nodes.push(mapped);\n            }\n        });\n\n        return nodes;\n    },\n\n    getAll: function(range, predicate) {\n        var selector = predicate;\n\n        if (typeof predicate == \"string\") {\n            predicate = function(node) {\n                return dom.is(node, selector);\n            };\n        }\n\n        return RangeUtils.mapAll(range, function(node) {\n            if (predicate(node)) {\n                return node;\n            }\n        });\n    },\n\n    getMarkers: function(range) {\n        return RangeUtils.getAll(range, function(node) {\n            return node.className == 'k-marker';\n        });\n    },\n\n    image: function(range) {\n        var nodes = RangeUtils.getAll(range, \"img\");\n\n        if (nodes.length == 1) {\n            return nodes[0];\n        }\n    },\n\n    isStartOf: function(originalRange, node) {\n        if (originalRange.startOffset !== 0) {\n            return false;\n        }\n\n        var range = originalRange.cloneRange();\n\n        while (range.startOffset === 0 && range.startContainer != node) {\n            var index = dom.findNodeIndex(range.startContainer);\n            var parent = range.startContainer.parentNode;\n\n            while (index > 0 && parent[index - 1] && dom.insignificant(parent[index - 1])) {\n                index--;\n            }\n\n            range.setStart(parent, index);\n        }\n\n        return range.startOffset === 0 && range.startContainer == node;\n    },\n\n    isEndOf: function(originalRange, node) {\n        var range = originalRange.cloneRange();\n\n        range.collapse(false);\n\n        var start = range.startContainer;\n\n        if (dom.isDataNode(start) && range.startOffset == dom.getNodeLength(start)) {\n            range.setStart(start.parentNode, dom.findNodeIndex(start) + 1);\n            range.collapse(true);\n        }\n\n        range.setEnd(node, dom.getNodeLength(node));\n\n        var nodes = [];\n\n        function visit(node) {\n            if (!dom.insignificant(node) && !(dom.isDataNode(node) && /^[\\ufeff]*$/.test(node.nodeValue))) {\n                nodes.push(node);\n            }\n        }\n\n        new RangeIterator(range).traverse(visit);\n\n        return !nodes.length;\n    },\n\n    wrapSelectedElements: function(range) {\n        var startEditable = dom.editableParent(range.startContainer);\n        var endEditable = dom.editableParent(range.endContainer);\n\n        while (range.startOffset === 0 && range.startContainer != startEditable) {\n            range.setStart(range.startContainer.parentNode, dom.findNodeIndex(range.startContainer));\n        }\n\n        function isEnd(offset, container) {\n            var length = dom.getNodeLength(container);\n\n            if (offset == length) {\n                return true;\n            }\n\n            for (var i = offset; i < length; i++) {\n                if (!dom.insignificant(container.childNodes[i])) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        while (isEnd(range.endOffset, range.endContainer) && range.endContainer != endEditable) {\n            range.setEnd(range.endContainer.parentNode, dom.findNodeIndex(range.endContainer) + 1);\n        }\n\n        return range;\n    },\n\n    expand: function(range) {\n        var result = range.cloneRange();\n\n        var startContainer = result.startContainer.childNodes[result.startOffset === 0 ? 0 : result.startOffset - 1];\n        var endContainer = result.endContainer.childNodes[result.endOffset];\n\n        if (!isDataNode(startContainer) || !isDataNode(endContainer)) {\n            return result;\n        }\n\n        var beforeCaret = startContainer.nodeValue;\n        var afterCaret = endContainer.nodeValue;\n\n        if (!beforeCaret || !afterCaret) {\n            return result;\n        }\n\n        var startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n        var endOffset = afterCaret.search(boundary);\n\n        if (!startOffset || !endOffset) {\n            return result;\n        }\n\n        endOffset = endOffset == -1 ? afterCaret.length : endOffset;\n        startOffset = startOffset == -1 ? 0 : beforeCaret.length - startOffset;\n\n        result.setStart(startContainer, startOffset);\n        result.setEnd(endContainer, endOffset);\n\n        return result;\n    },\n\n    isExpandable: function(range) {\n        var node = range.startContainer;\n        var rangeDocument = RangeUtils.documentFromRange(range);\n\n        if (node == rangeDocument || node == rangeDocument.body) {\n            return false;\n        }\n\n        var result = range.cloneRange();\n\n        var value = node.nodeValue;\n        if (!value) {\n            return false;\n        }\n\n        var beforeCaret = value.substring(0, result.startOffset);\n        var afterCaret = value.substring(result.startOffset);\n\n        var startOffset = 0, endOffset = 0;\n\n        if (beforeCaret) {\n            startOffset = beforeCaret.split('').reverse().join('').search(boundary);\n        }\n\n        if (afterCaret) {\n            endOffset = afterCaret.search(boundary);\n        }\n\n        return startOffset && endOffset;\n    }\n};\n\nextend(Editor, {\n    SelectionUtils: SelectionUtils,\n    W3CRange: W3CRange,\n    RangeIterator: RangeIterator,\n    W3CSelection: W3CSelection,\n    RangeEnumerator: RangeEnumerator,\n    RestorePoint: RestorePoint,\n    Marker: Marker,\n    RangeUtils: RangeUtils\n});\n\n})(window.kendo.jQuery);\n\n}, __webpack_require__.amdD);\n\n\n/***/ }),\n\n/***/ 82231:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = require(\"./components\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/amd define */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.amdD = function () {\n/******/ \t\t\tthrow new Error('define cannot be used indirect');\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module used 'module' so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(12712);\n/******/ \tmodule.exports = __webpack_exports__;\n/******/ \t\n/******/ })()\n;"],"mappings":"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"},"metadata":{},"sourceType":"script"}